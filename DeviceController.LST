C51 COMPILER V9.55   DEVICECONTROLLER                                                      05/13/2016 13:32:28 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE DEVICECONTROLLER
OBJECT MODULE PLACED IN DeviceController.OBJ
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE DeviceController.c OBJECTADVANCED OPTIMIZE(8,SPEED) BROWSE NOINTPROMOTE 
                    -DEFINE(STARTERKIT) DEBUG TABS(2)

line level    source

   1          #include "DeviceController.h"
   2          #include "PinDefine.h"
   3          #include "UART.h"
   4          #include "FlashUtils.h"
   5          #include <string.h>
   6          
   7          #define PREDEFINED_UUID   "bfcf9428-eef6-4261-ae2e-e9d66c7e3d31"
   8          extern bool shouldMonitorHVStatus;
   9          
  10          
  11          void sendUUID() {
  12   1          //char xdata uuidString[50];
  13   1          //unsigned char code * currentFlashDataEndAddress = getFlashDataEndAddress();
  14   1          //readFlashToBuffer(uuidString, 50, currentFlashDataEndAddress);
  15   1          sendUART("#f#");
  16   1          sendUART(PREDEFINED_UUID);
  17   1          sendUART("#\n");
  18   1      }
  19          
  20          void enableLCChannel(char channelCode) {
  21   1          // Switch off all LC / LCR channel first.
  22   1          IO_vResetPin(LCR_CHANNEL_1);
  23   1          IO_vResetPin(LCR_CHANNEL_2);
  24   1          IO_vResetPin(LCR_CHANNEL_3);    
  25   1          IO_vResetPin(LC_CHANNEL_1);
  26   1          IO_vResetPin(LC_CHANNEL_2);
  27   1          IO_vResetPin(LC_CHANNEL_3);
  28   1      
  29   1          // Enable coressponding LCR channel GPIO
  30   1          switch(channelCode) {
  31   2              case '0':
  32   2                  sendUART("#b#0#\n");
  33   2                  break;
  34   2              case '1':
  35   2                  IO_vSetPin(LC_CHANNEL_1);
  36   2                  sendUART("#b#1#\n");
  37   2                  break;
  38   2              case '2':
  39   2                  IO_vSetPin(LC_CHANNEL_2);
  40   2                  sendUART("#b#2#\n");            
  41   2                  break;
  42   2              case '3':
  43   2                  IO_vSetPin(LC_CHANNEL_3);
  44   2                  sendUART("#b#3#\n");
  45   2                  break;
  46   2              default:
  47   2                  sendUART("#Unknown LC Channel.#\n");                    
  48   2                  break;
  49   2          }
  50   1      }
  51          
  52          void enableLCRChannel(char channelCode) {
  53   1          // Switch off all LC / LCR channel first.
  54   1          IO_vResetPin(LCR_CHANNEL_1);
C51 COMPILER V9.55   DEVICECONTROLLER                                                      05/13/2016 13:32:28 PAGE 2   

  55   1          IO_vResetPin(LCR_CHANNEL_2);
  56   1          IO_vResetPin(LCR_CHANNEL_3);
  57   1          IO_vResetPin(LC_CHANNEL_1);
  58   1          IO_vResetPin(LC_CHANNEL_2);
  59   1          IO_vResetPin(LC_CHANNEL_3);
  60   1      
  61   1          // Enable coressponding LCR channel GPIO
  62   1          switch(channelCode) {
  63   2              case '0':
  64   2                  sendUART("#a#0#\n");
  65   2                  break;
  66   2              case '1':
  67   2                  IO_vSetPin(LCR_CHANNEL_1);
  68   2                  sendUART("#a#1#\n");
  69   2                  break;
  70   2              case '2':
  71   2                  IO_vSetPin(LCR_CHANNEL_2);
  72   2                  sendUART("#a#2#\n");            
  73   2                  break;
  74   2              case '3':
  75   2                  IO_vSetPin(LCR_CHANNEL_3);
  76   2                  sendUART("#a#3#\n");
  77   2                  break;
  78   2              default:
  79   2                  sendUART("#Unknown LCR Channel.#\n");                   
  80   2                  break;
  81   2          }
  82   1      }
  83          
  84          bool isAllHVRelayOK() {
  85   1      #ifdef STARTER_KIT_EMU
                  return IO_ubReadPin(HV_READY_1);
              #else
  88   1          return 
  89   1              IO_ubReadPin(HV_READY_1) &&
  90   1              IO_ubReadPin(HV_READY_2) &&
  91   1              IO_ubReadPin(HV_READY_3) &&
  92   1              IO_ubReadPin(HV_FAULT_1) &&
  93   1              IO_ubReadPin(HV_FAULT_2) &&
  94   1              IO_ubReadPin(HV_FAULT_3);
  95   1      #endif
  96   1      }
  97          
  98          void sendHVRelayStatus() {
  99   1          if (IO_ubReadPin(HV_READY_1)) {
 100   2              sendUART("HV_READY_1: OK\n");
 101   2          } else {
 102   2              sendUART("HV_READY_1: NG\n");
 103   2          }
 104   1      
 105   1          if (IO_ubReadPin(HV_READY_2)) {
 106   2              sendUART("HV_READY_2: OK\n");
 107   2          } else {
 108   2              sendUART("HV_READY_2: NG\n");
 109   2          }
 110   1      
 111   1          if (IO_ubReadPin(HV_READY_3)) {
 112   2              sendUART("HV_READY_3: OK\n");
 113   2          } else {
 114   2              sendUART("HV_READY_3: NG\n");
 115   2          }
 116   1      
C51 COMPILER V9.55   DEVICECONTROLLER                                                      05/13/2016 13:32:28 PAGE 3   

 117   1          if (IO_ubReadPin(HV_FAULT_1)) {
 118   2              sendUART("HV_FAULT_1: OK\n");
 119   2          } else {
 120   2              sendUART("HV_FAULT_1: NG\n");
 121   2          }
 122   1      
 123   1          if (IO_ubReadPin(HV_FAULT_2)) {
 124   2              sendUART("HV_FAULT_2: OK\n");
 125   2          } else {
 126   2              sendUART("HV_FAULT_2: NG\n");
 127   2          }
 128   1      
 129   1          if (IO_ubReadPin(HV_FAULT_3)) {
 130   2              sendUART("HV_FAULT_3: OK\n");
 131   2          } else {
 132   2              sendUART("HV_FAULT_3: NG\n");
 133   2          }
 134   1      
 135   1      
 136   1          if (isAllHVRelayOK()) {
 137   2              sendUART("#d#1#\n");
 138   2          } else {
 139   2              sendUART("#d#0#\n");            
 140   2          }
 141   1      }
 142          
 143          void setChargeMode(char modeCode) {
 144   1          if (modeCode == '0') {
 145   2              IO_vResetPin(HV_CHANNEL);               
 146   2              IO_vSetPin(DISCHARGE_CHANNEL);
 147   2              IO_vSetPin(CHARGE_CHANNEL);
 148   2              sendUART("#c#0#\n");            
 149   2          } else if (modeCode == '1') {
 150   2              if (!isAllHVRelayOK()) {
 151   3                  IO_vResetPin(HV_CHANNEL);                       
 152   3                  IO_vSetPin(CHARGE_CHANNEL);
 153   3                  IO_vSetPin(DISCHARGE_CHANNEL);
 154   3                  sendUART("#d#0#\n");
 155   3                  return;
 156   3              }
 157   2              IO_vSetPin(DISCHARGE_CHANNEL);
 158   2              IO_vSetPin(HV_CHANNEL);
 159   2              IO_vResetPin(CHARGE_CHANNEL);
 160   2              sendUART("#c#1#\n");
 161   2          } else if (modeCode == '2') {
 162   2              IO_vSetPin(CHARGE_CHANNEL);
 163   2              IO_vResetPin(HV_CHANNEL);
 164   2              IO_vResetPin(DISCHARGE_CHANNEL);
 165   2              sendUART("#c#2#\n");
 166   2          } else {
 167   2              sendUART("#Unknown Charge Mode#\n");            
 168   2          }
 169   1      }
 170          
 171          void setHVMonitorMode(char modeCode) {
 172   1          if (modeCode == '1') {
 173   2              shouldMonitorHVStatus = 1;
 174   2              sendUART("#e#1#\n");
 175   2          } else if (modeCode == '0') {
 176   2              shouldMonitorHVStatus = 0;
 177   2              sendUART("#e#0#\n");
 178   2          } else {
C51 COMPILER V9.55   DEVICECONTROLLER                                                      05/13/2016 13:32:28 PAGE 4   

 179   2              sendUART("#Unknown HV Monitor Code#\n");
 180   2          }
 181   1      
 182   1      }
 183          
 184          void setUUID(char * command) {
 185   1          unsigned char code * flashEndAddress = getFlashDataEndAddress();        
 186   1          char xdata uuidString[37] = {0};
 187   1          strncpy(uuidString, command+3, 36);
 188   1          sendUART("Setting UUID to ");
 189   1          sendUART(uuidString);
 190   1          sendUART("....\n");
 191   1          sendUART("Please wait...");
 192   1          writeBufferToFlash(uuidString, &flashEndAddress);
 193   1          sendUART("DONE\n");
 194   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    696    ----
   CONSTANT SIZE    =    519    ----
   XDATA SIZE       =   ----      37
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       7
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
