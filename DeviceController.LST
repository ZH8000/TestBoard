C51 COMPILER V9.54   DEVICECONTROLLER                                                      03/18/2016 11:04:41 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE DEVICECONTROLLER
OBJECT MODULE PLACED IN DeviceController.OBJ
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE DeviceController.c OBJECTADVANCED OPTIMIZE(8,SPEED) BROWSE NOINTPROMOTE 
                    -DEFINE(STARTERKIT) DEBUG TABS(2)

line level    source

   1          #include "DeviceController.h"
   2          #include "PinDefine.h"
   3          #include "UART.h"
   4          #include "FlashUtils.h"
   5          #include <string.h>
   6          
   7          extern bool shouldMonitorHVStatus;
   8          void sendUUID() {
   9   1        char xdata uuidString[50];
  10   1        unsigned char code * currentFlashDataEndAddress = getFlashDataEndAddress();
  11   1        readFlashToBuffer(uuidString, 50, currentFlashDataEndAddress);
  12   1        sendUART(uuidString);
  13   1        sendUART("\r\n");
  14   1      }
  15          
  16          void enableLCChannel(char channelCode) {
  17   1        // Switch off all LCR channel first.
  18   1        IO_vResetPin(LC_CHANNEL_1);
  19   1        IO_vResetPin(LC_CHANNEL_2);
  20   1        IO_vResetPin(LC_CHANNEL_3);
  21   1        
  22   1        // Enable coressponding LCR channel GPIO
  23   1        switch(channelCode) {
  24   2          case '0':
  25   2            sendUART("#b#0#\r\n");
  26   2            break;
  27   2          case '1':
  28   2            IO_vSetPin(LC_CHANNEL_1);
  29   2            sendUART("#b#1#\r\n");
  30   2            break;
  31   2          case '2':
  32   2            IO_vSetPin(LC_CHANNEL_2);
  33   2            sendUART("#b#2#\r\n");    
  34   2            break;
  35   2          case '3':
  36   2            IO_vSetPin(LC_CHANNEL_3);
  37   2            sendUART("#b#3#\r\n");
  38   2            break;
  39   2          default:
  40   2            sendUART("Unknown LC Channel.\r\n");      
  41   2            break;
  42   2        }
  43   1      }
  44          
  45          void enableLCRChannel(char channelCode) {
  46   1        // Switch off all LCR channel first.
  47   1        IO_vResetPin(LCR_CHANNEL_1);
  48   1        IO_vResetPin(LCR_CHANNEL_2);
  49   1        IO_vResetPin(LCR_CHANNEL_3);
  50   1        
  51   1        // Enable coressponding LCR channel GPIO
  52   1        switch(channelCode) {
  53   2          case '0':
  54   2            sendUART("#a#0#\r\n");
C51 COMPILER V9.54   DEVICECONTROLLER                                                      03/18/2016 11:04:41 PAGE 2   

  55   2            break;
  56   2          case '1':
  57   2            IO_vSetPin(LCR_CHANNEL_1);
  58   2            sendUART("#a#1#\r\n");
  59   2            break;
  60   2          case '2':
  61   2            IO_vSetPin(LCR_CHANNEL_2);
  62   2            sendUART("#a#2#\r\n");    
  63   2            break;
  64   2          case '3':
  65   2            IO_vSetPin(LCR_CHANNEL_3);
  66   2            sendUART("#a#3#\r\n");
  67   2            break;
  68   2          default:
  69   2            sendUART("Unknown LCR Channel.\r\n");     
  70   2            break;
  71   2        }
  72   1      }
  73          
  74          bool isAllHVRelayOK() {
  75   1        #ifdef STARTER_KIT_EMU
  76   1          return IO_ubReadPin(HV_READY_1);
  77   1        #else
                  return 
                    IO_ubReadPin(HV_READY_1) &&
                    IO_ubReadPin(HV_READY_2) &&
                    IO_ubReadPin(HV_READY_3) &&
                    IO_ubReadPin(HV_FAULT_1) &&
                    IO_ubReadPin(HV_FAULT_2) &&
                    IO_ubReadPin(HV_FAULT_3);
                #endif
  86   1      }
  87          
  88          void sendHVRelayStatus() {
  89   1        if (isAllHVRelayOK()) {
  90   2          sendUART("HV_OK\r\n");
  91   2        } else {
  92   2          sendUART("HV_NG\r\n");    
  93   2        }
  94   1      }
  95          
  96          void setChargeMode(char modeCode) {
  97   1        if (modeCode == '1') {
  98   2          if (!isAllHVRelayOK()) {
  99   3            IO_vResetPin(HV_CHANNEL);     
 100   3            IO_vResetPin(CHARGE_CHANNEL);
 101   3            IO_vResetPin(DISCHARGE_CHANNEL);
 102   3            sendUART("HV_NG\r\n");
 103   3            return;
 104   3          }
 105   2          IO_vResetPin(DISCHARGE_CHANNEL);
 106   2          IO_vSetPin(HV_CHANNEL);
 107   2          IO_vSetPin(CHARGE_CHANNEL);
 108   2          sendUART("#c#1#\r\n");
 109   2        } else if (modeCode == '0') {
 110   2          IO_vResetPin(CHARGE_CHANNEL);
 111   2          IO_vResetPin(HV_CHANNEL);
 112   2          IO_vSetPin(DISCHARGE_CHANNEL);
 113   2          sendUART("#c#0#\r\n");
 114   2        } else {
 115   2          sendUART("Unknown Charge Mode\r\n");    
 116   2        }
C51 COMPILER V9.54   DEVICECONTROLLER                                                      03/18/2016 11:04:41 PAGE 3   

 117   1      }
 118          
 119          void setHVMonitorMode(char modeCode) {
 120   1        if (modeCode == '1') {
 121   2          shouldMonitorHVStatus = 1;
 122   2          sendUART("#e#1#\r\n");
 123   2        } else if (modeCode == '0') {
 124   2          shouldMonitorHVStatus = 0;
 125   2          sendUART("#e#0#\r\n");
 126   2        } else {
 127   2          sendUART("Unknown HV Monitor Code\r\n");
 128   2        }
 129   1        
 130   1      }
 131          
 132          void setUUID(char * command) {
 133   1        unsigned char code * flashEndAddress = getFlashDataEndAddress();  
 134   1        char xdata uuidString[37] = {0};
 135   1        strncpy(uuidString, command+3, 36);
 136   1        sendUART("Setting UUID to ");
 137   1        sendUART(uuidString);
 138   1        sendUART("....\r\n");
 139   1        sendUART("Please wait...");
 140   1        writeBufferToFlash(uuidString, &flashEndAddress);
 141   1        sendUART("DONE\r\n");
 142   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    497    ----
   CONSTANT SIZE    =    291    ----
   XDATA SIZE       =   ----      87
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       7
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
