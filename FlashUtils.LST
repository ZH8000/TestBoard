C51 COMPILER V9.54   FLASHUTILS                                                            03/18/2016 11:02:42 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE FLASHUTILS
OBJECT MODULE PLACED IN FlashUtils.OBJ
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE FlashUtils.c OBJECTADVANCED OPTIMIZE(8,SPEED) BROWSE NOINTPROMOTE DEFINE
                    -(STARTERKIT) DEBUG TABS(2)

line level    source

   1          #include "FlashHandler.h"
   2          #include "FlashUtils.h"
   3          
   4          #include <string.h>
   5          
   6          #define FLASH_FIRST_ADDR       BASEADDR   
   7          #define FLASH_LAST_ADDR        WORDLINEADDR(96)
   8          #define FLASH_BANK_TO_CHECK    DFLASH0
   9          #define DFL0_SECTOR_ERASE      SECALL
  10          extern void delay(int second);
  11          
  12          unsigned char code * getFlashDataEndAddress() {
  13   1        // Initialize the pointer to the FLASH (Checking if there is a valid data)
  14   1        unsigned char code * EECurrentAddr = (unsigned char code*)FLASH_LAST_ADDR;
  15   1        unsigned char code * EETempAddr;
  16   1                
  17   1        for (EETempAddr = (unsigned char code*)FLASH_FIRST_ADDR; EETempAddr <= (unsigned char code*)FLASH_LAST_A
             -DDR; EETempAddr += BYTES_PER_WORDLINE)
  18   1        {
  19   2          if (*EETempAddr == 0)
  20   2          {
  21   3            EECurrentAddr = EETempAddr;
  22   3            break;
  23   3          }
  24   2        }
  25   1        return EECurrentAddr;
  26   1      }
  27          
  28          
  29          void writeToFlashPage(char xdata * buffer, unsigned char code ** EECurrentAddr) {
  30   1        int i = 0;
  31   1      
  32   1        for (i=0; i < BYTES_PER_WORDLINE; i++) {
  33   2          WLBuf[i] = *buffer;
  34   2          buffer++;
  35   2        }
  36   1      
  37   1        // Start the Flash Programming
  38   1        if (FLASH_Prog(*EECurrentAddr)) 
  39   1        {
  40   2          *EECurrentAddr = *EECurrentAddr + BYTES_PER_WORDLINE;
  41   2        }
  42   1        delay(2);
  43   1        
  44   1      }
  45          
  46          void readFlashToBuffer(char xdata * buffer, int n, unsigned char code * EECurrentAddr) 
  47          {
  48   1        unsigned char code * EETempAddr = (unsigned char code*)FLASH_FIRST_ADDR;
  49   1        int i = 0;
  50   1        int j = 0;
  51   1        int k = 0;
  52   1        memset(buffer, 0, n);
  53   1        
C51 COMPILER V9.54   FLASHUTILS                                                            03/18/2016 11:02:42 PAGE 2   

  54   1        while (FLASH_Ready(FLASH_BANK_TO_CHECK) == 0) {;}
  55   1        
  56   1        while (EETempAddr < EECurrentAddr && j < n) 
  57   1        { 
  58   2          i = 0;
  59   2          while (*(EETempAddr+i) != 0) {
  60   3            buffer[j] = *(EETempAddr+i);
  61   3            i++;
  62   3            j++;
  63   3          }
  64   2          EETempAddr = EETempAddr + BYTES_PER_WORDLINE;   
  65   2        } 
  66   1      }
  67          
  68          void writeBufferToFlash(char * buffer, unsigned char code ** EECurrentAddr) {
  69   1        char xdata pageBuffer[BYTES_PER_WORDLINE] = {0};
  70   1        char * currentCharacter = buffer;
  71   1        int i = 0;
  72   1        
  73   1        FLASH_Erase(SECALL,0);
  74   1        *EECurrentAddr = (unsigned char code*)FLASH_FIRST_ADDR;     // if erase than 1. WL is current
  75   1        delay(2);
  76   1        
  77   1        memset(pageBuffer, 0, BYTES_PER_WORDLINE);
  78   1        while (*currentCharacter != 0) {
  79   2          
  80   2          pageBuffer[i] = *currentCharacter;
  81   2          if (i == 25) {
  82   3            writeToFlashPage(pageBuffer, EECurrentAddr);
  83   3            memset(pageBuffer, 0, BYTES_PER_WORDLINE);
  84   3            i = 0;
  85   3          } else {
  86   3            i++;
  87   3          }
  88   2          currentCharacter++;
  89   2        }
  90   1        writeToFlashPage(pageBuffer, EECurrentAddr);  
  91   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    496    ----
   CONSTANT SIZE    =     32    ----
   XDATA SIZE       =   ----      32
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      30
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
