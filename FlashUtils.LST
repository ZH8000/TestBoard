C51 COMPILER V9.54   FLASHUTILS                                                            03/17/2016 16:16:15 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE FLASHUTILS
OBJECT MODULE PLACED IN FlashUtils.OBJ
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE FlashUtils.c OBJECTADVANCED OPTIMIZE(8,SPEED) BROWSE NOINTPROMOTE DEFINE
                    -(STARTERKIT) DEBUG TABS(2)

line level    source

   1          #include "FlashHandler.h"
   2          #include "FlashUtils.h"
   3          
   4          #include <string.h>
   5          
   6          #define FLASH_FIRST_ADDR       BASEADDR   
   7          #define FLASH_LAST_ADDR        WORDLINEADDR(96)
   8          #define FLASH_BANK_TO_CHECK    DFLASH0
   9          #define DFL0_SECTOR_ERASE      SECALL
  10          extern void delay(int second);
  11          
  12          unsigned char code * getFlashDataEndAddress() {
  13   1        // Initialize the pointer to the FLASH (Checking if there is a valid data)
  14   1        unsigned char code * EECurrentAddr = (unsigned char code*)FLASH_LAST_ADDR;
  15   1        unsigned char code * EETempAddr;
  16   1                
  17   1        for (EETempAddr = (unsigned char code*)FLASH_FIRST_ADDR; EETempAddr <= (unsigned char code*)FLASH_LAST_A
             -DDR; EETempAddr += BYTES_PER_WORDLINE)
  18   1        {
  19   2          if (*EETempAddr == 0)
  20   2          {
  21   3            EECurrentAddr = EETempAddr;
  22   3            break;
  23   3          }
  24   2        }
  25   1        return EECurrentAddr;
  26   1      }
  27          
  28          
  29          void writeToFlashPage(char xdata * buffer, unsigned char code ** EECurrentAddr) {
  30   1        int i = 0;
  31   1      
  32   1        for (i=0; i < BYTES_PER_WORDLINE; i++) {
  33   2          WLBuf[i] = *buffer;
  34   2          buffer++;
  35   2        }
  36   1      
  37   1        // Start the Flash Programming
  38   1        if (FLASH_Prog(*EECurrentAddr)) 
  39   1        {
  40   2          *EECurrentAddr = *EECurrentAddr + BYTES_PER_WORDLINE;
  41   2        } 
  42   1        
  43   1      }
  44          
  45          void readFlashToBuffer(char xdata * buffer, int n, unsigned char code * EECurrentAddr) 
  46          {
  47   1        unsigned char code * EETempAddr = (unsigned char code*)FLASH_FIRST_ADDR;
  48   1        int i = 0;
  49   1        int j = 0;
  50   1        int k = 0;
  51   1        memset(buffer, 0, n);
  52   1        
  53   1        while (FLASH_Ready(FLASH_BANK_TO_CHECK) == 0) {;}
C51 COMPILER V9.54   FLASHUTILS                                                            03/17/2016 16:16:15 PAGE 2   

  54   1        
  55   1        while (EETempAddr < EECurrentAddr && j < n) 
  56   1        { 
  57   2          i = 0;
  58   2          while (*(EETempAddr+i) != 0) {
  59   3            buffer[j] = *(EETempAddr+i);
  60   3            i++;
  61   3            j++;
  62   3          }
  63   2          EETempAddr = EETempAddr + BYTES_PER_WORDLINE;   
  64   2        } 
  65   1      }
  66          
  67          void writeBufferToFlash(char * buffer, unsigned char code ** EECurrentAddr) {
  68   1        char xdata pageBuffer[BYTES_PER_WORDLINE] = {0};
  69   1        char * currentCharacter = buffer;
  70   1        int i = 0;
  71   1        
  72   1        FLASH_Erase(SECALL,0);
  73   1        *EECurrentAddr = (unsigned char code*)FLASH_FIRST_ADDR;     // if erase than 1. WL is current
  74   1        delay(2);
  75   1        
  76   1        memset(pageBuffer, 0, BYTES_PER_WORDLINE);
  77   1        while (*currentCharacter != 0) {
  78   2          
  79   2          pageBuffer[i] = *currentCharacter;
  80   2          if (i == 25) {
  81   3            writeToFlashPage(pageBuffer, EECurrentAddr);
  82   3            memset(pageBuffer, 0, BYTES_PER_WORDLINE);
  83   3            i = 0;
  84   3          } else {
  85   3            i++;
  86   3          }
  87   2          currentCharacter++;
  88   2        }
  89   1        writeToFlashPage(pageBuffer, EECurrentAddr);  
  90   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    490    ----
   CONSTANT SIZE    =     32    ----
   XDATA SIZE       =   ----      32
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      30
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
