LX51 LINKER/LOCATER V4.66.41.0                                                          03/18/2016  10:54:36  PAGE 1





ASSEMBLER CODE PACKING OF MODULE:  TestBoard (?C_STARTUP)


----- FUNCTION isAllHVRelayOK (BEGIN) -----
 FILE: 'DeviceController.c'
   73: bool isAllHVRelayOK() {
   74: 	#ifdef STARTER_KIT_EMU
   75: 		return IO_ubReadPin(HV_READY_1);
000020 A2C8              MOV      C,P4_0
   76: 	#else
   77: 		return 
   78: 			IO_ubReadPin(HV_READY_1) &&
   79: 			IO_ubReadPin(HV_READY_2) &&
   80: 			IO_ubReadPin(HV_READY_3) &&
   81: 			IO_ubReadPin(HV_FAULT_1) &&
   82: 			IO_ubReadPin(HV_FAULT_2) &&
   83: 			IO_ubReadPin(HV_FAULT_3);
   84: 	#endif
   85: }
000022 22                RET      
----- FUNCTION isAllHVRelayOK (END) -------


000023 0208B9            LJMP     08B9H
----- FUNCTION MAIN_vInit (BEGIN) -----
 FILE: 'MAIN.C'
   30: void MAIN_vInit(void)
   31: {
   32:   ///  -----------------------------------------------------------------------
   33:   ///  Configuration of the System Clock:
   34:   ///  -----------------------------------------------------------------------
   35:   ///  - On Chip Osc is Selected
   36:   ///  - PLL Mode, NDIV =  20
   37:   ///  - input frequency is 9.6 MHz
   38: 
   39:   //   FCLK runs at 2 times the frequency of PCLK.
   40:   SFR_PAGE(_su1, noSST);         // switch to page1
000525 75BF01            MOV      SCU_PAGE,#01H
   41:   CMCON         =  0x10;         // load Clock Control Register
000528 75BA10            MOV      CMCON,#010H
   42:   SFR_PAGE(_su0, noSST);         // switch to page0
00052B E4                CLR      A
00052C F5BF              MOV      SCU_PAGE,A
   43: 
   44: 
   45:   ///  *********************************************************************************
   46:   ///  Note : All peripheral related IO configurations are done in the 
   47:   ///  respective peripheral modules (alternate functions selection)
   48:   ///  *********************************************************************************
   49: 
   50:   ///  Initialization of module 'GPIO'
   51:   IO_vInit();
00052E B13F              ACALL    IO_vInit
   52: 
   53:   ///  Initialization of module 'UART (Serial Interface)'
   54:   UART_vInit();
000530 120893            LCALL    UART_vInit
   55: 
   56:   //   Interrupt Priority
   57: 
   58:   IP            =  0x00;         // load Interrupt Priority Register
000533 E4                CLR      A
000534 F5B8              MOV      IP,A
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:54:36  PAGE 2


   59:   IPH           =  0x00;         // load Interrupt Priority High Register
000536 F5B9              MOV      IPH,A
   60:   IP1           =  0x00;         // load Interrupt Priority 1 Register
000538 F5F8              MOV      IP1,A
   61:   IPH1          =  0x00;         // load Interrupt Priority 1 High Register
00053A F5F9              MOV      IPH1,A
   62: 
   63: 
   64:   //// Interrupt structure 2 mode 0 is selected.
   65:   //// Interrupt service routine choice 2 is selected.
   66:   //   globally enable interrupts
   67:   EA            =  1;           
00053C D2AF              SETB     EA
   68: 
   69: } 
00053E 22                RET      
----- FUNCTION MAIN_vInit (END) -------


----- FUNCTION IO_vInit (BEGIN) -----
 FILE: 'IO.C'
   49: void IO_vInit(void)
   50: {
   51: 	#ifdef STARTER_KIT_EMU
   52: 		P1_DIR        		= 0x04; 
00053F 759104            MOV      P1_DIR,#04H
   53: 		P1_DATA       		= 0x00;
000542 E4                CLR      A
000543 F590              MOV      P1_DATA,A
   54: 		P3_DIR			  		= 0xFF;
000545 75B1FF            MOV      P3_DIR,#0FFH
   55: 		P3_DATA						= 0x00;
000548 F5B0              MOV      P3_DATA,A
   56: 	#else
   57: 
   58: 		///  -----------------------------------------------------------------------
   59: 		///  Configuration of Port P0:
   60: 		///  -----------------------------------------------------------------------
   61: 		///  - no pin of port P0 is used
   62: 
   63: 
   64: 		///  -----------------------------------------------------------------------
   65: 		///  Configuration of Port P1:
   66: 		///  -----------------------------------------------------------------------
   67: 		///  P1.0:
   68: 		///  - is used as general purpose output
   69: 		///  - push/pull output is selected
   70: 		///  - the pin status is low level
   71: 		///  - pull-up device is assigned
   72: 		///  P1.1:
   73: 		///  - is used as general purpose output
   74: 		///  - push/pull output is selected
   75: 		///  - the pin status is low level
   76: 		///  - pull-up device is assigned
   77: 		///  P1.2:
   78: 		///  - is used as general purpose output
   79: 		///  - push/pull output is selected
   80: 		///  - the pin status is low level
   81: 		///  - pull-up device is assigned
   82: 		///  P1.3:
   83: 		///  - is used as general purpose output
   84: 		///  - push/pull output is selected
   85: 		///  - the pin status is low level
   86: 		///  - pull-up device is assigned
   87: 		///  P1.4:
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:54:36  PAGE 3


   88: 		///  - is used as general purpose output
   89: 		///  - push/pull output is selected
   90: 		///  - the pin status is low level
   91: 		///  - pull-up device is assigned
   92: 		///  P1.5:
   93: 		///  - is used as general purpose output
   94: 		///  - push/pull output is selected
   95: 		///  - the pin status is low level
   96: 		///  - pull-up device is assigned
   97: 
   98: 
   99: 		P1_DIR        =  0x3F;         // load direction register
  100: 
  101: 		///  -----------------------------------------------------------------------
  102: 		///  Configuration of Port P2:
  103: 		///  -----------------------------------------------------------------------
  104: 		///  - no pin of port P2 is used
  105: 
  106: 
  107: 		///  -----------------------------------------------------------------------
  108: 		///  Configuration of Port P3:
  109: 		///  -----------------------------------------------------------------------
  110: 		///  P3.4:
  111: 		///  - is used as general purpose output
  112: 		///  - push/pull output is selected
  113: 		///  - the pin status is low level
  114: 		///  - pull device is disabled (tristate) 
  115: 		///  P3.5:
  116: 		///  - is used as general purpose output
  117: 		///  - push/pull output is selected
  118: 		///  - the pin status is low level
  119: 		///  - pull device is disabled (tristate) 
  120: 		///  P3.6:
  121: 		///  - is used as general purpose output
  122: 		///  - push/pull output is selected
  123: 		///  - the pin status is low level
  124: 		///  - pull device is disabled (tristate) 
  125: 		///  P3.7:
  126: 		///  - is used as general purpose output
  127: 		///  - push/pull output is selected
  128: 		///  - the pin status is low level
  129: 		///  - pull device is disabled (tristate) 
  130: 
  131: 
  132: 		P3_DIR        =  0xF0;         // load direction register
  133: 
  134: 		///  -----------------------------------------------------------------------
  135: 		///  Configuration of Port P4:
  136: 		///  -----------------------------------------------------------------------
  137: 		///  P4.0:
  138: 		///  - is used as general input
  139: 		///  - pull device is disabled (tristate) 
  140: 		///  P4.1:
  141: 		///  - is used as general input
  142: 		///  - pull device is disabled (tristate) 
  143: 		///  P4.2:
  144: 		///  - is used as general input
  145: 		///  - pull-up device is assigned
  146: 		///  P4.3:
  147: 		///  - is used as general input
  148: 		///  - pull device is disabled (tristate) 
  149: 		///  P4.4:
  150: 		///  - is used as general input
  151: 		///  - pull device is disabled (tristate) 
  152: 		///  P4.5:
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:54:36  PAGE 4


  153: 		///  - is used as general input
  154: 		///  - pull device is disabled (tristate) 
  155: 
  156: 
  157: 		///  -----------------------------------------------------------------------
  158: 		///  Configuration of Port P5:
  159: 		///  -----------------------------------------------------------------------
  160: 		///  - no pin of port P5 is used
  161: 	#endif
  162: 
  163: } //  End of function IO_vInit
00054A 22                RET      
----- FUNCTION IO_vInit (END) -------


----- FUNCTION main (BEGIN) -----
 FILE: 'MAIN.C'
   79: void main(void)
   80: {
   81:   MAIN_vInit();
   82: 	
00054B B125              ACALL    MAIN_vInit
00054D         ?C0012?MAIN:
   83:   while(1) {
   84: 		
   85: 		if (shouldMonitorHVStatus && !isAllHVRelayOK()) {
00054D 30030C            JNB      shouldMonitorHVStatus,?C0014?MAIN
000550 1120              ACALL    isAllHVRelayOK
000552 4008              JC       ?C0014?MAIN
   86: 			sendUART("HV_NG\r\n");
000554 7BFF              MOV      R3,#0FFH
000556 7A00              MOV      R2,#HIGH 01000018H
000558 7918              MOV      R1,#LOW 01000018H
00055A B164              ACALL    _sendUART
   87: 		}
00055C         ?C0014?MAIN:
   88: 			
   89: 		delay(1);
00055C 7F01              MOV      R7,#01H
00055E 7E00              MOV      R6,#00H
000560 D1EC              ACALL    _delay
   90: 	}
000562 80E9              SJMP     ?C0012?MAIN
----- FUNCTION main (END) -------


----- FUNCTION _sendUART (BEGIN) -----
 FILE: 'UART.C'
  133: void sendUART(char * message) {
  134: 	char * current = message;
;---- Variable 'message' assigned to Register 'R1/R2/R3' ----
  135: 	while (*current != '\0') {
;---- Variable 'current' assigned to Register 'R1/R2/R3' ----
000564         ?C0002?UART:
  136: 		SBUF = *current;
000564 311C              ACALL    ?C?CLDPTR
000566 6010              JZ       ?C0006?UART
  137: 		while (TI == 0);
000568 F599              MOV      SBUF,A
00056A         ?C0004?UART:
  138: 		TI = 0;		
00056A 3099FD            JNB      TI,?C0004?UART
00056D         ?C0005?UART:
  139: 		current++;
00056D C299              CLR      TI
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:54:36  PAGE 5


  140: 	}
00056F 7401              MOV      A,#01H
000571 29                ADD      A,R1
000572 F9                MOV      R1,A
000573 E4                CLR      A
000574 3A                ADDC     A,R2
000575 FA                MOV      R2,A
  141: }
000576 80EC              SJMP     ?C0002?UART
  142: 
000578         ?C0006?UART:
000578 22                RET      
----- FUNCTION _sendUART (END) -------


----- FUNCTION sendUUID (BEGIN) -----
 FILE: 'DeviceController.c'
    7: void sendUUID() {
    8: 	char xdata uuidString[50];
    9: 	unsigned char code * currentFlashDataEndAddress = getFlashDataEndAddress();
000579 120AA6            LCALL    getFlashDataEndAddress
;---- Variable 'currentFlashDataEndAddress' assigned to Register 'R2/R3' ----
00057C AB07              MOV      R3,AR7
00057E AA06              MOV      R2,AR6
   10: 	readFlashToBuffer(uuidString, 50, currentFlashDataEndAddress);
000580 7EF0              MOV      R6,#HIGH uuidString
000582 7FC8              MOV      R7,#LOW uuidString
000584 7D32              MOV      R5,#032H
000586 7C00              MOV      R4,#00H
000588 1209E5            LCALL    _readFlashToBuffer
   11: 	sendUART(uuidString);
00058B 7B01              MOV      R3,#01H
00058D 7AF0              MOV      R2,#HIGH uuidString
00058F 79C8              MOV      R1,#LOW uuidString
000591 B164              ACALL    _sendUART
   12: 	sendUART("\r\n");
000593 7BFF              MOV      R3,#0FFH
000595 7A02              MOV      R2,#HIGH 01000226H
000597 7926              MOV      R1,#LOW 01000226H
000599 80C9              SJMP     _sendUART
----- FUNCTION sendUUID (END) -------


----- FUNCTION _processCommand (BEGIN) -----
 FILE: 'UART.C'
  143: void processCommand(char * command) {
  144: 	
00059B 8B3F              MOV      command,R3
00059D 8A40              MOV      command+01H,R2
00059F 8941              MOV      command+02H,R1
  145: 	int commandSize = strlen(command);
0005A1 1103              ACALL    _strlen
0005A3 8E42              MOV      commandSize,R6
0005A5 8F43              MOV      commandSize+01H,R7
  146: 	char xdata respondMessage[MAX_RESPONSE_LENGTH] = {0};
0005A7 7800              MOV      R0,#LOW respondMessage
0005A9 7CF0              MOV      R4,#HIGH respondMessage
0005AB 7D01              MOV      R5,#01H
0005AD 7BFF              MOV      R3,#0FFH
0005AF 7A03              MOV      R2,#HIGH _?ix1000
0005B1 7934              MOV      R1,#LOW _?ix1000
0005B3 7E00              MOV      R6,#00H
0005B5 7FC8              MOV      R7,#0C8H
0005B7 11F6              ACALL    ?C?COPY
  147: 	bool isNormalCommand = commandSize == 5 && command[0] == '$' && command[2] == '$' && command[4] == '$';
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:54:36  PAGE 6


0005B9 E543              MOV      A,commandSize+01H
0005BB 6405              XRL      A,#05H
0005BD 4542              ORL      A,commandSize
0005BF 701E              JNZ      ?C0007?UART
0005C1 AB3F              MOV      R3,command
0005C3 AA40              MOV      R2,command+01H
0005C5 A941              MOV      R1,command+02H
0005C7 311C              ACALL    ?C?CLDPTR
0005C9 B42413            CJNE     A,#024H,?C0007?UART
0005CC 900002            MOV      DPTR,#02H
0005CF 3135              ACALL    ?C?CLDOPTR
0005D1 B4240B            CJNE     A,#024H,?C0007?UART
0005D4 900004            MOV      DPTR,#04H
0005D7 3135              ACALL    ?C?CLDOPTR
0005D9 B42403            CJNE     A,#024H,?C0007?UART
0005DC D3                SETB     C
0005DD 8001              SJMP     ?C0008?UART
0005DF         ?C0007?UART:
0005DF C3                CLR      C
0005E0         ?C0008?UART:
0005E0 9200              MOV      isNormalCommand,C
  148: 	bool isSetUUIDCommand = commandSize == 40 && command[0] == '$' && command[1] == 'f' && command[2] == '$' && comm
>> and[39] == '$';
0005E2 E543              MOV      A,commandSize+01H
0005E4 6428              XRL      A,#028H
0005E6 4542              ORL      A,commandSize
0005E8 7027              JNZ      ?C0009?UART
0005EA AB3F              MOV      R3,command
0005EC AA40              MOV      R2,command+01H
0005EE A941              MOV      R1,command+02H
0005F0 311C              ACALL    ?C?CLDPTR
0005F2 6424              XRL      A,#024H
0005F4 701B              JNZ      ?C0009?UART
0005F6 900001            MOV      DPTR,#01H
0005F9 3135              ACALL    ?C?CLDOPTR
0005FB B46613            CJNE     A,#066H,?C0009?UART
0005FE 900002            MOV      DPTR,#02H
000601 3135              ACALL    ?C?CLDOPTR
000603 B4240B            CJNE     A,#024H,?C0009?UART
000606 900027            MOV      DPTR,#027H
000609 3135              ACALL    ?C?CLDOPTR
00060B B42403            CJNE     A,#024H,?C0009?UART
00060E D3                SETB     C
00060F 8001              SJMP     ?C0010?UART
000611         ?C0009?UART:
000611 C3                CLR      C
000612         ?C0010?UART:
000612 9201              MOV      isSetUUIDCommand,C
  149: 	
  150: 	memset(respondMessage, 0, MAX_RESPONSE_LENGTH);	
000614 7E00              MOV      R6,#00H
000616 7FC8              MOV      R7,#0C8H
000618 7D00              MOV      R5,#00H
00061A 7B01              MOV      R3,#01H
00061C 7AF0              MOV      R2,#HIGH respondMessage
00061E 7900              MOV      R1,#LOW respondMessage
000620 31E4              ACALL    ?C?MEMSET
  151: 
  152: 	if (isNormalCommand) {
000622 300057            JNB      isNormalCommand,?C0011?UART
  153: 		switch(command[1]) {
000625 AB3F              MOV      R3,command
000627 AA40              MOV      R2,command+01H
000629 A941              MOV      R1,command+02H
00062B 900001            MOV      DPTR,#01H
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:54:36  PAGE 7


00062E 3135              ACALL    ?C?CLDOPTR
000630 249E              ADD      A,#09EH
000632 6019              JZ       ?C0014?UART
000634 14                DEC      A
000635 6025              JZ       ?C0015?UART
000637 14                DEC      A
000638 6030              JZ       ?C0016?UART
00063A 14                DEC      A
00063B 602F              JZ       ?C0017?UART
00063D 14                DEC      A
00063E 603A              JZ       ?C0018?UART
000640 2405              ADD      A,#05H
000642 704B              JNZ      ?C0031?UART
  154: 			case 'a':
000644         ?C0013?UART:
  155: 				enableLCRChannel(command[3]);
000644 900003            MOV      DPTR,#03H
000647 3135              ACALL    ?C?CLDOPTR
000649 FF                MOV      R7,A
00064A 020998            LJMP     _enableLCRChannel
  156: 				break;
  157: 			case 'b':
00064D         ?C0014?UART:
  158: 				enableLCChannel(command[3]);
00064D AB3F              MOV      R3,command
00064F AA40              MOV      R2,command+01H
000651 A941              MOV      R1,command+02H
000653 900003            MOV      DPTR,#03H
000656 3135              ACALL    ?C?CLDOPTR
000658 FF                MOV      R7,A
000659 020954            LJMP     _enableLCChannel
  159: 				break;
  160: 			case 'c':
00065C         ?C0015?UART:
  161: 				setChargeMode(command[3]);
00065C AB3F              MOV      R3,command
00065E AA40              MOV      R2,command+01H
000660 A941              MOV      R1,command+02H
000662 900003            MOV      DPTR,#03H
000665 3135              ACALL    ?C?CLDOPTR
000667 FF                MOV      R7,A
000668 803F              SJMP     _setChargeMode
  162: 				break;
  163: 			case 'd':
00066A         ?C0016?UART:
  164: 				sendHVRelayStatus();
00066A 802B              SJMP     sendHVRelayStatus
  165: 				break;
  166: 			case 'e':
00066C         ?C0017?UART:
  167: 				setHVMonitorMode(command[3]);
00066C AB3F              MOV      R3,command
00066E AA40              MOV      R2,command+01H
000670 A941              MOV      R1,command+02H
000672 900003            MOV      DPTR,#03H
000675 3135              ACALL    ?C?CLDOPTR
000677 FF                MOV      R7,A
000678 E120              AJMP     _setHVMonitorMode
  168: 				break;
  169: 			case 'f':
00067A         ?C0018?UART:
  170: 				sendUUID();
00067A A179              AJMP     sendUUID
  171: 				break;
  172: 			default:
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:54:36  PAGE 8


00067C         ?C0011?UART:
00067C 300110            JNB      isSetUUIDCommand,?C0021?UART
  173: 				sendUART("Unknown Command\r\n");
  174: 		}		
  175: 	} else if (isSetUUIDCommand) {
  176: 		setUUID(command);
00067F AB3F              MOV      R3,command
000681 AA40              MOV      R2,command+01H
000683 A941              MOV      R1,command+02H
000685 F148              ACALL    _setUUID
  177: 		sendUART("DONE\r\n");
000687 7BFF              MOV      R3,#0FFH
000689 7A03              MOV      R2,#HIGH 0100032DH
00068B 792D              MOV      R1,#LOW 0100032DH
  178: 	} else {
00068D 8006              SJMP     ?C0032?UART
00068F         ?C0021?UART:
  179: 		sendUART("Unknown Command\r\n");
00068F         
00068F 7BFF              MOV      R3,#0FFH
000691 7A03              MOV      R2,#HIGH 0100031BH
000693 791B              MOV      R1,#LOW 0100031BH
000695         
000695 A164              AJMP     _sendUART
  180: 	}
----- FUNCTION _processCommand (END) -------


----- FUNCTION sendHVRelayStatus (BEGIN) -----
 FILE: 'DeviceController.c'
   87: void sendHVRelayStatus() {
   88: 	if (isAllHVRelayOK()) {
   89: 		sendUART("HV_OK\r\n");
000697 1120              ACALL    isAllHVRelayOK
000699 7BFF              MOV      R3,#0FFH
00069B 5006              JNC      ?C0017?DEVICECONTROLLER
   90: 	} else {
00069D 7A02              MOV      R2,#HIGH 01000296H
00069F 7996              MOV      R1,#LOW 01000296H
   91: 		sendUART("HV_NG\r\n");		
0006A1 8004              SJMP     ?C0040?DEVICECONTROLLER
0006A3         ?C0017?DEVICECONTROLLER:
   92: 	}
0006A3 7A02              MOV      R2,#HIGH 0100029EH
0006A5 799E              MOV      R1,#LOW 0100029EH
0006A7         
0006A7 A164              AJMP     _sendUART
   93: }
----- FUNCTION sendHVRelayStatus (END) -------


----- FUNCTION _setChargeMode (BEGIN) -----
 FILE: 'DeviceController.c'
   95: void setChargeMode(char modeCode) {
   96: 	if (modeCode == '1') {
0006A9 8F44              MOV      modeCode,R7
   97: 		if (!isAllHVRelayOK()) {
0006AB E544              MOV      A,modeCode
0006AD 6431              XRL      A,#031H
0006AF 7020              JNZ      ?C0020?DEVICECONTROLLER
   98: 			IO_vResetPin(HV_CHANNEL);			
0006B1 1120              ACALL    isAllHVRelayOK
0006B3 400E              JC       ?C0021?DEVICECONTROLLER
   99: 			IO_vResetPin(CHARGE_CHANNEL);
0006B5 C2B6              CLR      P3_6
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:54:36  PAGE 9


  100: 			IO_vResetPin(DISCHARGE_CHANNEL);
0006B7 C2B7              CLR      P3_7
  101: 			sendUART("HV_NG\r\n");
0006B9 C292              CLR      P1_2
  102: 			return;
0006BB 7BFF              MOV      R3,#0FFH
0006BD 7A02              MOV      R2,#HIGH 0100029EH
0006BF 799E              MOV      R1,#LOW 0100029EH
0006C1 8027              SJMP     ?C0043?DEVICECONTROLLER
  103: 		}
0006C3         ?C0021?DEVICECONTROLLER:
  104: 		IO_vResetPin(DISCHARGE_CHANNEL);
0006C3 C292              CLR      P1_2
  105: 		IO_vSetPin(HV_CHANNEL);
0006C5 D2B6              SETB     P3_6
  106: 		IO_vSetPin(CHARGE_CHANNEL);
0006C7 D2B7              SETB     P3_7
  107: 		sendUART("#c#1#\r\n");
0006C9 7BFF              MOV      R3,#0FFH
0006CB 7A02              MOV      R2,#HIGH 010002A6H
0006CD 79A6              MOV      R1,#LOW 010002A6H
0006CF         
  108: 	} else if (modeCode == '0') {
0006CF 8019              SJMP     ?C0043?DEVICECONTROLLER
0006D1         ?C0020?DEVICECONTROLLER:
0006D1 E544              MOV      A,modeCode
0006D3 B4300E            CJNE     A,#030H,?C0024?DEVICECONTROLLER
  109: 		IO_vResetPin(CHARGE_CHANNEL);
0006D6 C2B7              CLR      P3_7
  110: 		IO_vResetPin(HV_CHANNEL);
0006D8 C2B6              CLR      P3_6
  111: 		IO_vSetPin(DISCHARGE_CHANNEL);
0006DA D292              SETB     P1_2
  112: 		sendUART("#c#0#\r\n");
0006DC 7BFF              MOV      R3,#0FFH
0006DE 7A02              MOV      R2,#HIGH 010002AEH
0006E0 79AE              MOV      R1,#LOW 010002AEH
0006E2         
  113: 	} else {
0006E2 8006              SJMP     ?C0043?DEVICECONTROLLER
0006E4         ?C0024?DEVICECONTROLLER:
  114: 		sendUART("Unknown Charge Mode\r\n");		
0006E4 7BFF              MOV      R3,#0FFH
0006E6 7A02              MOV      R2,#HIGH 010002B6H
0006E8 79B6              MOV      R1,#LOW 010002B6H
0006EA         
0006EA A164              AJMP     _sendUART
  115: 	}
----- FUNCTION _setChargeMode (END) -------


----- FUNCTION _delay (BEGIN) -----
 FILE: 'MAIN.C'
   70: void delay(int second) {
   71:   int i, j, k;
;---- Variable 'second' assigned to Register 'R6/R7' ----
   72:   for (i = 0; i < second; i++) {
;---- Variable 'i' assigned to Register 'R4/R5' ----
0006EC E4                CLR      A
0006ED FD                MOV      R5,A
0006EE FC                MOV      R4,A
0006EF         ?C0002?MAIN:
0006EF C3                CLR      C
0006F0 ED                MOV      A,R5
0006F1 9F                SUBB     A,R7
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:54:36  PAGE 10


0006F2 EE                MOV      A,R6
0006F3 6480              XRL      A,#080H
0006F5 F8                MOV      R0,A
0006F6 EC                MOV      A,R4
0006F7 6480              XRL      A,#080H
0006F9 98                SUBB     A,R0
0006FA 5023              JNC      ?C0011?MAIN
   73:     for (j = 0; j < 25; j++) {
;---- Variable 'j' assigned to Register 'R2/R3' ----
0006FC E4                CLR      A
0006FD FB                MOV      R3,A
0006FE FA                MOV      R2,A
0006FF         ?C0005?MAIN:
   74:       for (k = 0; k < 30000; k++) {
;---- Variable 'k' assigned to Register 'DPTR' ----
0006FF 900000            MOV      DPTR,#00H
000702         ?C0008?MAIN:
   75:       }
000702 A3                INC      DPTR
000703 E582              MOV      A,DPL
000705 B430FA            CJNE     A,#030H,?C0008?MAIN
000708 E583              MOV      A,DPH
00070A B475F5            CJNE     A,#075H,?C0008?MAIN
   76:     }
00070D         ?C0007?MAIN:
00070D 0B                INC      R3
00070E BB0001            CJNE     R3,#00H,?C0017?MAIN
000711 0A                INC      R2
000712         ?C0017?MAIN:
000712 EB                MOV      A,R3
000713 6419              XRL      A,#019H
000715 4A                ORL      A,R2
000716 70E7              JNZ      ?C0005?MAIN
   77:   }
000718         ?C0004?MAIN:
000718 0D                INC      R5
000719 BD0001            CJNE     R5,#00H,?C0018?MAIN
00071C 0C                INC      R4
00071D         ?C0018?MAIN:
00071D 80D0              SJMP     ?C0002?MAIN
   78: }
00071F         ?C0011?MAIN:
00071F 22                RET      
----- FUNCTION _delay (END) -------


----- FUNCTION _setHVMonitorMode (BEGIN) -----
 FILE: 'DeviceController.c'
  118: void setHVMonitorMode(char modeCode) {
  119: 	if (modeCode == '1') {
000720 8F44              MOV      modeCode,R7
  120: 		shouldMonitorHVStatus = 1;
000722 E544              MOV      A,modeCode
000724 B4310A            CJNE     A,#031H,?C0026?DEVICECONTROLLER
  121: 		sendUART("#e#1#\r\n");
000727 D203              SETB     shouldMonitorHVStatus
  122: 	} else if (modeCode == '0') {
000729 7BFF              MOV      R3,#0FFH
00072B 7A02              MOV      R2,#HIGH 010002CCH
00072D 79CC              MOV      R1,#LOW 010002CCH
  123: 		shouldMonitorHVStatus = 0;
00072F 8015              SJMP     ?C0045?DEVICECONTROLLER
000731         ?C0026?DEVICECONTROLLER:
000731 E544              MOV      A,modeCode
000733 B4300A            CJNE     A,#030H,?C0028?DEVICECONTROLLER
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:54:36  PAGE 11


  124: 		sendUART("#e#0#\r\n");
000736 C203              CLR      shouldMonitorHVStatus
  125: 	} else {
000738 7BFF              MOV      R3,#0FFH
00073A 7A02              MOV      R2,#HIGH 010002D4H
00073C 79D4              MOV      R1,#LOW 010002D4H
00073E         
  126: 		sendUART("Unknown HV Monitor Code\r\n");
00073E 8006              SJMP     ?C0045?DEVICECONTROLLER
000740         ?C0028?DEVICECONTROLLER:
  127: 	}
000740 7BFF              MOV      R3,#0FFH
000742 7A02              MOV      R2,#HIGH 010002DCH
000744 79DC              MOV      R1,#LOW 010002DCH
000746         
000746 A164              AJMP     _sendUART
  128: 	
----- FUNCTION _setHVMonitorMode (END) -------


----- FUNCTION _setUUID (BEGIN) -----
 FILE: 'DeviceController.c'
  131: void setUUID(char * command) {
  132: 	unsigned char code * flashEndAddress = getFlashDataEndAddress();	
000748 8B44              MOV      command,R3
00074A 8A45              MOV      command+01H,R2
00074C 8946              MOV      command+02H,R1
  133: 	char xdata uuidString[37] = "CDEABC00-MNOP-41d4-a716-44665544EFGH";
00074E 120AA6            LCALL    getFlashDataEndAddress
000751 8E47              MOV      flashEndAddress,R6
000753 8F48              MOV      flashEndAddress+01H,R7
  134: 	writeBufferToFlash(uuidString, &flashEndAddress);
000755 78C8              MOV      R0,#LOW uuidString
000757 7CF0              MOV      R4,#HIGH uuidString
000759 7D01              MOV      R5,#01H
00075B 7BFF              MOV      R3,#0FFH
00075D 7A02              MOV      R2,#HIGH _?ix1000
00075F 79F6              MOV      R1,#LOW _?ix1000
000761 7E00              MOV      R6,#00H
000763 7F25              MOV      R7,#025H
000765 11F6              ACALL    ?C?COPY
  134: }
000767 754C00            MOV      ?_writeBufferToFlash?BYTE+03H,#00H
00076A 754D00            MOV      ?_writeBufferToFlash?BYTE+04H,#HIGH flashEndAddress
00076D 754E47            MOV      ?_writeBufferToFlash?BYTE+05H,#LOW flashEndAddress
000770 7B01              MOV      R3,#01H
000772 7AF0              MOV      R2,#HIGH uuidString
000774 79C8              MOV      R1,#LOW uuidString
;----                  JMP      _writeBufferToFlash
----- FUNCTION _setUUID (END) -------


----- FUNCTION _writeBufferToFlash (BEGIN) -----
 FILE: 'FlashUtils.c'
   68: void writeBufferToFlash(char * buffer, unsigned char code ** EECurrentAddr) {
   69: 	char xdata pageBuffer[BYTES_PER_WORDLINE] = {0};
000776 8B49              MOV      buffer,R3
000778 8A4A              MOV      buffer+01H,R2
00077A 894B              MOV      buffer+02H,R1
   70: 	char * currentCharacter = buffer;
00077C 78ED              MOV      R0,#LOW pageBuffer
00077E 7CF0              MOV      R4,#HIGH pageBuffer
000780 7D01              MOV      R5,#01H
000782 7BFF              MOV      R3,#0FFH
000784 7A05              MOV      R2,#HIGH _?ix1000
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:54:36  PAGE 12


000786 7905              MOV      R1,#LOW _?ix1000
000788 7E00              MOV      R6,#00H
00078A 7F20              MOV      R7,#020H
00078C 11F6              ACALL    ?C?COPY
   71: 	int i = 0;
00078E 85494F            MOV      currentCharacter,buffer
000791 854A50            MOV      currentCharacter+01H,buffer+01H
000794 854B51            MOV      currentCharacter+02H,buffer+02H
   72: 	
000797 E4                CLR      A
000798 F552              MOV      i,A
00079A F553              MOV      i+01H,A
   73: 	FLASH_Erase(SECALL,0);
00079C FD                MOV      R5,A
00079D FC                MOV      R4,A
00079E 7FFF              MOV      R7,#0FFH
0007A0 7E03              MOV      R6,#03H
0007A2 120A78            LCALL    _FLASH_Erase
   74: 	*EECurrentAddr = (unsigned char code*)FLASH_FIRST_ADDR;			// if erase than 1. WL is current
0007A5 AB4C              MOV      R3,EECurrentAddr
0007A7 AA4D              MOV      R2,EECurrentAddr+01H
0007A9 A94E              MOV      R1,EECurrentAddr+02H
0007AB 74A0              MOV      A,#0A0H
0007AD 75F000            MOV      B,#00H
0007B0 31C5              ACALL    ?C?ISTPTR
   75:   delay(2);
0007B2 7F02              MOV      R7,#02H
0007B4 7E00              MOV      R6,#00H
0007B6 D1EC              ACALL    _delay
   76: 	
   77: 	memset(pageBuffer, 0, BYTES_PER_WORDLINE);
0007B8 7E00              MOV      R6,#00H
0007BA 7F20              MOV      R7,#020H
0007BC 7D00              MOV      R5,#00H
0007BE 7B01              MOV      R3,#01H
0007C0 7AF0              MOV      R2,#HIGH pageBuffer
0007C2 79ED              MOV      R1,#LOW pageBuffer
0007C4 31E4              ACALL    ?C?MEMSET
0007C6         ?C0018?FLASHUTILS:
   78: 	while (*currentCharacter != 0) {
0007C6 AB4F              MOV      R3,currentCharacter
0007C8 AA50              MOV      R2,currentCharacter+01H
0007CA A951              MOV      R1,currentCharacter+02H
0007CC 311C              ACALL    ?C?CLDPTR
0007CE FF                MOV      R7,A
0007CF 604E              JZ       ?C0019?FLASHUTILS
   79: 		
   80: 		pageBuffer[i] = *currentCharacter;
0007D1 74ED              MOV      A,#LOW pageBuffer
0007D3 2553              ADD      A,i+01H
0007D5 F582              MOV      DPL,A
0007D7 74F0              MOV      A,#HIGH pageBuffer
0007D9 3552              ADDC     A,i
0007DB F583              MOV      DPH,A
0007DD EF                MOV      A,R7
0007DE F0                MOVX     @DPTR,A
   81: 		if (i == 25) {
0007DF E553              MOV      A,i+01H
0007E1 6419              XRL      A,#019H
0007E3 4552              ORL      A,i
0007E5 7023              JNZ      ?C0020?FLASHUTILS
   82: 			writeToFlashPage(pageBuffer, EECurrentAddr);
0007E7 7EF0              MOV      R6,#HIGH pageBuffer
0007E9 7FED              MOV      R7,#LOW pageBuffer
0007EB AB4C              MOV      R3,EECurrentAddr
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:54:36  PAGE 13


0007ED AA4D              MOV      R2,EECurrentAddr+01H
0007EF A94E              MOV      R1,EECurrentAddr+02H
0007F1 120829            LCALL    _writeToFlashPage
   83: 			memset(pageBuffer, 0, BYTES_PER_WORDLINE);
0007F4 7E00              MOV      R6,#00H
0007F6 7F20              MOV      R7,#020H
0007F8 7D00              MOV      R5,#00H
0007FA 7B01              MOV      R3,#01H
0007FC 7AF0              MOV      R2,#HIGH pageBuffer
0007FE 79ED              MOV      R1,#LOW pageBuffer
000800 1201E4            LCALL    ?C?MEMSET
   84: 			i = 0;
000803 E4                CLR      A
000804 F552              MOV      i,A
000806 F553              MOV      i+01H,A
   85: 		} else {
000808 8008              SJMP     ?C0021?FLASHUTILS
00080A         ?C0020?FLASHUTILS:
   86: 			i++;
00080A 0553              INC      i+01H
00080C E553              MOV      A,i+01H
00080E 7002              JNZ      ?C0027?FLASHUTILS
000810 0552              INC      i
000812         ?C0027?FLASHUTILS:
   87: 		}
000812         ?C0021?FLASHUTILS:
   88: 		currentCharacter++;
000812 7401              MOV      A,#01H
000814 2551              ADD      A,currentCharacter+02H
000816 F551              MOV      currentCharacter+02H,A
000818 E4                CLR      A
000819 3550              ADDC     A,currentCharacter+01H
00081B F550              MOV      currentCharacter+01H,A
   89: 	}
00081D 80A7              SJMP     ?C0018?FLASHUTILS
00081F         ?C0019?FLASHUTILS:
   90: 	writeToFlashPage(pageBuffer, EECurrentAddr);	
00081F 7EF0              MOV      R6,#HIGH pageBuffer
000821 7FED              MOV      R7,#LOW pageBuffer
000823 AB4C              MOV      R3,EECurrentAddr
000825 AA4D              MOV      R2,EECurrentAddr+01H
000827 A94E              MOV      R1,EECurrentAddr+02H
;----                  JMP      _writeToFlashPage
----- FUNCTION _writeBufferToFlash (END) -------


----- FUNCTION _writeToFlashPage (BEGIN) -----
 FILE: 'FlashUtils.c'
   29: void writeToFlashPage(char xdata * buffer, unsigned char code ** EECurrentAddr) {
   30: 	int i = 0;
000829 8E54              MOV      buffer,R6
00082B 8F55              MOV      buffer+01H,R7
00082D 8B56              MOV      EECurrentAddr,R3
00082F 8A57              MOV      EECurrentAddr+01H,R2
000831 8958              MOV      EECurrentAddr+02H,R1
   31: 
;---- Variable 'i' assigned to Register 'R6/R7' ----
000833 E4                CLR      A
000834 FF                MOV      R7,A
000835 FE                MOV      R6,A
   32: 	for (i=0; i < BYTES_PER_WORDLINE; i++) {
000836         ?C0006?FLASHUTILS:
   33: 		WLBuf[i] = *buffer;
000836 855582            MOV      DPL,buffer+01H
000839 855483            MOV      DPH,buffer
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:54:36  PAGE 14


00083C E0                MOVX     A,@DPTR
00083D FD                MOV      R5,A
00083E 74E0              MOV      A,#LOW WLBuf
000840 2F                ADD      A,R7
000841 F8                MOV      R0,A
000842 A605              MOV      @R0,AR5
   34: 		buffer++;
000844 0555              INC      buffer+01H
000846 E555              MOV      A,buffer+01H
000848 7002              JNZ      ?C0023?FLASHUTILS
00084A 0554              INC      buffer
00084C         ?C0023?FLASHUTILS:
   35: 	}
00084C 0F                INC      R7
00084D BF0001            CJNE     R7,#00H,?C0024?FLASHUTILS
000850 0E                INC      R6
000851         ?C0024?FLASHUTILS:
000851 EF                MOV      A,R7
000852 6420              XRL      A,#020H
000854 4E                ORL      A,R6
000855 70DF              JNZ      ?C0006?FLASHUTILS
000857         ?C0007?FLASHUTILS:
   36: 
   37: 	// Start the Flash Programming
   38: 	if (FLASH_Prog(*EECurrentAddr)) 
000857 AB56              MOV      R3,EECurrentAddr
000859 AA57              MOV      R2,EECurrentAddr+01H
00085B A958              MOV      R1,EECurrentAddr+02H
00085D 120162            LCALL    ?C?ILDPTR
000860 FF                MOV      R7,A
000861 AEF0              MOV      R6,B
000863 117B              ACALL    _FLASH_Prog
000865 500D              JNC      ?C0009?FLASHUTILS
   39: 	{
   40: 		*EECurrentAddr = *EECurrentAddr + BYTES_PER_WORDLINE;
000867 AB56              MOV      R3,EECurrentAddr
000869 AA57              MOV      R2,EECurrentAddr+01H
00086B A958              MOV      R1,EECurrentAddr+02H
00086D E4                CLR      A
00086E 75F020            MOV      B,#020H
000871 12018D            LCALL    ?C?IILDPTR
   41: 	}
000874         ?C0009?FLASHUTILS:
   42: 	delay(2);
000874 7F02              MOV      R7,#02H
000876 7E00              MOV      R6,#00H
000878 0206EC            LJMP     _delay
----- FUNCTION _writeToFlashPage (END) -------


----- FUNCTION _FLASH_Prog (BEGIN) -----
 FILE: 'FlashHandler.c'
  113: bit FLASH_Prog					(unsigned char code* WLAddress) 
  114: {
;---- Variable 'WLAddress' assigned to Register 'R6/R7' ----
  115: #ifdef	XC88x
  116: 	volatile bit success;		    // needed for CY flag saving of the BROM routine's result
  117: #endif	// XC88x
  118: #ifdef	XC866
  119: #define USE_BANK  3					// fix the used registerbank to 3 for XC866 devices
  120: #endif	// XC866
  121: 									// For SDCC parameter is now already in DPTR
  122: #ifdef SDCC
  123: 	*WLAddress;						// avoid warning of 'unreferenced function argument
  124: #endif	// SDCC
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:54:36  PAGE 15


  125: #ifdef __C51__
  126:    DPTR = (unsigned int)WLAddress;
00087B 8E83              MOV      DPH,R6
00087D 8F82              MOV      DPL,R7
  127: #endif	// __C51__
  128: 
  129:    REG[(0+(USE_BANK*8))] = WORDLINE_BUFFER_ADDRESS;
00087F 7818              MOV      R0,#018H
000881 76E0              MOV      @R0,#0E0H
  130: #ifdef	XC88x
  131: 	PUSH(PSW);
000883 C0D0              PUSH     PSW
  132: 	PSW = ((USE_BANK)<<3);
000885 75D018            MOV      PSW,#018H
  133: #endif	// XC88x
  134: 
  135: #ifdef	__C51__		
  136: 	((void (code *) (void)) FLASH_PROG) ();
000888 12DFF6            LCALL    0DFF6H
  137: #endif	// __C51__
  138: #ifdef	SDCC
  139: _asm
  140: 	LCALL FLASH_PROG;
  141: _endasm;
  142: #endif	// SDCC
  143: 
  144: #ifdef	XC88x
  145: 	success = CY;
00088B 9202              MOV      success,C
  146: 	POP(PSW);
00088D D0D0              POP      PSW
  147: 	return(!success);			  
00088F A202              MOV      C,success
000891 B3                CPL      C
  148: #endif	// XC88x
  149: #ifdef	XC866
  150: 	return (!CY);
  151: #endif	// XC866
  152: }
000892 22                RET      
----- FUNCTION _FLASH_Prog (END) -------


----- FUNCTION UART_vInit (BEGIN) -----
 FILE: 'UART.C'
   60: void UART_vInit(void)
   61: {
   62:   ///  -----------------------------------------------------------------------
   63:   ///  UART settings
   64:   ///  -----------------------------------------------------------------------
   65:   ///  Pin TXD_1 (P0.2) is selected for transmission
   66:   ///  Pin RXD_1 (P0.1) is selected for reception
   67:   ///  Receiver enabled
   68:   ///  Mode 1: 8-bit data, 1 start bit, 1 stop bit, variable baud rate
   69:   ///  Receiver interrupt flag RI will only be activated if a valid stop bit 
   70:   ///  was received
   71:   ///  BRG is selected for baudrate generation
   72: 
   73:   SFR_PAGE(_pp2, noSST);         // switch to page 2 without saving
000893 75B202            MOV      PORT_PAGE,#02H
   74:   P0_ALTSEL0   &= ~(ubyte)0x04;  // configure alternate function register 0
000896 5380FB            ANL      P0_ALTSEL0,#0FBH
   75:   P0_ALTSEL1   |=  (ubyte)0x04;  // configure alternate function register 1
000899 438604            ORL      P0_ALTSEL1,#04H
   76:   SFR_PAGE(_pp0, noSST);         // switch to page 0 without saving
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:54:36  PAGE 16


00089C E4                CLR      A
00089D F5B2              MOV      PORT_PAGE,A
   77:   P0_DIR       |=  (ubyte)0x04;  // set output direction
00089F 438604            ORL      P0_DIR,#04H
   78: 
   79: 
   80:   MODPISEL     |=  (ubyte)0x01;  // configure peripheral input select register
0008A2 43B301            ORL      MODPISEL,#01H
   81:   BCON          =  0x00;         // reset baudrate timer/reload register
0008A5 F5BD              MOV      BCON,A
   82:   SCON          =  0x70;         // load serial channel control register
0008A7 759870            MOV      SCON,#070H
   83: 
   84:   ///  -----------------------------------------------------------------------
   85:   ///  Baudrate generator settings
   86:   ///  -----------------------------------------------------------------------
   87:   ///  input clock = fPCLK
   88:   ///  Fractional divider is enabled
   89:   ///  baudrate = 9.6004 kbaud
   90: 
   91:   FDSTEP        =  0xD5;         // load fractional divider reload register
0008AA 75EAD5            MOV      FDSTEP,#0D5H
   92:   BG            =  0x81;         // load baudrate timer/reload register
0008AD 75BE81            MOV      BG,#081H
   93:   FDCON        |=  0x01;         // load Fractional Divider control register
0008B0 43E901            ORL      FDCON,#01H
   94:   BCON         |=  0x01;         // load baud rate control register
0008B3 43BD01            ORL      BCON,#01H
   95: 
   96:   ///  UART interrupt enabled
   97:   ES = 1;
0008B6 D2AC              SETB     ES
   98: 
   99: } //  End of function UART_vInit
0008B8 22                RET      
----- FUNCTION UART_vInit (END) -------


----- FUNCTION UART_viIsr (BEGIN) -----
 FILE: 'UART.C'
  183: void UART_viIsr(void) interrupt UARTINT
0008B9 C0E0              PUSH     ACC
0008BB C0F0              PUSH     B
0008BD C083              PUSH     DPH
0008BF C082              PUSH     DPL
0008C1 C0D0              PUSH     PSW
0008C3 75D000            MOV      PSW,#00H
0008C6 C000              PUSH     AR0
0008C8 C001              PUSH     AR1
0008CA C002              PUSH     AR2
0008CC C003              PUSH     AR3
0008CE C004              PUSH     AR4
0008D0 C005              PUSH     AR5
0008D2 C006              PUSH     AR6
0008D4 C007              PUSH     AR7
  184: {
  185: 	// switch to page 0
  186:   SFR_PAGE(_su0, SST0);
0008D6 75BF80            MOV      SCU_PAGE,#080H
  187:   if (TI)
0008D9 309902            JNB      TI,?C0024?UART
  188:   {
  189: 		TI = 0;
0008DC C299              CLR      TI
  190:   }
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:54:36  PAGE 17


0008DE         ?C0024?UART:
  191:   if (RI)
0008DE 309855            JNB      RI,?C0025?UART
  192:   {
  193: 		char receiveByte = SBUF;
0008E1 85993E            MOV      receiveByte,SBUF
  194: 		if (receiveByte == '\r' || receiveByte == '\n' || bufferCount >= MAX_COMMAND_LENGTH-1) {
0008E4 E53E              MOV      A,receiveByte
0008E6 640D              XRL      A,#0DH
0008E8 6013              JZ       ?C0027?UART
0008EA E53E              MOV      A,receiveByte
0008EC 640A              XRL      A,#0AH
0008EE 600D              JZ       ?C0027?UART
0008F0 C3                CLR      C
0008F1 E509              MOV      A,bufferCount+01H
0008F3 9463              SUBB     A,#063H
0008F5 E508              MOV      A,bufferCount
0008F7 6480              XRL      A,#080H
0008F9 9480              SUBB     A,#080H
0008FB 4020              JC       ?C0026?UART
0008FD         ?C0027?UART:
  195: 			processCommand(receiveBuffer);
0008FD 7B01              MOV      R3,#01H
0008FF 7AF1              MOV      R2,#HIGH receiveBuffer
000901 7971              MOV      R1,#LOW receiveBuffer
000903 12059B            LCALL    _processCommand
  196: 			memset(receiveBuffer, 0, MAX_COMMAND_LENGTH);			
000906 7E00              MOV      R6,#00H
000908 7F64              MOV      R7,#064H
00090A 7D00              MOV      R5,#00H
00090C 7B01              MOV      R3,#01H
00090E 7AF1              MOV      R2,#HIGH receiveBuffer
000910 7971              MOV      R1,#LOW receiveBuffer
000912 1201E4            LCALL    ?C?MEMSET
  197: 			bufferCount = 0;
000915 750800            MOV      bufferCount,#00H
000918 750900            MOV      bufferCount+01H,#00H
  198: 		} else {
00091B 8017              SJMP     ?C0028?UART
00091D         ?C0026?UART:
  199: 			receiveBuffer[bufferCount] = receiveByte;
00091D 7471              MOV      A,#LOW receiveBuffer
00091F 2509              ADD      A,bufferCount+01H
000921 F582              MOV      DPL,A
000923 74F1              MOV      A,#HIGH receiveBuffer
000925 3508              ADDC     A,bufferCount
000927 F583              MOV      DPH,A
000929 E53E              MOV      A,receiveByte
00092B F0                MOVX     @DPTR,A
  200: 			bufferCount++;
00092C 0509              INC      bufferCount+01H
00092E E509              MOV      A,bufferCount+01H
000930 7002              JNZ      ?C0030?UART
000932 0508              INC      bufferCount
000934         ?C0030?UART:
  201: 		}
000934         ?C0028?UART:
  202:     RI = 0;
000934 C298              CLR      RI
  203:   }
000936         ?C0025?UART:
  204: 
  205: 	// restore the old page
  206:   SFR_PAGE(_su0, RST0);
000936 75BFC0            MOV      SCU_PAGE,#0C0H
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:54:36  PAGE 18


  207: }
000939 D007              POP      AR7
00093B D006              POP      AR6
00093D D005              POP      AR5
00093F D004              POP      AR4
000941 D003              POP      AR3
000943 D002              POP      AR2
000945 D001              POP      AR1
000947 D000              POP      AR0
000949 D0D0              POP      PSW
00094B D082              POP      DPL
00094D D083              POP      DPH
00094F D0F0              POP      B
000951 D0E0              POP      ACC
000953 32                RETI     
----- FUNCTION UART_viIsr (END) -------


----- FUNCTION _enableLCChannel (BEGIN) -----
 FILE: 'DeviceController.c'
   15: void enableLCChannel(char channelCode) {
   16: 	// Switch off all LCR channel first.
;---- Variable 'channelCode' assigned to Register 'R7' ----
   17: 	IO_vResetPin(LC_CHANNEL_1);
000954 C2B1              CLR      P3_1
   18: 	IO_vResetPin(LC_CHANNEL_2);
000956 C2B3              CLR      P3_3
   19: 	IO_vResetPin(LC_CHANNEL_3);
000958 C2B5              CLR      P3_5
   20: 	
   21: 	// Enable coressponding LCR channel GPIO
   22: 	switch(channelCode) {
00095A EF                MOV      A,R7
00095B 24CF              ADD      A,#0CFH
00095D 6012              JZ       ?C0004?DEVICECONTROLLER
00095F 14                DEC      A
000960 6019              JZ       ?C0005?DEVICECONTROLLER
000962 14                DEC      A
000963 6020              JZ       ?C0006?DEVICECONTROLLER
000965 2403              ADD      A,#03H
000967 7026              JNZ      ?C0007?DEVICECONTROLLER
   23: 		case '0':
000969         ?C0003?DEVICECONTROLLER:
   24: 			sendUART("#b#0#\r\n");
000969 7BFF              MOV      R3,#0FFH
00096B 7A02              MOV      R2,#HIGH 01000229H
00096D 7929              MOV      R1,#LOW 01000229H
   25: 			break;
00096F 8024              SJMP     ?C0035?DEVICECONTROLLER
   26: 		case '1':
000971         ?C0004?DEVICECONTROLLER:
   27: 			IO_vSetPin(LC_CHANNEL_1);
000971 D2B1              SETB     P3_1
   28: 			sendUART("#b#1#\r\n");
000973 7BFF              MOV      R3,#0FFH
000975 7A02              MOV      R2,#HIGH 01000231H
000977 7931              MOV      R1,#LOW 01000231H
000979         
   29: 			break;
000979 801A              SJMP     ?C0035?DEVICECONTROLLER
   30: 		case '2':
00097B         ?C0005?DEVICECONTROLLER:
   31: 			IO_vSetPin(LC_CHANNEL_2);
00097B D2B3              SETB     P3_3
   32: 			sendUART("#b#2#\r\n");		
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:54:36  PAGE 19


00097D 7BFF              MOV      R3,#0FFH
00097F 7A02              MOV      R2,#HIGH 01000239H
000981 7939              MOV      R1,#LOW 01000239H
000983         
   33: 			break;
000983 8010              SJMP     ?C0035?DEVICECONTROLLER
   34: 		case '3':
000985         ?C0006?DEVICECONTROLLER:
   35: 			IO_vSetPin(LC_CHANNEL_3);
000985 D2B5              SETB     P3_5
   36: 			sendUART("#b#3#\r\n");
000987 7BFF              MOV      R3,#0FFH
000989 7A02              MOV      R2,#HIGH 01000241H
00098B 7941              MOV      R1,#LOW 01000241H
00098D         
   37: 			break;
00098D 8006              SJMP     ?C0035?DEVICECONTROLLER
   38: 		default:
00098F         ?C0007?DEVICECONTROLLER:
   39: 			sendUART("Unknown LC Channel.\r\n");			
00098F 7BFF              MOV      R3,#0FFH
000991 7A02              MOV      R2,#HIGH 01000249H
000993 7949              MOV      R1,#LOW 01000249H
000995         
000995 020564            LJMP     _sendUART
   40: 			break;
   41: 	}
----- FUNCTION _enableLCChannel (END) -------


----- FUNCTION _enableLCRChannel (BEGIN) -----
 FILE: 'DeviceController.c'
   44: void enableLCRChannel(char channelCode) {
   45: 	// Switch off all LCR channel first.
;---- Variable 'channelCode' assigned to Register 'R7' ----
   46: 	IO_vResetPin(LCR_CHANNEL_1);
000998 C2B0              CLR      P3_0
   47: 	IO_vResetPin(LCR_CHANNEL_2);
00099A C2B2              CLR      P3_2
   48: 	IO_vResetPin(LCR_CHANNEL_3);
00099C C2B4              CLR      P3_4
   49: 	
   50: 	// Enable coressponding LCR channel GPIO
   51: 	switch(channelCode) {
00099E EF                MOV      A,R7
00099F 24CF              ADD      A,#0CFH
0009A1 6012              JZ       ?C0011?DEVICECONTROLLER
0009A3 14                DEC      A
0009A4 6019              JZ       ?C0012?DEVICECONTROLLER
0009A6 14                DEC      A
0009A7 6020              JZ       ?C0013?DEVICECONTROLLER
0009A9 2403              ADD      A,#03H
0009AB 7026              JNZ      ?C0014?DEVICECONTROLLER
   52: 		case '0':
0009AD         ?C0010?DEVICECONTROLLER:
   53: 			sendUART("#a#0#\r\n");
0009AD 7BFF              MOV      R3,#0FFH
0009AF 7A02              MOV      R2,#HIGH 0100025FH
0009B1 795F              MOV      R1,#LOW 0100025FH
   54: 			break;
0009B3 8024              SJMP     ?C0039?DEVICECONTROLLER
   55: 		case '1':
0009B5         ?C0011?DEVICECONTROLLER:
   56: 			IO_vSetPin(LCR_CHANNEL_1);
0009B5 D2B0              SETB     P3_0
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:54:36  PAGE 20


   57: 			sendUART("#a#1#\r\n");
0009B7 7BFF              MOV      R3,#0FFH
0009B9 7A02              MOV      R2,#HIGH 01000267H
0009BB 7967              MOV      R1,#LOW 01000267H
0009BD         
   58: 			break;
0009BD 801A              SJMP     ?C0039?DEVICECONTROLLER
   59: 		case '2':
0009BF         ?C0012?DEVICECONTROLLER:
   60: 			IO_vSetPin(LCR_CHANNEL_2);
0009BF D2B2              SETB     P3_2
   61: 			sendUART("#a#2#\r\n");		
0009C1 7BFF              MOV      R3,#0FFH
0009C3 7A02              MOV      R2,#HIGH 0100026FH
0009C5 796F              MOV      R1,#LOW 0100026FH
0009C7         
   62: 			break;
0009C7 8010              SJMP     ?C0039?DEVICECONTROLLER
   63: 		case '3':
0009C9         ?C0013?DEVICECONTROLLER:
   64: 			IO_vSetPin(LCR_CHANNEL_3);
0009C9 D2B4              SETB     P3_4
   65: 			sendUART("#a#3#\r\n");
0009CB 7BFF              MOV      R3,#0FFH
0009CD 7A02              MOV      R2,#HIGH 01000277H
0009CF 7977              MOV      R1,#LOW 01000277H
0009D1         
   66: 			break;
0009D1 8006              SJMP     ?C0039?DEVICECONTROLLER
   67: 		default:
0009D3         ?C0014?DEVICECONTROLLER:
   68: 			sendUART("Unknown LCR Channel.\r\n");			
0009D3 7BFF              MOV      R3,#0FFH
0009D5 7A02              MOV      R2,#HIGH 0100027FH
0009D7 797F              MOV      R1,#LOW 0100027FH
0009D9         
0009D9 020564            LJMP     _sendUART
   69: 			break;
   70: 	}
----- FUNCTION _enableLCRChannel (END) -------


----- FUNCTION FLASH_Erase_Abort (BEGIN) -----
 FILE: 'FlashHandler.c'
   75: bit FLASH_Erase_Abort (void)
   76: {
   77: #ifdef __C51__		
   78: 	((void (code *) (void)) FLASH_ERASE_ABORT) ();
0009DC 12DFF3            LCALL    0DFF3H
   79: #endif	// __C51__
   80: #ifdef	SDCC
   81: _asm
   82: 	LCALL FLASH_ERASE_ABORT;
   83: _endasm;
   84: #endif	// SDCC
   85: 	return (!CY);  
0009DF B3                CPL      C
   86: }
0009E0 22                RET      
----- FUNCTION FLASH_Erase_Abort (END) -------


----- FUNCTION _FLASH_Ready (BEGIN) -----
 FILE: 'FlashHandler.c'
   90: bit FLASH_Ready						(unsigned char BankNum)
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:54:36  PAGE 21


   91: {
;---- Variable 'BankNum' assigned to Register 'R7' ----
   92:     ACC = BankNum;
   93: #ifdef __C51__		
0009E1 EF                MOV      A,R7
   94: 	((void (code *) (void)) FLASH_READ_STATUS) ();
0009E2 02DFF0            LJMP     0DFF0H
   95: #endif	// __C51__
   96: #ifdef	SDCC
   97: _asm
   98: 	LCALL FLASH_READ_STATUS;
   99: _endasm;
  100: #endif	// SDCC
  101: 	return(CY);
----- FUNCTION _FLASH_Ready (END) -------


----- FUNCTION _readFlashToBuffer (BEGIN) -----
 FILE: 'FlashUtils.c'
   46: void readFlashToBuffer(char xdata * buffer, int n, unsigned char code * EECurrentAddr) 
   47: {
0009E5 8E44              MOV      buffer,R6
0009E7 8F45              MOV      buffer+01H,R7
0009E9 8C46              MOV      n,R4
0009EB 8D47              MOV      n+01H,R5
0009ED 8A48              MOV      EECurrentAddr,R2
0009EF 8B49              MOV      EECurrentAddr+01H,R3
   48: 	unsigned char code * EETempAddr = (unsigned char code*)FLASH_FIRST_ADDR;
   49: 	int i = 0;
0009F1 754AA0            MOV      EETempAddr,#0A0H
0009F4 754B00            MOV      EETempAddr+01H,#00H
   50: 	int j = 0;
0009F7 E4                CLR      A
0009F8 F54C              MOV      i,A
0009FA F54D              MOV      i+01H,A
   51: 	int k = 0;
0009FC F54E              MOV      j,A
0009FE F54F              MOV      j+01H,A
   52: 	memset(buffer, 0, n);
000A00 F550              MOV      k,A
000A02 F551              MOV      k+01H,A
   53: 	
000A04 AE46              MOV      R6,n
000A06 AF47              MOV      R7,n+01H
000A08 FD                MOV      R5,A
000A09 AA44              MOV      R2,buffer
000A0B A945              MOV      R1,buffer+01H
000A0D 7B01              MOV      R3,#01H
000A0F 1201E4            LCALL    ?C?MEMSET
000A12         ?C0011?FLASHUTILS:
   54: 	while (FLASH_Ready(FLASH_BANK_TO_CHECK) == 0) {;}
000A12 7F03              MOV      R7,#03H
000A14 31E1              ACALL    _FLASH_Ready
000A16 50FA              JNC      ?C0011?FLASHUTILS
000A18         ?C0012?FLASHUTILS:
000A18         ?C0013?FLASHUTILS:
   55: 	
   56: 	while (EETempAddr < EECurrentAddr && j < n) 
000A18 C3                CLR      C
000A19 E54B              MOV      A,EETempAddr+01H
000A1B 9549              SUBB     A,EECurrentAddr+01H
000A1D E54A              MOV      A,EETempAddr
000A1F 9548              SUBB     A,EECurrentAddr
000A21 5054              JNC      ?C0017?FLASHUTILS
000A23 C3                CLR      C
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:54:36  PAGE 22


000A24 E54F              MOV      A,j+01H
000A26 9547              SUBB     A,n+01H
000A28 E546              MOV      A,n
000A2A 6480              XRL      A,#080H
000A2C F8                MOV      R0,A
000A2D E54E              MOV      A,j
000A2F 6480              XRL      A,#080H
000A31 98                SUBB     A,R0
000A32 5043              JNC      ?C0017?FLASHUTILS
   57: 	{	
   58: 		i = 0;
000A34 E4                CLR      A
000A35 F54C              MOV      i,A
000A37 F54D              MOV      i+01H,A
000A39         ?C0015?FLASHUTILS:
   59: 		while (*(EETempAddr+i) != 0) {
000A39 E54B              MOV      A,EETempAddr+01H
000A3B 254D              ADD      A,i+01H
000A3D F582              MOV      DPL,A
000A3F E54A              MOV      A,EETempAddr
000A41 354C              ADDC     A,i
000A43 F583              MOV      DPH,A
000A45 E4                CLR      A
000A46 93                MOVC     A,@A+DPTR
000A47 FF                MOV      R7,A
000A48 6020              JZ       ?C0016?FLASHUTILS
   60: 			buffer[j] = *(EETempAddr+i);
000A4A E545              MOV      A,buffer+01H
000A4C 254F              ADD      A,j+01H
000A4E F582              MOV      DPL,A
000A50 E544              MOV      A,buffer
000A52 354E              ADDC     A,j
000A54 F583              MOV      DPH,A
000A56 EF                MOV      A,R7
000A57 F0                MOVX     @DPTR,A
   61: 			i++;
000A58 054D              INC      i+01H
000A5A E54D              MOV      A,i+01H
000A5C 7002              JNZ      ?C0025?FLASHUTILS
000A5E 054C              INC      i
000A60         ?C0025?FLASHUTILS:
   62: 			j++;
000A60 054F              INC      j+01H
000A62 E54F              MOV      A,j+01H
000A64 7002              JNZ      ?C0026?FLASHUTILS
000A66 054E              INC      j
000A68         ?C0026?FLASHUTILS:
   63: 		}
000A68 80CF              SJMP     ?C0015?FLASHUTILS
000A6A         ?C0016?FLASHUTILS:
   64: 		EETempAddr = EETempAddr + BYTES_PER_WORDLINE;		
000A6A 7420              MOV      A,#020H
000A6C 254B              ADD      A,EETempAddr+01H
000A6E F54B              MOV      EETempAddr+01H,A
000A70 E4                CLR      A
000A71 354A              ADDC     A,EETempAddr
000A73 F54A              MOV      EETempAddr,A
   65: 	}	
000A75 80A1              SJMP     ?C0013?FLASHUTILS
   66: }
000A77         ?C0017?FLASHUTILS:
000A77 22                RET      
----- FUNCTION _readFlashToBuffer (END) -------


LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:54:36  PAGE 23


----- FUNCTION _FLASH_Erase (BEGIN) -----
 FILE: 'FlashHandler.c'
  161: bit FLASH_Erase			(unsigned int DFlash0Sector,unsigned int DFlash1Sector)
  162: #endif	// XC88x
;---- Variable 'DFlash1Sector' assigned to Register 'R4/R5' ----
;---- Variable 'DFlash0Sector' assigned to Register 'R6/R7' ----
  163: {
  164: #ifdef	XC88x
  165:     volatile bit success; 
  166: #endif	// XC88x
  167: 	t_unFLPARAM P1;
  168: #ifdef	XC88x
  169: 	t_unFLPARAM P2;
  170: #endif	// XC88x
  171: 
  172: #ifdef	XC866
  173: #define USE_BANK  3								// fix the used registerbank to 3 for XC866 devices
  174: #endif	// XC866
  175: 
  176: 	P1.UINT_Param = DFlash0Sector;
000A78 8E54              MOV      P1,R6
000A7A 8F55              MOV      P1+01H,R7
  177: #ifdef	XC88x
  178: 	P2.UINT_Param = DFlash1Sector;
000A7C 8C56              MOV      P2,R4
000A7E 8D57              MOV      P2+01H,R5
  179: #endif	// XC88x
  180: 	
  181: #ifdef	XC866
  182: 	REG[(4+(USE_BANK*8))] = P1.UBYTE_Param[0];	// DFLASH0 Sector - BANK3 - High Adr Byte
  183: 	REG[(3+(USE_BANK*8))] = P1.UBYTE_Param[1];	// DFLASH0 Sector - BANK3 - Low  Adr Byte
  184: #endif	// XC866
  185: #ifdef	XC88x
  186: 	REG[(1+(USE_BANK*8))] = P1.UBYTE_Param[0];	// DFLASH0 Sector -         High Adr Byte
000A80 7819              MOV      R0,#019H
000A82 A654              MOV      @R0,P1
  187: 	REG[(0+(USE_BANK*8))] = P1.UBYTE_Param[1];	// DFLASH0 Sector -         Low  Adr Byte
000A84 18                DEC      R0
000A85 A655              MOV      @R0,P1+01H
  188: 	REG[(4+(USE_BANK*8))] = P2.UBYTE_Param[0];	// DFLASH1 Sector  
000A87 781C              MOV      R0,#01CH
000A89 A656              MOV      @R0,P2
  189: 	REG[(3+(USE_BANK*8))] = P2.UBYTE_Param[1];	// DFLASH1 Sector  
000A8B 18                DEC      R0
000A8C A657              MOV      @R0,P2+01H
  190: #endif	// XC88x
  191: 	REG[(5+(USE_BANK*8))] = 0;					// PFLASH  
000A8E 781D              MOV      R0,#01DH
000A90 E4                CLR      A
000A91 F6                MOV      @R0,A
  192: 	REG[(6+(USE_BANK*8))] = 0;					// PFLASH  
000A92 08                INC      R0
000A93 F6                MOV      @R0,A
  193: 	REG[(7+(USE_BANK*8))] = 0;					// PFLASH  
000A94 08                INC      R0
000A95 F6                MOV      @R0,A
  194: 
  195: #ifdef XC88x
  196: 	PUSH(PSW);
000A96 C0D0              PUSH     PSW
  197: 	PSW = ((USE_BANK)<<3);
000A98 75D018            MOV      PSW,#018H
  198: #endif	// XC88x
  199: 
  200: #ifdef	__C51__
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:54:36  PAGE 24


  201: 	((void (code *) (void)) FLASH_ERASE) ();
000A9B 12DFF9            LCALL    0DFF9H
  202: #endif	// __C51__
  203: #ifdef	SDCC
  204: _asm
  205: 	LCALL FLASH_ERASE;
  206: _endasm;
  207: #endif	// SDCC
  208: 
  209: #ifdef	XC866
  210: 	return(!CY);
  211: #endif	// XC866
  212: #ifdef	XC88x
  213: 	success = CY;
000A9E 9202              MOV      success,C
  214: 	POP(PSW);
000AA0 D0D0              POP      PSW
  215: 	return (!success);
000AA2 A202              MOV      C,success
000AA4 B3                CPL      C
  216: #endif	// XC88x
  217: }
000AA5 22                RET      
----- FUNCTION _FLASH_Erase (END) -------


----- FUNCTION getFlashDataEndAddress (BEGIN) -----
 FILE: 'FlashUtils.c'
   12: unsigned char code * getFlashDataEndAddress() {
   13:   // Initialize the pointer to the FLASH (Checking if there is a valid data)
   14:   unsigned char code * EECurrentAddr = (unsigned char code*)FLASH_LAST_ADDR;
;---- Variable 'EECurrentAddr' assigned to Register 'R6/R7' ----
000AA6 7F00              MOV      R7,#00H
000AA8 7EAC              MOV      R6,#0ACH
   15:   unsigned char code * EETempAddr;
   16:           
   17:   for (EETempAddr = (unsigned char code*)FLASH_FIRST_ADDR; EETempAddr <= (unsigned char code*)FLASH_LAST_ADDR; EE
>> TempAddr += BYTES_PER_WORDLINE)
;---- Variable 'EETempAddr' assigned to Register 'DPTR' ----
000AAA 90A000            MOV      DPTR,#0A000H
000AAD         ?C0001?FLASHUTILS:
000AAD D3                SETB     C
000AAE E582              MOV      A,DPL
000AB0 9400              SUBB     A,#00H
000AB2 E583              MOV      A,DPH
000AB4 94AC              SUBB     A,#0ACH
000AB6 5017              JNC      ?C0002?FLASHUTILS
   18: 	{
   19: 		if (*EETempAddr == 0)
000AB8 E4                CLR      A
000AB9 93                MOVC     A,@A+DPTR
000ABA 7006              JNZ      ?C0003?FLASHUTILS
   20: 		{
   21: 			EECurrentAddr = EETempAddr;
000ABC AE83              MOV      R6,DPH
000ABE AF82              MOV      R7,DPL
   22: 			break;
000AC0 800D              SJMP     ?C0002?FLASHUTILS
   23: 		}
   24: 	}
000AC2         ?C0003?FLASHUTILS:
000AC2 7420              MOV      A,#020H
000AC4 2582              ADD      A,DPL
000AC6 F582              MOV      DPL,A
000AC8 E4                CLR      A
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:54:36  PAGE 25


000AC9 3583              ADDC     A,DPH
000ACB F583              MOV      DPH,A
000ACD 80DE              SJMP     ?C0001?FLASHUTILS
000ACF         ?C0002?FLASHUTILS:
   25: 	return EECurrentAddr;
   26: }
000ACF 22                RET      
----- FUNCTION getFlashDataEndAddress (END) -------


