LX51 LINKER/LOCATER V4.66.41.0                                                          03/17/2016  16:16:15  PAGE 1





ASSEMBLER CODE PACKING OF MODULE:  TestBoard (?C_STARTUP)


----- FUNCTION isAllHVRelayOK (BEGIN) -----
 FILE: 'DeviceController.c'
   73: bool isAllHVRelayOK() {
   74: 	#ifdef STARTER_KIT_EMU
   75: 		return IO_ubReadPin(HV_READY_1);
000020 A2C8              MOV      C,P4_0
   76: 	#else
   77: 		return 
   78: 			IO_ubReadPin(HV_READY_1) &&
   79: 			IO_ubReadPin(HV_READY_2) &&
   80: 			IO_ubReadPin(HV_READY_3) &&
   81: 			IO_ubReadPin(HV_FAULT_1) &&
   82: 			IO_ubReadPin(HV_FAULT_2) &&
   83: 			IO_ubReadPin(HV_FAULT_3);
   84: 	#endif
   85: }
000022 22                RET      
----- FUNCTION isAllHVRelayOK (END) -------


000023 020814            LJMP     0814H
----- FUNCTION MAIN_vInit (BEGIN) -----
 FILE: 'MAIN.C'
   30: void MAIN_vInit(void)
   31: {
   32:   ///  -----------------------------------------------------------------------
   33:   ///  Configuration of the System Clock:
   34:   ///  -----------------------------------------------------------------------
   35:   ///  - On Chip Osc is Selected
   36:   ///  - PLL Mode, NDIV =  20
   37:   ///  - input frequency is 9.6 MHz
   38: 
   39:   //   FCLK runs at 2 times the frequency of PCLK.
   40:   SFR_PAGE(_su1, noSST);         // switch to page1
0003F3 75BF01            MOV      SCU_PAGE,#01H
   41:   CMCON         =  0x10;         // load Clock Control Register
0003F6 75BA10            MOV      CMCON,#010H
   42:   SFR_PAGE(_su0, noSST);         // switch to page0
0003F9 E4                CLR      A
0003FA F5BF              MOV      SCU_PAGE,A
   43: 
   44: 
   45:   ///  *********************************************************************************
   46:   ///  Note : All peripheral related IO configurations are done in the 
   47:   ///  respective peripheral modules (alternate functions selection)
   48:   ///  *********************************************************************************
   49: 
   50:   ///  Initialization of module 'GPIO'
   51:   IO_vInit();
0003FC 910C              ACALL    IO_vInit
   52: 
   53:   ///  Initialization of module 'UART (Serial Interface)'
   54:   UART_vInit();
0003FE F1EE              ACALL    UART_vInit
   55: 
   56:   //   Interrupt Priority
   57: 
   58:   IP            =  0x00;         // load Interrupt Priority Register
000400 E4                CLR      A
000401 F5B8              MOV      IP,A
LX51 LINKER/LOCATER V4.66.41.0                                                        03/17/2016  16:16:15  PAGE 2


   59:   IPH           =  0x00;         // load Interrupt Priority High Register
000403 F5B9              MOV      IPH,A
   60:   IP1           =  0x00;         // load Interrupt Priority 1 Register
000405 F5F8              MOV      IP1,A
   61:   IPH1          =  0x00;         // load Interrupt Priority 1 High Register
000407 F5F9              MOV      IPH1,A
   62: 
   63: 
   64:   //// Interrupt structure 2 mode 0 is selected.
   65:   //// Interrupt service routine choice 2 is selected.
   66:   //   globally enable interrupts
   67:   EA            =  1;           
000409 D2AF              SETB     EA
   68: 
   69: } 
00040B 22                RET      
----- FUNCTION MAIN_vInit (END) -------


----- FUNCTION IO_vInit (BEGIN) -----
 FILE: 'IO.C'
   49: void IO_vInit(void)
   50: {
   51: 	#ifdef STARTER_KIT_EMU
   52: 		P1_DIR        		= 0x04; 
00040C 759104            MOV      P1_DIR,#04H
   53: 		P1_DATA       		= 0x00;
00040F E4                CLR      A
000410 F590              MOV      P1_DATA,A
   54: 		P3_DIR			  		= 0xFF;
000412 75B1FF            MOV      P3_DIR,#0FFH
   55: 		P3_DATA						= 0x00;
000415 F5B0              MOV      P3_DATA,A
   56: 	#else
   57: 
   58: 		///  -----------------------------------------------------------------------
   59: 		///  Configuration of Port P0:
   60: 		///  -----------------------------------------------------------------------
   61: 		///  - no pin of port P0 is used
   62: 
   63: 
   64: 		///  -----------------------------------------------------------------------
   65: 		///  Configuration of Port P1:
   66: 		///  -----------------------------------------------------------------------
   67: 		///  P1.0:
   68: 		///  - is used as general purpose output
   69: 		///  - push/pull output is selected
   70: 		///  - the pin status is low level
   71: 		///  - pull-up device is assigned
   72: 		///  P1.1:
   73: 		///  - is used as general purpose output
   74: 		///  - push/pull output is selected
   75: 		///  - the pin status is low level
   76: 		///  - pull-up device is assigned
   77: 		///  P1.2:
   78: 		///  - is used as general purpose output
   79: 		///  - push/pull output is selected
   80: 		///  - the pin status is low level
   81: 		///  - pull-up device is assigned
   82: 		///  P1.3:
   83: 		///  - is used as general purpose output
   84: 		///  - push/pull output is selected
   85: 		///  - the pin status is low level
   86: 		///  - pull-up device is assigned
   87: 		///  P1.4:
LX51 LINKER/LOCATER V4.66.41.0                                                        03/17/2016  16:16:15  PAGE 3


   88: 		///  - is used as general purpose output
   89: 		///  - push/pull output is selected
   90: 		///  - the pin status is low level
   91: 		///  - pull-up device is assigned
   92: 		///  P1.5:
   93: 		///  - is used as general purpose output
   94: 		///  - push/pull output is selected
   95: 		///  - the pin status is low level
   96: 		///  - pull-up device is assigned
   97: 
   98: 
   99: 		P1_DIR        =  0x3F;         // load direction register
  100: 
  101: 		///  -----------------------------------------------------------------------
  102: 		///  Configuration of Port P2:
  103: 		///  -----------------------------------------------------------------------
  104: 		///  - no pin of port P2 is used
  105: 
  106: 
  107: 		///  -----------------------------------------------------------------------
  108: 		///  Configuration of Port P3:
  109: 		///  -----------------------------------------------------------------------
  110: 		///  P3.4:
  111: 		///  - is used as general purpose output
  112: 		///  - push/pull output is selected
  113: 		///  - the pin status is low level
  114: 		///  - pull device is disabled (tristate) 
  115: 		///  P3.5:
  116: 		///  - is used as general purpose output
  117: 		///  - push/pull output is selected
  118: 		///  - the pin status is low level
  119: 		///  - pull device is disabled (tristate) 
  120: 		///  P3.6:
  121: 		///  - is used as general purpose output
  122: 		///  - push/pull output is selected
  123: 		///  - the pin status is low level
  124: 		///  - pull device is disabled (tristate) 
  125: 		///  P3.7:
  126: 		///  - is used as general purpose output
  127: 		///  - push/pull output is selected
  128: 		///  - the pin status is low level
  129: 		///  - pull device is disabled (tristate) 
  130: 
  131: 
  132: 		P3_DIR        =  0xF0;         // load direction register
  133: 
  134: 		///  -----------------------------------------------------------------------
  135: 		///  Configuration of Port P4:
  136: 		///  -----------------------------------------------------------------------
  137: 		///  P4.0:
  138: 		///  - is used as general input
  139: 		///  - pull device is disabled (tristate) 
  140: 		///  P4.1:
  141: 		///  - is used as general input
  142: 		///  - pull device is disabled (tristate) 
  143: 		///  P4.2:
  144: 		///  - is used as general input
  145: 		///  - pull-up device is assigned
  146: 		///  P4.3:
  147: 		///  - is used as general input
  148: 		///  - pull device is disabled (tristate) 
  149: 		///  P4.4:
  150: 		///  - is used as general input
  151: 		///  - pull device is disabled (tristate) 
  152: 		///  P4.5:
LX51 LINKER/LOCATER V4.66.41.0                                                        03/17/2016  16:16:15  PAGE 4


  153: 		///  - is used as general input
  154: 		///  - pull device is disabled (tristate) 
  155: 
  156: 
  157: 		///  -----------------------------------------------------------------------
  158: 		///  Configuration of Port P5:
  159: 		///  -----------------------------------------------------------------------
  160: 		///  - no pin of port P5 is used
  161: 	#endif
  162: 
  163: } //  End of function IO_vInit
000417 22                RET      
----- FUNCTION IO_vInit (END) -------


----- FUNCTION main (BEGIN) -----
 FILE: 'MAIN.C'
   79: void main(void)
   80: {
   81:   MAIN_vInit();
   82: 	
000418 71F3              ACALL    MAIN_vInit
00041A         ?C0012?MAIN:
   83:   while(1) {
   84: 		
   85: 		if (shouldMonitorHVStatus && !isAllHVRelayOK()) {
00041A 30000C            JNB      shouldMonitorHVStatus,?C0014?MAIN
00041D 1120              ACALL    isAllHVRelayOK
00041F 4008              JC       ?C0014?MAIN
   86: 			sendUART("HV_NG\r\n");
000421 7BFF              MOV      R3,#0FFH
000423 7A03              MOV      R2,#HIGH 010003CBH
000425 79CB              MOV      R1,#LOW 010003CBH
000427 9131              ACALL    _sendUART
   87: 		}
000429         ?C0014?MAIN:
   88: 			
   89: 		delay(1);
000429 7F01              MOV      R7,#01H
00042B 7E00              MOV      R6,#00H
00042D B163              ACALL    _delay
   90: 	}
00042F 80E9              SJMP     ?C0012?MAIN
----- FUNCTION main (END) -------


----- FUNCTION _sendUART (BEGIN) -----
 FILE: 'UART.C'
  129: void sendUART(char * message) {
  130: 	char * current = message;
;---- Variable 'message' assigned to Register 'R1/R2/R3' ----
  131: 	while (*current != '\0') {
;---- Variable 'current' assigned to Register 'R1/R2/R3' ----
000431         ?C0002?UART:
  132: 		SBUF = *current;
000431 311C              ACALL    ?C?CLDPTR
000433 6010              JZ       ?C0006?UART
  133: 		while (TI == 0);
000435 F599              MOV      SBUF,A
000437         ?C0004?UART:
  134: 		TI = 0;		
000437 3099FD            JNB      TI,?C0004?UART
00043A         ?C0005?UART:
  135: 		current++;
00043A C299              CLR      TI
LX51 LINKER/LOCATER V4.66.41.0                                                        03/17/2016  16:16:15  PAGE 5


  136: 	}
00043C 7401              MOV      A,#01H
00043E 29                ADD      A,R1
00043F F9                MOV      R1,A
000440 E4                CLR      A
000441 3A                ADDC     A,R2
000442 FA                MOV      R2,A
  137: }
000443 80EC              SJMP     ?C0002?UART
  138: 
000445         ?C0006?UART:
000445 22                RET      
----- FUNCTION _sendUART (END) -------


----- FUNCTION sendUUID (BEGIN) -----
 FILE: 'DeviceController.c'
    7: void sendUUID() {
    8: 	char xdata uuidString[50];
    9: 	unsigned char code * currentFlashDataEndAddress = getFlashDataEndAddress();
000446 1208DA            LCALL    getFlashDataEndAddress
;---- Variable 'currentFlashDataEndAddress' assigned to Register 'R2/R3' ----
000449 AB07              MOV      R3,AR7
00044B AA06              MOV      R2,AR6
   10: 	readFlashToBuffer(uuidString, 50, currentFlashDataEndAddress);
00044D 7EF0              MOV      R6,#HIGH uuidString
00044F 7F64              MOV      R7,#LOW uuidString
000451 7D32              MOV      R5,#032H
000453 7C00              MOV      R4,#00H
000455 D145              ACALL    _readFlashToBuffer
   11: 	sendUART(uuidString);
000457 7B01              MOV      R3,#01H
000459 7AF0              MOV      R2,#HIGH uuidString
00045B 7964              MOV      R1,#LOW uuidString
00045D 9131              ACALL    _sendUART
   12: 	sendUART("\r\n");
00045F 7BFF              MOV      R3,#0FFH
000461 7A02              MOV      R2,#HIGH 01000226H
000463 7926              MOV      R1,#LOW 01000226H
000465 80CA              SJMP     _sendUART
----- FUNCTION sendUUID (END) -------


----- FUNCTION _processCommand (BEGIN) -----
 FILE: 'UART.C'
  139: void processCommand(char * command) {
  140: 	int commandSize = strlen(command);
000467 8B3F              MOV      command,R3
000469 8A40              MOV      command+01H,R2
00046B 8941              MOV      command+02H,R1
  141: 	char respondMessage[20] = {0};
00046D 71B6              ACALL    _strlen
00046F 8E42              MOV      commandSize,R6
000471 8F43              MOV      commandSize+01H,R7
  142: 	memset(respondMessage, 0, 20);
000473 7844              MOV      R0,#LOW respondMessage
000475 7C00              MOV      R4,#HIGH respondMessage
000477 7D00              MOV      R5,#00H
000479 7BFF              MOV      R3,#0FFH
00047B 7A03              MOV      R2,#HIGH _?ix1000
00047D 79A2              MOV      R1,#LOW _?ix1000
00047F 7E00              MOV      R6,#00H
000481 7F14              MOV      R7,#014H
000483 11F6              ACALL    ?C?COPY
  143: 	if (commandSize != 5 || command[0] != '$' || command[4] != '$') {
LX51 LINKER/LOCATER V4.66.41.0                                                        03/17/2016  16:16:15  PAGE 6


000485 7E00              MOV      R6,#00H
000487 7F14              MOV      R7,#014H
000489 7D00              MOV      R5,#00H
00048B 7B00              MOV      R3,#00H
00048D 7A00              MOV      R2,#HIGH respondMessage
00048F 7944              MOV      R1,#LOW respondMessage
000491 31E4              ACALL    ?C?MEMSET
  144: 		sendUART("Unknown Command\r\n");
000493 E543              MOV      A,commandSize+01H
000495 6405              XRL      A,#05H
000497 4542              ORL      A,commandSize
000499 706B              JNZ      ?C0026?UART
00049B AB3F              MOV      R3,command
00049D AA40              MOV      R2,command+01H
00049F A941              MOV      R1,command+02H
0004A1 311C              ACALL    ?C?CLDPTR
0004A3 B42409            CJNE     A,#024H,?C0008?UART
0004A6 900004            MOV      DPTR,#04H
0004A9 3135              ACALL    ?C?CLDOPTR
0004AB 6424              XRL      A,#024H
0004AD 6002              JZ       ?C0007?UART
0004AF         ?C0008?UART:
  145: 	} else {
  146: 		switch(command[1]) {
0004AF 8055              SJMP     ?C0026?UART
0004B1         ?C0007?UART:
  147: 			case 'a':
0004B1 AB3F              MOV      R3,command
0004B3 AA40              MOV      R2,command+01H
0004B5 A941              MOV      R1,command+02H
0004B7 900001            MOV      DPTR,#01H
0004BA 3135              ACALL    ?C?CLDOPTR
0004BC 249E              ADD      A,#09EH
0004BE 6018              JZ       ?C0012?UART
0004C0 14                DEC      A
0004C1 6023              JZ       ?C0013?UART
0004C3 14                DEC      A
0004C4 602E              JZ       ?C0014?UART
0004C6 14                DEC      A
0004C7 602D              JZ       ?C0015?UART
0004C9 14                DEC      A
0004CA 6038              JZ       ?C0016?UART
0004CC 2405              ADD      A,#05H
0004CE 7036              JNZ      ?C0017?UART
  148: 				enableLCRChannel(command[3]);
0004D0         ?C0011?UART:
  149: 				break;
0004D0 900003            MOV      DPTR,#03H
0004D3 3135              ACALL    ?C?CLDOPTR
0004D5 FF                MOV      R7,A
0004D6 C102              AJMP     _enableLCRChannel
  150: 			case 'b':
  151: 				enableLCChannel(command[3]);
0004D8         ?C0012?UART:
  152: 				break;
0004D8 AB3F              MOV      R3,command
0004DA AA40              MOV      R2,command+01H
0004DC A941              MOV      R1,command+02H
0004DE 900003            MOV      DPTR,#03H
0004E1 3135              ACALL    ?C?CLDOPTR
0004E3 FF                MOV      R7,A
0004E4 A1BF              AJMP     _enableLCChannel
  153: 			case 'c':
  154: 				setChargeMode(command[3]);
0004E6         ?C0013?UART:
LX51 LINKER/LOCATER V4.66.41.0                                                        03/17/2016  16:16:15  PAGE 7


  155: 				break;
0004E6 AB3F              MOV      R3,command
0004E8 AA40              MOV      R2,command+01H
0004EA A941              MOV      R1,command+02H
0004EC 900003            MOV      DPTR,#03H
0004EF 3135              ACALL    ?C?CLDOPTR
0004F1 FF                MOV      R7,A
0004F2 802C              SJMP     _setChargeMode
  156: 			case 'd':
  157: 				sendHVRelayStatus();
0004F4         ?C0014?UART:
  158: 				break;
0004F4 8018              SJMP     sendHVRelayStatus
  159: 			case 'e':
  160: 				setHVMonitorMode(command[3]);
0004F6         ?C0015?UART:
  161: 				break;
0004F6 AB3F              MOV      R3,command
0004F8 AA40              MOV      R2,command+01H
0004FA A941              MOV      R1,command+02H
0004FC 900003            MOV      DPTR,#03H
0004FF 3135              ACALL    ?C?CLDOPTR
000501 FF                MOV      R7,A
000502 A197              AJMP     _setHVMonitorMode
  162: 			case 'f':
  163: 				sendUUID();
000504         ?C0016?UART:
  164: 			default:
000504 9146              ACALL    sendUUID
  165: 				sendUART("Unknown Command\r\n");
000506         ?C0017?UART:
  166: 		}
000506         
000506 7BFF              MOV      R3,#0FFH
000508 7A03              MOV      R2,#HIGH 01000390H
00050A 7990              MOV      R1,#LOW 01000390H
00050C 8131              AJMP     _sendUART
  167: 	}
----- FUNCTION _processCommand (END) -------


----- FUNCTION sendHVRelayStatus (BEGIN) -----
 FILE: 'DeviceController.c'
   87: void sendHVRelayStatus() {
   88: 	if (isAllHVRelayOK()) {
   89: 		sendUART("HV_OK\r\n");
00050E 1120              ACALL    isAllHVRelayOK
000510 7BFF              MOV      R3,#0FFH
000512 5006              JNC      ?C0017?DEVICECONTROLLER
   90: 	} else {
000514 7A02              MOV      R2,#HIGH 01000296H
000516 7996              MOV      R1,#LOW 01000296H
   91: 		sendUART("HV_NG\r\n");		
000518 8004              SJMP     ?C0039?DEVICECONTROLLER
00051A         ?C0017?DEVICECONTROLLER:
   92: 	}
00051A 7A02              MOV      R2,#HIGH 0100029EH
00051C 799E              MOV      R1,#LOW 0100029EH
00051E         
00051E 8131              AJMP     _sendUART
   93: }
----- FUNCTION sendHVRelayStatus (END) -------


----- FUNCTION _setChargeMode (BEGIN) -----
LX51 LINKER/LOCATER V4.66.41.0                                                        03/17/2016  16:16:15  PAGE 8


 FILE: 'DeviceController.c'
   95: void setChargeMode(char modeCode) {
   96: 	if (modeCode == '1') {
000520 8F58              MOV      modeCode,R7
   97: 		if (!isAllHVRelayOK()) {
000522 E558              MOV      A,modeCode
000524 6431              XRL      A,#031H
000526 7020              JNZ      ?C0020?DEVICECONTROLLER
   98: 			IO_vResetPin(HV_CHANNEL);			
000528 1120              ACALL    isAllHVRelayOK
00052A 400E              JC       ?C0021?DEVICECONTROLLER
   99: 			IO_vResetPin(CHARGE_CHANNEL);
00052C C2B6              CLR      P3_6
  100: 			IO_vResetPin(DISCHARGE_CHANNEL);
00052E C2B7              CLR      P3_7
  101: 			sendUART("HV_NG\r\n");
000530 C292              CLR      P1_2
  102: 			return;
000532 7BFF              MOV      R3,#0FFH
000534 7A02              MOV      R2,#HIGH 0100029EH
000536 799E              MOV      R1,#LOW 0100029EH
000538 8027              SJMP     ?C0042?DEVICECONTROLLER
  103: 		}
00053A         ?C0021?DEVICECONTROLLER:
  104: 		IO_vResetPin(DISCHARGE_CHANNEL);
00053A C292              CLR      P1_2
  105: 		IO_vSetPin(HV_CHANNEL);
00053C D2B6              SETB     P3_6
  106: 		IO_vSetPin(CHARGE_CHANNEL);
00053E D2B7              SETB     P3_7
  107: 		sendUART("#c#1#\r\n");
000540 7BFF              MOV      R3,#0FFH
000542 7A02              MOV      R2,#HIGH 010002A6H
000544 79A6              MOV      R1,#LOW 010002A6H
000546         
  108: 	} else if (modeCode == '0') {
000546 8019              SJMP     ?C0042?DEVICECONTROLLER
000548         ?C0020?DEVICECONTROLLER:
000548 E558              MOV      A,modeCode
00054A B4300E            CJNE     A,#030H,?C0024?DEVICECONTROLLER
  109: 		IO_vResetPin(CHARGE_CHANNEL);
00054D C2B7              CLR      P3_7
  110: 		IO_vResetPin(HV_CHANNEL);
00054F C2B6              CLR      P3_6
  111: 		IO_vSetPin(DISCHARGE_CHANNEL);
000551 D292              SETB     P1_2
  112: 		sendUART("#c#0#\r\n");
000553 7BFF              MOV      R3,#0FFH
000555 7A02              MOV      R2,#HIGH 010002AEH
000557 79AE              MOV      R1,#LOW 010002AEH
000559         
  113: 	} else {
000559 8006              SJMP     ?C0042?DEVICECONTROLLER
00055B         ?C0024?DEVICECONTROLLER:
  114: 		sendUART("Unknown Charge Mode\r\n");		
00055B 7BFF              MOV      R3,#0FFH
00055D 7A02              MOV      R2,#HIGH 010002B6H
00055F 79B6              MOV      R1,#LOW 010002B6H
000561         
000561 8131              AJMP     _sendUART
  115: 	}
----- FUNCTION _setChargeMode (END) -------


----- FUNCTION _delay (BEGIN) -----
LX51 LINKER/LOCATER V4.66.41.0                                                        03/17/2016  16:16:15  PAGE 9


 FILE: 'MAIN.C'
   70: void delay(int second) {
   71:   int i, j, k;
;---- Variable 'second' assigned to Register 'R6/R7' ----
   72:   for (i = 0; i < second; i++) {
;---- Variable 'i' assigned to Register 'R4/R5' ----
000563 E4                CLR      A
000564 FD                MOV      R5,A
000565 FC                MOV      R4,A
000566         ?C0002?MAIN:
000566 C3                CLR      C
000567 ED                MOV      A,R5
000568 9F                SUBB     A,R7
000569 EE                MOV      A,R6
00056A 6480              XRL      A,#080H
00056C F8                MOV      R0,A
00056D EC                MOV      A,R4
00056E 6480              XRL      A,#080H
000570 98                SUBB     A,R0
000571 5023              JNC      ?C0011?MAIN
   73:     for (j = 0; j < 25; j++) {
;---- Variable 'j' assigned to Register 'R2/R3' ----
000573 E4                CLR      A
000574 FB                MOV      R3,A
000575 FA                MOV      R2,A
000576         ?C0005?MAIN:
   74:       for (k = 0; k < 30000; k++) {
;---- Variable 'k' assigned to Register 'DPTR' ----
000576 900000            MOV      DPTR,#00H
000579         ?C0008?MAIN:
   75:       }
000579 A3                INC      DPTR
00057A E582              MOV      A,DPL
00057C B430FA            CJNE     A,#030H,?C0008?MAIN
00057F E583              MOV      A,DPH
000581 B475F5            CJNE     A,#075H,?C0008?MAIN
   76:     }
000584         ?C0007?MAIN:
000584 0B                INC      R3
000585 BB0001            CJNE     R3,#00H,?C0017?MAIN
000588 0A                INC      R2
000589         ?C0017?MAIN:
000589 EB                MOV      A,R3
00058A 6419              XRL      A,#019H
00058C 4A                ORL      A,R2
00058D 70E7              JNZ      ?C0005?MAIN
   77:   }
00058F         ?C0004?MAIN:
00058F 0D                INC      R5
000590 BD0001            CJNE     R5,#00H,?C0018?MAIN
000593 0C                INC      R4
000594         ?C0018?MAIN:
000594 80D0              SJMP     ?C0002?MAIN
   78: }
000596         ?C0011?MAIN:
000596 22                RET      
----- FUNCTION _delay (END) -------


----- FUNCTION _setHVMonitorMode (BEGIN) -----
 FILE: 'DeviceController.c'
  118: void setHVMonitorMode(char modeCode) {
  119: 	if (modeCode == '1') {
000597 8F58              MOV      modeCode,R7
  120: 		shouldMonitorHVStatus = 1;
LX51 LINKER/LOCATER V4.66.41.0                                                        03/17/2016  16:16:15  PAGE 10


000599 E558              MOV      A,modeCode
00059B B4310A            CJNE     A,#031H,?C0026?DEVICECONTROLLER
  121: 		sendUART("#e#1#\r\n");
00059E D200              SETB     shouldMonitorHVStatus
  122: 	} else if (modeCode == '0') {
0005A0 7BFF              MOV      R3,#0FFH
0005A2 7A02              MOV      R2,#HIGH 010002CCH
0005A4 79CC              MOV      R1,#LOW 010002CCH
  123: 		shouldMonitorHVStatus = 0;
0005A6 8015              SJMP     ?C0044?DEVICECONTROLLER
0005A8         ?C0026?DEVICECONTROLLER:
0005A8 E558              MOV      A,modeCode
0005AA B4300A            CJNE     A,#030H,?C0028?DEVICECONTROLLER
  124: 		sendUART("#e#0#\r\n");
0005AD C200              CLR      shouldMonitorHVStatus
  125: 	} else {
0005AF 7BFF              MOV      R3,#0FFH
0005B1 7A02              MOV      R2,#HIGH 010002D4H
0005B3 79D4              MOV      R1,#LOW 010002D4H
0005B5         
  126: 		sendUART("Unknown HV Monitor Code\r\n");
0005B5 8006              SJMP     ?C0044?DEVICECONTROLLER
0005B7         ?C0028?DEVICECONTROLLER:
  127: 	}
0005B7 7BFF              MOV      R3,#0FFH
0005B9 7A02              MOV      R2,#HIGH 010002DCH
0005BB 79DC              MOV      R1,#LOW 010002DCH
0005BD         
0005BD 8131              AJMP     _sendUART
  128: 	
----- FUNCTION _setHVMonitorMode (END) -------


----- FUNCTION _enableLCChannel (BEGIN) -----
 FILE: 'DeviceController.c'
   15: void enableLCChannel(char channelCode) {
   16: 	// Switch off all LCR channel first.
;---- Variable 'channelCode' assigned to Register 'R7' ----
   17: 	IO_vResetPin(LC_CHANNEL_1);
0005BF C2B1              CLR      P3_1
   18: 	IO_vResetPin(LC_CHANNEL_2);
0005C1 C2B3              CLR      P3_3
   19: 	IO_vResetPin(LC_CHANNEL_3);
0005C3 C2B5              CLR      P3_5
   20: 	
   21: 	// Enable coressponding LCR channel GPIO
   22: 	switch(channelCode) {
0005C5 EF                MOV      A,R7
0005C6 24CF              ADD      A,#0CFH
0005C8 6012              JZ       ?C0004?DEVICECONTROLLER
0005CA 14                DEC      A
0005CB 6019              JZ       ?C0005?DEVICECONTROLLER
0005CD 14                DEC      A
0005CE 6020              JZ       ?C0006?DEVICECONTROLLER
0005D0 2403              ADD      A,#03H
0005D2 7026              JNZ      ?C0007?DEVICECONTROLLER
   23: 		case '0':
0005D4         ?C0003?DEVICECONTROLLER:
   24: 			sendUART("#b#0#\r\n");
0005D4 7BFF              MOV      R3,#0FFH
0005D6 7A02              MOV      R2,#HIGH 01000229H
0005D8 7929              MOV      R1,#LOW 01000229H
   25: 			break;
0005DA 8024              SJMP     ?C0034?DEVICECONTROLLER
   26: 		case '1':
LX51 LINKER/LOCATER V4.66.41.0                                                        03/17/2016  16:16:15  PAGE 11


0005DC         ?C0004?DEVICECONTROLLER:
   27: 			IO_vSetPin(LC_CHANNEL_1);
0005DC D2B1              SETB     P3_1
   28: 			sendUART("#b#1#\r\n");
0005DE 7BFF              MOV      R3,#0FFH
0005E0 7A02              MOV      R2,#HIGH 01000231H
0005E2 7931              MOV      R1,#LOW 01000231H
0005E4         
   29: 			break;
0005E4 801A              SJMP     ?C0034?DEVICECONTROLLER
   30: 		case '2':
0005E6         ?C0005?DEVICECONTROLLER:
   31: 			IO_vSetPin(LC_CHANNEL_2);
0005E6 D2B3              SETB     P3_3
   32: 			sendUART("#b#2#\r\n");		
0005E8 7BFF              MOV      R3,#0FFH
0005EA 7A02              MOV      R2,#HIGH 01000239H
0005EC 7939              MOV      R1,#LOW 01000239H
0005EE         
   33: 			break;
0005EE 8010              SJMP     ?C0034?DEVICECONTROLLER
   34: 		case '3':
0005F0         ?C0006?DEVICECONTROLLER:
   35: 			IO_vSetPin(LC_CHANNEL_3);
0005F0 D2B5              SETB     P3_5
   36: 			sendUART("#b#3#\r\n");
0005F2 7BFF              MOV      R3,#0FFH
0005F4 7A02              MOV      R2,#HIGH 01000241H
0005F6 7941              MOV      R1,#LOW 01000241H
0005F8         
   37: 			break;
0005F8 8006              SJMP     ?C0034?DEVICECONTROLLER
   38: 		default:
0005FA         ?C0007?DEVICECONTROLLER:
   39: 			sendUART("Unknown LC Channel.\r\n");			
0005FA 7BFF              MOV      R3,#0FFH
0005FC 7A02              MOV      R2,#HIGH 01000249H
0005FE 7949              MOV      R1,#LOW 01000249H
000600         
000600 8131              AJMP     _sendUART
   40: 			break;
   41: 	}
----- FUNCTION _enableLCChannel (END) -------


----- FUNCTION _enableLCRChannel (BEGIN) -----
 FILE: 'DeviceController.c'
   44: void enableLCRChannel(char channelCode) {
   45: 	// Switch off all LCR channel first.
;---- Variable 'channelCode' assigned to Register 'R7' ----
   46: 	IO_vResetPin(LCR_CHANNEL_1);
000602 C2B0              CLR      P3_0
   47: 	IO_vResetPin(LCR_CHANNEL_2);
000604 C2B2              CLR      P3_2
   48: 	IO_vResetPin(LCR_CHANNEL_3);
000606 C2B4              CLR      P3_4
   49: 	
   50: 	// Enable coressponding LCR channel GPIO
   51: 	switch(channelCode) {
000608 EF                MOV      A,R7
000609 24CF              ADD      A,#0CFH
00060B 6012              JZ       ?C0011?DEVICECONTROLLER
00060D 14                DEC      A
00060E 6019              JZ       ?C0012?DEVICECONTROLLER
000610 14                DEC      A
LX51 LINKER/LOCATER V4.66.41.0                                                        03/17/2016  16:16:15  PAGE 12


000611 6020              JZ       ?C0013?DEVICECONTROLLER
000613 2403              ADD      A,#03H
000615 7026              JNZ      ?C0014?DEVICECONTROLLER
   52: 		case '0':
000617         ?C0010?DEVICECONTROLLER:
   53: 			sendUART("#a#0#\r\n");
000617 7BFF              MOV      R3,#0FFH
000619 7A02              MOV      R2,#HIGH 0100025FH
00061B 795F              MOV      R1,#LOW 0100025FH
   54: 			break;
00061D 8024              SJMP     ?C0038?DEVICECONTROLLER
   55: 		case '1':
00061F         ?C0011?DEVICECONTROLLER:
   56: 			IO_vSetPin(LCR_CHANNEL_1);
00061F D2B0              SETB     P3_0
   57: 			sendUART("#a#1#\r\n");
000621 7BFF              MOV      R3,#0FFH
000623 7A02              MOV      R2,#HIGH 01000267H
000625 7967              MOV      R1,#LOW 01000267H
000627         
   58: 			break;
000627 801A              SJMP     ?C0038?DEVICECONTROLLER
   59: 		case '2':
000629         ?C0012?DEVICECONTROLLER:
   60: 			IO_vSetPin(LCR_CHANNEL_2);
000629 D2B2              SETB     P3_2
   61: 			sendUART("#a#2#\r\n");		
00062B 7BFF              MOV      R3,#0FFH
00062D 7A02              MOV      R2,#HIGH 0100026FH
00062F 796F              MOV      R1,#LOW 0100026FH
000631         
   62: 			break;
000631 8010              SJMP     ?C0038?DEVICECONTROLLER
   63: 		case '3':
000633         ?C0013?DEVICECONTROLLER:
   64: 			IO_vSetPin(LCR_CHANNEL_3);
000633 D2B4              SETB     P3_4
   65: 			sendUART("#a#3#\r\n");
000635 7BFF              MOV      R3,#0FFH
000637 7A02              MOV      R2,#HIGH 01000277H
000639 7977              MOV      R1,#LOW 01000277H
00063B         
   66: 			break;
00063B 8006              SJMP     ?C0038?DEVICECONTROLLER
   67: 		default:
00063D         ?C0014?DEVICECONTROLLER:
   68: 			sendUART("Unknown LCR Channel.\r\n");			
00063D 7BFF              MOV      R3,#0FFH
00063F 7A02              MOV      R2,#HIGH 0100027FH
000641 797F              MOV      R1,#LOW 0100027FH
000643         
000643 8131              AJMP     _sendUART
   69: 			break;
   70: 	}
----- FUNCTION _enableLCRChannel (END) -------


----- FUNCTION _readFlashToBuffer (BEGIN) -----
 FILE: 'FlashUtils.c'
   45: void readFlashToBuffer(char xdata * buffer, int n, unsigned char code * EECurrentAddr) 
   46: {
000645 8E58              MOV      buffer,R6
000647 8F59              MOV      buffer+01H,R7
000649 8C5A              MOV      n,R4
00064B 8D5B              MOV      n+01H,R5
LX51 LINKER/LOCATER V4.66.41.0                                                        03/17/2016  16:16:15  PAGE 13


00064D 8A5C              MOV      EECurrentAddr,R2
00064F 8B5D              MOV      EECurrentAddr+01H,R3
   47: 	unsigned char code * EETempAddr = (unsigned char code*)FLASH_FIRST_ADDR;
   48: 	int i = 0;
000651 755EA0            MOV      EETempAddr,#0A0H
000654 755F00            MOV      EETempAddr+01H,#00H
   49: 	int j = 0;
000657 E4                CLR      A
000658 F560              MOV      i,A
00065A F561              MOV      i+01H,A
   50: 	int k = 0;
00065C F562              MOV      j,A
00065E F563              MOV      j+01H,A
   51: 	memset(buffer, 0, n);
000660 F564              MOV      k,A
000662 F565              MOV      k+01H,A
   52: 	
000664 AE5A              MOV      R6,n
000666 AF5B              MOV      R7,n+01H
000668 FD                MOV      R5,A
000669 AA58              MOV      R2,buffer
00066B A959              MOV      R1,buffer+01H
00066D 7B01              MOV      R3,#01H
00066F 31E4              ACALL    ?C?MEMSET
000671         ?C0011?FLASHUTILS:
   53: 	while (FLASH_Ready(FLASH_BANK_TO_CHECK) == 0) {;}
000671 7F03              MOV      R7,#03H
000673 F1D2              ACALL    _FLASH_Ready
000675 50FA              JNC      ?C0011?FLASHUTILS
000677         ?C0012?FLASHUTILS:
000677         ?C0013?FLASHUTILS:
   54: 	
   55: 	while (EETempAddr < EECurrentAddr && j < n) 
000677 C3                CLR      C
000678 E55F              MOV      A,EETempAddr+01H
00067A 955D              SUBB     A,EECurrentAddr+01H
00067C E55E              MOV      A,EETempAddr
00067E 955C              SUBB     A,EECurrentAddr
000680 5054              JNC      ?C0017?FLASHUTILS
000682 C3                CLR      C
000683 E563              MOV      A,j+01H
000685 955B              SUBB     A,n+01H
000687 E55A              MOV      A,n
000689 6480              XRL      A,#080H
00068B F8                MOV      R0,A
00068C E562              MOV      A,j
00068E 6480              XRL      A,#080H
000690 98                SUBB     A,R0
000691 5043              JNC      ?C0017?FLASHUTILS
   56: 	{	
   57: 		i = 0;
000693 E4                CLR      A
000694 F560              MOV      i,A
000696 F561              MOV      i+01H,A
000698         ?C0015?FLASHUTILS:
   58: 		while (*(EETempAddr+i) != 0) {
000698 E55F              MOV      A,EETempAddr+01H
00069A 2561              ADD      A,i+01H
00069C F582              MOV      DPL,A
00069E E55E              MOV      A,EETempAddr
0006A0 3560              ADDC     A,i
0006A2 F583              MOV      DPH,A
0006A4 E4                CLR      A
0006A5 93                MOVC     A,@A+DPTR
0006A6 FF                MOV      R7,A
LX51 LINKER/LOCATER V4.66.41.0                                                        03/17/2016  16:16:15  PAGE 14


0006A7 6020              JZ       ?C0016?FLASHUTILS
   59: 			buffer[j] = *(EETempAddr+i);
0006A9 E559              MOV      A,buffer+01H
0006AB 2563              ADD      A,j+01H
0006AD F582              MOV      DPL,A
0006AF E558              MOV      A,buffer
0006B1 3562              ADDC     A,j
0006B3 F583              MOV      DPH,A
0006B5 EF                MOV      A,R7
0006B6 F0                MOVX     @DPTR,A
   60: 			i++;
0006B7 0561              INC      i+01H
0006B9 E561              MOV      A,i+01H
0006BB 7002              JNZ      ?C0025?FLASHUTILS
0006BD 0560              INC      i
0006BF         ?C0025?FLASHUTILS:
   61: 			j++;
0006BF 0563              INC      j+01H
0006C1 E563              MOV      A,j+01H
0006C3 7002              JNZ      ?C0026?FLASHUTILS
0006C5 0562              INC      j
0006C7         ?C0026?FLASHUTILS:
   62: 		}
0006C7 80CF              SJMP     ?C0015?FLASHUTILS
0006C9         ?C0016?FLASHUTILS:
   63: 		EETempAddr = EETempAddr + BYTES_PER_WORDLINE;		
0006C9 7420              MOV      A,#020H
0006CB 255F              ADD      A,EETempAddr+01H
0006CD F55F              MOV      EETempAddr+01H,A
0006CF E4                CLR      A
0006D0 355E              ADDC     A,EETempAddr
0006D2 F55E              MOV      EETempAddr,A
   64: 	}	
0006D4 80A1              SJMP     ?C0013?FLASHUTILS
   65: }
0006D6         ?C0017?FLASHUTILS:
0006D6 22                RET      
----- FUNCTION _readFlashToBuffer (END) -------


----- FUNCTION _writeBufferToFlash (BEGIN) -----
 FILE: 'FlashUtils.c'
   67: void writeBufferToFlash(char * buffer, unsigned char code ** EECurrentAddr) {
   68: 	char xdata pageBuffer[BYTES_PER_WORDLINE] = {0};
0006D7 8B21              MOV      buffer,R3
0006D9 8A22              MOV      buffer+01H,R2
0006DB 8923              MOV      buffer+02H,R1
   69: 	char * currentCharacter = buffer;
0006DD 7896              MOV      R0,#LOW pageBuffer
0006DF 7CF0              MOV      R4,#HIGH pageBuffer
0006E1 7D01              MOV      R5,#01H
0006E3 7BFF              MOV      R3,#0FFH
0006E5 7A03              MOV      R2,#HIGH _?ix1000
0006E7 79D3              MOV      R1,#LOW _?ix1000
0006E9 7E00              MOV      R6,#00H
0006EB 7F20              MOV      R7,#020H
0006ED 11F6              ACALL    ?C?COPY
   70: 	int i = 0;
0006EF 852127            MOV      currentCharacter,buffer
0006F2 852228            MOV      currentCharacter+01H,buffer+01H
0006F5 852329            MOV      currentCharacter+02H,buffer+02H
   71: 	
0006F8 E4                CLR      A
0006F9 F52A              MOV      i,A
0006FB F52B              MOV      i+01H,A
LX51 LINKER/LOCATER V4.66.41.0                                                        03/17/2016  16:16:15  PAGE 15


   72: 	FLASH_Erase(SECALL,0);
0006FD FD                MOV      R5,A
0006FE FC                MOV      R4,A
0006FF 7FFF              MOV      R7,#0FFH
000701 7E03              MOV      R6,#03H
000703 1208AC            LCALL    _FLASH_Erase
   73: 	*EECurrentAddr = (unsigned char code*)FLASH_FIRST_ADDR;			// if erase than 1. WL is current
000706 AB24              MOV      R3,EECurrentAddr
000708 AA25              MOV      R2,EECurrentAddr+01H
00070A A926              MOV      R1,EECurrentAddr+02H
00070C 74A0              MOV      A,#0A0H
00070E 75F000            MOV      B,#00H
000711 31C5              ACALL    ?C?ISTPTR
   74:   delay(2);
000713 7F02              MOV      R7,#02H
000715 7E00              MOV      R6,#00H
000717 B163              ACALL    _delay
   75: 	
   76: 	memset(pageBuffer, 0, BYTES_PER_WORDLINE);
000719 7E00              MOV      R6,#00H
00071B 7F20              MOV      R7,#020H
00071D 7D00              MOV      R5,#00H
00071F 7B01              MOV      R3,#01H
000721 7AF0              MOV      R2,#HIGH pageBuffer
000723 7996              MOV      R1,#LOW pageBuffer
000725 31E4              ACALL    ?C?MEMSET
000727         ?C0018?FLASHUTILS:
   77: 	while (*currentCharacter != 0) {
000727 AB27              MOV      R3,currentCharacter
000729 AA28              MOV      R2,currentCharacter+01H
00072B A929              MOV      R1,currentCharacter+02H
00072D 311C              ACALL    ?C?CLDPTR
00072F FF                MOV      R7,A
000730 604C              JZ       ?C0019?FLASHUTILS
   78: 		
   79: 		pageBuffer[i] = *currentCharacter;
000732 7496              MOV      A,#LOW pageBuffer
000734 252B              ADD      A,i+01H
000736 F582              MOV      DPL,A
000738 74F0              MOV      A,#HIGH pageBuffer
00073A 352A              ADDC     A,i
00073C F583              MOV      DPH,A
00073E EF                MOV      A,R7
00073F F0                MOVX     @DPTR,A
   80: 		if (i == 25) {
000740 E52B              MOV      A,i+01H
000742 6419              XRL      A,#019H
000744 452A              ORL      A,i
000746 7021              JNZ      ?C0020?FLASHUTILS
   81: 			writeToFlashPage(pageBuffer, EECurrentAddr);
000748 7EF0              MOV      R6,#HIGH pageBuffer
00074A 7F96              MOV      R7,#LOW pageBuffer
00074C AB24              MOV      R3,EECurrentAddr
00074E AA25              MOV      R2,EECurrentAddr+01H
000750 A926              MOV      R1,EECurrentAddr+02H
000752 F188              ACALL    _writeToFlashPage
   82: 			memset(pageBuffer, 0, BYTES_PER_WORDLINE);
000754 7E00              MOV      R6,#00H
000756 7F20              MOV      R7,#020H
000758 7D00              MOV      R5,#00H
00075A 7B01              MOV      R3,#01H
00075C 7AF0              MOV      R2,#HIGH pageBuffer
00075E 7996              MOV      R1,#LOW pageBuffer
000760 31E4              ACALL    ?C?MEMSET
   83: 			i = 0;
LX51 LINKER/LOCATER V4.66.41.0                                                        03/17/2016  16:16:15  PAGE 16


000762 E4                CLR      A
000763 F52A              MOV      i,A
000765 F52B              MOV      i+01H,A
   84: 		} else {
000767 8008              SJMP     ?C0021?FLASHUTILS
000769         ?C0020?FLASHUTILS:
   85: 			i++;
000769 052B              INC      i+01H
00076B E52B              MOV      A,i+01H
00076D 7002              JNZ      ?C0027?FLASHUTILS
00076F 052A              INC      i
000771         ?C0027?FLASHUTILS:
   86: 		}
000771         ?C0021?FLASHUTILS:
   87: 		currentCharacter++;
000771 7401              MOV      A,#01H
000773 2529              ADD      A,currentCharacter+02H
000775 F529              MOV      currentCharacter+02H,A
000777 E4                CLR      A
000778 3528              ADDC     A,currentCharacter+01H
00077A F528              MOV      currentCharacter+01H,A
   88: 	}
00077C 80A9              SJMP     ?C0018?FLASHUTILS
00077E         ?C0019?FLASHUTILS:
   89: 	writeToFlashPage(pageBuffer, EECurrentAddr);	
00077E 7EF0              MOV      R6,#HIGH pageBuffer
000780 7F96              MOV      R7,#LOW pageBuffer
000782 AB24              MOV      R3,EECurrentAddr
000784 AA25              MOV      R2,EECurrentAddr+01H
000786 A926              MOV      R1,EECurrentAddr+02H
;----                  JMP      _writeToFlashPage
----- FUNCTION _writeBufferToFlash (END) -------


----- FUNCTION _writeToFlashPage (BEGIN) -----
 FILE: 'FlashUtils.c'
   29: void writeToFlashPage(char xdata * buffer, unsigned char code ** EECurrentAddr) {
   30: 	int i = 0;
000788 8E2C              MOV      buffer,R6
00078A 8F2D              MOV      buffer+01H,R7
00078C 8B2E              MOV      EECurrentAddr,R3
00078E 8A2F              MOV      EECurrentAddr+01H,R2
000790 8930              MOV      EECurrentAddr+02H,R1
   31: 
;---- Variable 'i' assigned to Register 'R6/R7' ----
000792 E4                CLR      A
000793 FF                MOV      R7,A
000794 FE                MOV      R6,A
   32: 	for (i=0; i < BYTES_PER_WORDLINE; i++) {
000795         ?C0006?FLASHUTILS:
   33: 		WLBuf[i] = *buffer;
000795 852D82            MOV      DPL,buffer+01H
000798 852C83            MOV      DPH,buffer
00079B E0                MOVX     A,@DPTR
00079C FD                MOV      R5,A
00079D 74E0              MOV      A,#LOW WLBuf
00079F 2F                ADD      A,R7
0007A0 F8                MOV      R0,A
0007A1 A605              MOV      @R0,AR5
   34: 		buffer++;
0007A3 052D              INC      buffer+01H
0007A5 E52D              MOV      A,buffer+01H
0007A7 7002              JNZ      ?C0023?FLASHUTILS
0007A9 052C              INC      buffer
0007AB         ?C0023?FLASHUTILS:
LX51 LINKER/LOCATER V4.66.41.0                                                        03/17/2016  16:16:15  PAGE 17


   35: 	}
0007AB 0F                INC      R7
0007AC BF0001            CJNE     R7,#00H,?C0024?FLASHUTILS
0007AF 0E                INC      R6
0007B0         ?C0024?FLASHUTILS:
0007B0 EF                MOV      A,R7
0007B1 6420              XRL      A,#020H
0007B3 4E                ORL      A,R6
0007B4 70DF              JNZ      ?C0006?FLASHUTILS
0007B6         ?C0007?FLASHUTILS:
   36: 
   37: 	// Start the Flash Programming
   38: 	if (FLASH_Prog(*EECurrentAddr)) 
0007B6 AB2E              MOV      R3,EECurrentAddr
0007B8 AA2F              MOV      R2,EECurrentAddr+01H
0007BA A930              MOV      R1,EECurrentAddr+02H
0007BC 3162              ACALL    ?C?ILDPTR
0007BE FF                MOV      R7,A
0007BF AEF0              MOV      R6,B
0007C1 F1D6              ACALL    _FLASH_Prog
0007C3 500C              JNC      ?C0010?FLASHUTILS
   39: 	{
   40: 		*EECurrentAddr = *EECurrentAddr + BYTES_PER_WORDLINE;
0007C5 AB2E              MOV      R3,EECurrentAddr
0007C7 AA2F              MOV      R2,EECurrentAddr+01H
0007C9 A930              MOV      R1,EECurrentAddr+02H
0007CB E4                CLR      A
0007CC 75F020            MOV      B,#020H
0007CF 318D              ACALL    ?C?IILDPTR
   41: 	} 
   42: 	
   43: }
0007D1         ?C0010?FLASHUTILS:
0007D1 22                RET      
----- FUNCTION _writeToFlashPage (END) -------


----- FUNCTION _FLASH_Ready (BEGIN) -----
 FILE: 'FlashHandler.c'
   90: bit FLASH_Ready						(unsigned char BankNum)
   91: {
;---- Variable 'BankNum' assigned to Register 'R7' ----
   92:     ACC = BankNum;
   93: #ifdef __C51__		
0007D2 EF                MOV      A,R7
   94: 	((void (code *) (void)) FLASH_READ_STATUS) ();
0007D3 02DFF0            LJMP     0DFF0H
   95: #endif	// __C51__
   96: #ifdef	SDCC
   97: _asm
   98: 	LCALL FLASH_READ_STATUS;
   99: _endasm;
  100: #endif	// SDCC
  101: 	return(CY);
----- FUNCTION _FLASH_Ready (END) -------


----- FUNCTION _FLASH_Prog (BEGIN) -----
 FILE: 'FlashHandler.c'
  113: bit FLASH_Prog					(unsigned char code* WLAddress) 
  114: {
;---- Variable 'WLAddress' assigned to Register 'R6/R7' ----
  115: #ifdef	XC88x
  116: 	volatile bit success;		    // needed for CY flag saving of the BROM routine's result
  117: #endif	// XC88x
LX51 LINKER/LOCATER V4.66.41.0                                                        03/17/2016  16:16:15  PAGE 18


  118: #ifdef	XC866
  119: #define USE_BANK  3					// fix the used registerbank to 3 for XC866 devices
  120: #endif	// XC866
  121: 									// For SDCC parameter is now already in DPTR
  122: #ifdef SDCC
  123: 	*WLAddress;						// avoid warning of 'unreferenced function argument
  124: #endif	// SDCC
  125: #ifdef __C51__
  126:    DPTR = (unsigned int)WLAddress;
0007D6 8E83              MOV      DPH,R6
0007D8 8F82              MOV      DPL,R7
  127: #endif	// __C51__
  128: 
  129:    REG[(0+(USE_BANK*8))] = WORDLINE_BUFFER_ADDRESS;
0007DA 7818              MOV      R0,#018H
0007DC 76E0              MOV      @R0,#0E0H
  130: #ifdef	XC88x
  131: 	PUSH(PSW);
0007DE C0D0              PUSH     PSW
  132: 	PSW = ((USE_BANK)<<3);
0007E0 75D018            MOV      PSW,#018H
  133: #endif	// XC88x
  134: 
  135: #ifdef	__C51__		
  136: 	((void (code *) (void)) FLASH_PROG) ();
0007E3 12DFF6            LCALL    0DFF6H
  137: #endif	// __C51__
  138: #ifdef	SDCC
  139: _asm
  140: 	LCALL FLASH_PROG;
  141: _endasm;
  142: #endif	// SDCC
  143: 
  144: #ifdef	XC88x
  145: 	success = CY;
0007E6 9201              MOV      success,C
  146: 	POP(PSW);
0007E8 D0D0              POP      PSW
  147: 	return(!success);			  
0007EA A201              MOV      C,success
0007EC B3                CPL      C
  148: #endif	// XC88x
  149: #ifdef	XC866
  150: 	return (!CY);
  151: #endif	// XC866
  152: }
0007ED 22                RET      
----- FUNCTION _FLASH_Prog (END) -------


----- FUNCTION UART_vInit (BEGIN) -----
 FILE: 'UART.C'
   56: void UART_vInit(void)
   57: {
   58:   ///  -----------------------------------------------------------------------
   59:   ///  UART settings
   60:   ///  -----------------------------------------------------------------------
   61:   ///  Pin TXD_1 (P0.2) is selected for transmission
   62:   ///  Pin RXD_1 (P0.1) is selected for reception
   63:   ///  Receiver enabled
   64:   ///  Mode 1: 8-bit data, 1 start bit, 1 stop bit, variable baud rate
   65:   ///  Receiver interrupt flag RI will only be activated if a valid stop bit 
   66:   ///  was received
   67:   ///  BRG is selected for baudrate generation
   68: 
LX51 LINKER/LOCATER V4.66.41.0                                                        03/17/2016  16:16:15  PAGE 19


   69:   SFR_PAGE(_pp2, noSST);         // switch to page 2 without saving
0007EE 75B202            MOV      PORT_PAGE,#02H
   70:   P0_ALTSEL0   &= ~(ubyte)0x04;  // configure alternate function register 0
0007F1 5380FB            ANL      P0_ALTSEL0,#0FBH
   71:   P0_ALTSEL1   |=  (ubyte)0x04;  // configure alternate function register 1
0007F4 438604            ORL      P0_ALTSEL1,#04H
   72:   SFR_PAGE(_pp0, noSST);         // switch to page 0 without saving
0007F7 E4                CLR      A
0007F8 F5B2              MOV      PORT_PAGE,A
   73:   P0_DIR       |=  (ubyte)0x04;  // set output direction
0007FA 438604            ORL      P0_DIR,#04H
   74: 
   75: 
   76:   MODPISEL     |=  (ubyte)0x01;  // configure peripheral input select register
0007FD 43B301            ORL      MODPISEL,#01H
   77:   BCON          =  0x00;         // reset baudrate timer/reload register
000800 F5BD              MOV      BCON,A
   78:   SCON          =  0x70;         // load serial channel control register
000802 759870            MOV      SCON,#070H
   79: 
   80:   ///  -----------------------------------------------------------------------
   81:   ///  Baudrate generator settings
   82:   ///  -----------------------------------------------------------------------
   83:   ///  input clock = fPCLK
   84:   ///  Fractional divider is enabled
   85:   ///  baudrate = 9.6004 kbaud
   86: 
   87:   FDSTEP        =  0xD5;         // load fractional divider reload register
000805 75EAD5            MOV      FDSTEP,#0D5H
   88:   BG            =  0x81;         // load baudrate timer/reload register
000808 75BE81            MOV      BG,#081H
   89:   FDCON        |=  0x01;         // load Fractional Divider control register
00080B 43E901            ORL      FDCON,#01H
   90:   BCON         |=  0x01;         // load baud rate control register
00080E 43BD01            ORL      BCON,#01H
   91: 
   92:   ///  UART interrupt enabled
   93:   ES = 1;
000811 D2AC              SETB     ES
   94: 
   95: } //  End of function UART_vInit
000813 22                RET      
----- FUNCTION UART_vInit (END) -------


----- FUNCTION UART_viIsr (BEGIN) -----
 FILE: 'UART.C'
  170: void UART_viIsr(void) interrupt UARTINT
000814 C0E0              PUSH     ACC
000816 C0F0              PUSH     B
000818 C083              PUSH     DPH
00081A C082              PUSH     DPL
00081C C0D0              PUSH     PSW
00081E 75D000            MOV      PSW,#00H
000821 C000              PUSH     AR0
000823 C001              PUSH     AR1
000825 C002              PUSH     AR2
000827 C003              PUSH     AR3
000829 C004              PUSH     AR4
00082B C005              PUSH     AR5
00082D C006              PUSH     AR6
00082F C007              PUSH     AR7
  171: {
  172: 	// switch to page 0
  173:   SFR_PAGE(_su0, SST0);
LX51 LINKER/LOCATER V4.66.41.0                                                        03/17/2016  16:16:15  PAGE 20


000831 75BF80            MOV      SCU_PAGE,#080H
  174:   if (TI)
000834 309902            JNB      TI,?C0019?UART
  175:   {
  176: 		TI = 0;
000837 C299              CLR      TI
  177:   }
000839         ?C0019?UART:
  178:   if (RI)
000839 30984D            JNB      RI,?C0020?UART
  179:   {
  180: 		char receiveByte = SBUF;
00083C 85993E            MOV      receiveByte,SBUF
  181: 		if (receiveByte == '\r' || receiveByte == '\n' || bufferCount >= 18) {
00083F E53E              MOV      A,receiveByte
000841 640D              XRL      A,#0DH
000843 6013              JZ       ?C0022?UART
000845 E53E              MOV      A,receiveByte
000847 640A              XRL      A,#0AH
000849 600D              JZ       ?C0022?UART
00084B C3                CLR      C
00084C E509              MOV      A,bufferCount+01H
00084E 9412              SUBB     A,#012H
000850 E508              MOV      A,bufferCount
000852 6480              XRL      A,#080H
000854 9480              SUBB     A,#080H
000856 4020              JC       ?C0021?UART
000858         ?C0022?UART:
  182: 			processCommand(receiveBuffer);
000858 7B00              MOV      R3,#00H
00085A 7A00              MOV      R2,#HIGH receiveBuffer
00085C 790A              MOV      R1,#LOW receiveBuffer
00085E 120467            LCALL    _processCommand
  183: 			memset(receiveBuffer, 0, 20);			
000861 7E00              MOV      R6,#00H
000863 7F14              MOV      R7,#014H
000865 7D00              MOV      R5,#00H
000867 7B00              MOV      R3,#00H
000869 7A00              MOV      R2,#HIGH receiveBuffer
00086B 790A              MOV      R1,#LOW receiveBuffer
00086D 1201E4            LCALL    ?C?MEMSET
  184: 			bufferCount = 0;
000870 750800            MOV      bufferCount,#00H
000873 750900            MOV      bufferCount+01H,#00H
  185: 		} else {
000876 800F              SJMP     ?C0023?UART
000878         ?C0021?UART:
  186: 			receiveBuffer[bufferCount] = receiveByte;
000878 740A              MOV      A,#LOW receiveBuffer
00087A 2509              ADD      A,bufferCount+01H
00087C F8                MOV      R0,A
00087D A63E              MOV      @R0,receiveByte
  187: 			bufferCount++;
00087F 0509              INC      bufferCount+01H
000881 E509              MOV      A,bufferCount+01H
000883 7002              JNZ      ?C0025?UART
000885 0508              INC      bufferCount
000887         ?C0025?UART:
  188: 		}
000887         ?C0023?UART:
  189:     RI = 0;
000887 C298              CLR      RI
  190:   }
000889         ?C0020?UART:
  191: 
LX51 LINKER/LOCATER V4.66.41.0                                                        03/17/2016  16:16:15  PAGE 21


  192: 	// restore the old page
  193:   SFR_PAGE(_su0, RST0);
000889 75BFC0            MOV      SCU_PAGE,#0C0H
  194: }
00088C D007              POP      AR7
00088E D006              POP      AR6
000890 D005              POP      AR5
000892 D004              POP      AR4
000894 D003              POP      AR3
000896 D002              POP      AR2
000898 D001              POP      AR1
00089A D000              POP      AR0
00089C D0D0              POP      PSW
00089E D082              POP      DPL
0008A0 D083              POP      DPH
0008A2 D0F0              POP      B
0008A4 D0E0              POP      ACC
0008A6 32                RETI     
----- FUNCTION UART_viIsr (END) -------


----- FUNCTION FLASH_Erase_Abort (BEGIN) -----
 FILE: 'FlashHandler.c'
   75: bit FLASH_Erase_Abort (void)
   76: {
   77: #ifdef __C51__		
   78: 	((void (code *) (void)) FLASH_ERASE_ABORT) ();
0008A7 12DFF3            LCALL    0DFF3H
   79: #endif	// __C51__
   80: #ifdef	SDCC
   81: _asm
   82: 	LCALL FLASH_ERASE_ABORT;
   83: _endasm;
   84: #endif	// SDCC
   85: 	return (!CY);  
0008AA B3                CPL      C
   86: }
0008AB 22                RET      
----- FUNCTION FLASH_Erase_Abort (END) -------


----- FUNCTION _FLASH_Erase (BEGIN) -----
 FILE: 'FlashHandler.c'
  161: bit FLASH_Erase			(unsigned int DFlash0Sector,unsigned int DFlash1Sector)
  162: #endif	// XC88x
;---- Variable 'DFlash1Sector' assigned to Register 'R4/R5' ----
;---- Variable 'DFlash0Sector' assigned to Register 'R6/R7' ----
  163: {
  164: #ifdef	XC88x
  165:     volatile bit success; 
  166: #endif	// XC88x
  167: 	t_unFLPARAM P1;
  168: #ifdef	XC88x
  169: 	t_unFLPARAM P2;
  170: #endif	// XC88x
  171: 
  172: #ifdef	XC866
  173: #define USE_BANK  3								// fix the used registerbank to 3 for XC866 devices
  174: #endif	// XC866
  175: 
  176: 	P1.UINT_Param = DFlash0Sector;
0008AC 8E31              MOV      P1,R6
0008AE 8F32              MOV      P1+01H,R7
  177: #ifdef	XC88x
  178: 	P2.UINT_Param = DFlash1Sector;
LX51 LINKER/LOCATER V4.66.41.0                                                        03/17/2016  16:16:15  PAGE 22


0008B0 8C33              MOV      P2,R4
0008B2 8D34              MOV      P2+01H,R5
  179: #endif	// XC88x
  180: 	
  181: #ifdef	XC866
  182: 	REG[(4+(USE_BANK*8))] = P1.UBYTE_Param[0];	// DFLASH0 Sector - BANK3 - High Adr Byte
  183: 	REG[(3+(USE_BANK*8))] = P1.UBYTE_Param[1];	// DFLASH0 Sector - BANK3 - Low  Adr Byte
  184: #endif	// XC866
  185: #ifdef	XC88x
  186: 	REG[(1+(USE_BANK*8))] = P1.UBYTE_Param[0];	// DFLASH0 Sector -         High Adr Byte
0008B4 7819              MOV      R0,#019H
0008B6 A631              MOV      @R0,P1
  187: 	REG[(0+(USE_BANK*8))] = P1.UBYTE_Param[1];	// DFLASH0 Sector -         Low  Adr Byte
0008B8 18                DEC      R0
0008B9 A632              MOV      @R0,P1+01H
  188: 	REG[(4+(USE_BANK*8))] = P2.UBYTE_Param[0];	// DFLASH1 Sector  
0008BB 781C              MOV      R0,#01CH
0008BD A633              MOV      @R0,P2
  189: 	REG[(3+(USE_BANK*8))] = P2.UBYTE_Param[1];	// DFLASH1 Sector  
0008BF 18                DEC      R0
0008C0 A634              MOV      @R0,P2+01H
  190: #endif	// XC88x
  191: 	REG[(5+(USE_BANK*8))] = 0;					// PFLASH  
0008C2 781D              MOV      R0,#01DH
0008C4 E4                CLR      A
0008C5 F6                MOV      @R0,A
  192: 	REG[(6+(USE_BANK*8))] = 0;					// PFLASH  
0008C6 08                INC      R0
0008C7 F6                MOV      @R0,A
  193: 	REG[(7+(USE_BANK*8))] = 0;					// PFLASH  
0008C8 08                INC      R0
0008C9 F6                MOV      @R0,A
  194: 
  195: #ifdef XC88x
  196: 	PUSH(PSW);
0008CA C0D0              PUSH     PSW
  197: 	PSW = ((USE_BANK)<<3);
0008CC 75D018            MOV      PSW,#018H
  198: #endif	// XC88x
  199: 
  200: #ifdef	__C51__
  201: 	((void (code *) (void)) FLASH_ERASE) ();
0008CF 12DFF9            LCALL    0DFF9H
  202: #endif	// __C51__
  203: #ifdef	SDCC
  204: _asm
  205: 	LCALL FLASH_ERASE;
  206: _endasm;
  207: #endif	// SDCC
  208: 
  209: #ifdef	XC866
  210: 	return(!CY);
  211: #endif	// XC866
  212: #ifdef	XC88x
  213: 	success = CY;
0008D2 9202              MOV      success,C
  214: 	POP(PSW);
0008D4 D0D0              POP      PSW
  215: 	return (!success);
0008D6 A202              MOV      C,success
0008D8 B3                CPL      C
  216: #endif	// XC88x
  217: }
0008D9 22                RET      
----- FUNCTION _FLASH_Erase (END) -------
LX51 LINKER/LOCATER V4.66.41.0                                                        03/17/2016  16:16:15  PAGE 23




----- FUNCTION getFlashDataEndAddress (BEGIN) -----
 FILE: 'FlashUtils.c'
   12: unsigned char code * getFlashDataEndAddress() {
   13:   // Initialize the pointer to the FLASH (Checking if there is a valid data)
   14:   unsigned char code * EECurrentAddr = (unsigned char code*)FLASH_LAST_ADDR;
;---- Variable 'EECurrentAddr' assigned to Register 'R6/R7' ----
0008DA 7F00              MOV      R7,#00H
0008DC 7EAC              MOV      R6,#0ACH
   15:   unsigned char code * EETempAddr;
   16:           
   17:   for (EETempAddr = (unsigned char code*)FLASH_FIRST_ADDR; EETempAddr <= (unsigned char code*)FLASH_LAST_ADDR; EE
>> TempAddr += BYTES_PER_WORDLINE)
;---- Variable 'EETempAddr' assigned to Register 'DPTR' ----
0008DE 90A000            MOV      DPTR,#0A000H
0008E1         ?C0001?FLASHUTILS:
0008E1 D3                SETB     C
0008E2 E582              MOV      A,DPL
0008E4 9400              SUBB     A,#00H
0008E6 E583              MOV      A,DPH
0008E8 94AC              SUBB     A,#0ACH
0008EA 5017              JNC      ?C0002?FLASHUTILS
   18: 	{
   19: 		if (*EETempAddr == 0)
0008EC E4                CLR      A
0008ED 93                MOVC     A,@A+DPTR
0008EE 7006              JNZ      ?C0003?FLASHUTILS
   20: 		{
   21: 			EECurrentAddr = EETempAddr;
0008F0 AE83              MOV      R6,DPH
0008F2 AF82              MOV      R7,DPL
   22: 			break;
0008F4 800D              SJMP     ?C0002?FLASHUTILS
   23: 		}
   24: 	}
0008F6         ?C0003?FLASHUTILS:
0008F6 7420              MOV      A,#020H
0008F8 2582              ADD      A,DPL
0008FA F582              MOV      DPL,A
0008FC E4                CLR      A
0008FD 3583              ADDC     A,DPH
0008FF F583              MOV      DPH,A
000901 80DE              SJMP     ?C0001?FLASHUTILS
000903         ?C0002?FLASHUTILS:
   25: 	return EECurrentAddr;
   26: }
000903 22                RET      
----- FUNCTION getFlashDataEndAddress (END) -------


