LX51 LINKER/LOCATER V4.66.41.0                                                          03/18/2016  10:39:27  PAGE 1





ASSEMBLER CODE PACKING OF MODULE:  TestBoard (?C_STARTUP)


----- FUNCTION isAllHVRelayOK (BEGIN) -----
 FILE: 'DeviceController.c'
   73: bool isAllHVRelayOK() {
   74: 	#ifdef STARTER_KIT_EMU
   75: 		return IO_ubReadPin(HV_READY_1);
000020 A2C8              MOV      C,P4_0
   76: 	#else
   77: 		return 
   78: 			IO_ubReadPin(HV_READY_1) &&
   79: 			IO_ubReadPin(HV_READY_2) &&
   80: 			IO_ubReadPin(HV_READY_3) &&
   81: 			IO_ubReadPin(HV_FAULT_1) &&
   82: 			IO_ubReadPin(HV_FAULT_2) &&
   83: 			IO_ubReadPin(HV_FAULT_3);
   84: 	#endif
   85: }
000022 22                RET      
----- FUNCTION isAllHVRelayOK (END) -------


000023 E1F4              AJMP     010007F4H
----- FUNCTION MAIN_vInit (BEGIN) -----
 FILE: 'MAIN.C'
   30: void MAIN_vInit(void)
   31: {
   32:   ///  -----------------------------------------------------------------------
   33:   ///  Configuration of the System Clock:
   34:   ///  -----------------------------------------------------------------------
   35:   ///  - On Chip Osc is Selected
   36:   ///  - PLL Mode, NDIV =  20
   37:   ///  - input frequency is 9.6 MHz
   38: 
   39:   //   FCLK runs at 2 times the frequency of PCLK.
   40:   SFR_PAGE(_su1, noSST);         // switch to page1
00041E 75BF01            MOV      SCU_PAGE,#01H
   41:   CMCON         =  0x10;         // load Clock Control Register
000421 75BA10            MOV      CMCON,#010H
   42:   SFR_PAGE(_su0, noSST);         // switch to page0
000424 E4                CLR      A
000425 F5BF              MOV      SCU_PAGE,A
   43: 
   44: 
   45:   ///  *********************************************************************************
   46:   ///  Note : All peripheral related IO configurations are done in the 
   47:   ///  respective peripheral modules (alternate functions selection)
   48:   ///  *********************************************************************************
   49: 
   50:   ///  Initialization of module 'GPIO'
   51:   IO_vInit();
000427 9137              ACALL    IO_vInit
   52: 
   53:   ///  Initialization of module 'UART (Serial Interface)'
   54:   UART_vInit();
000429 F133              ACALL    UART_vInit
   55: 
   56:   //   Interrupt Priority
   57: 
   58:   IP            =  0x00;         // load Interrupt Priority Register
00042B E4                CLR      A
00042C F5B8              MOV      IP,A
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:39:27  PAGE 2


   59:   IPH           =  0x00;         // load Interrupt Priority High Register
00042E F5B9              MOV      IPH,A
   60:   IP1           =  0x00;         // load Interrupt Priority 1 Register
000430 F5F8              MOV      IP1,A
   61:   IPH1          =  0x00;         // load Interrupt Priority 1 High Register
000432 F5F9              MOV      IPH1,A
   62: 
   63: 
   64:   //// Interrupt structure 2 mode 0 is selected.
   65:   //// Interrupt service routine choice 2 is selected.
   66:   //   globally enable interrupts
   67:   EA            =  1;           
000434 D2AF              SETB     EA
   68: 
   69: } 
000436 22                RET      
----- FUNCTION MAIN_vInit (END) -------


----- FUNCTION IO_vInit (BEGIN) -----
 FILE: 'IO.C'
   49: void IO_vInit(void)
   50: {
   51: 	#ifdef STARTER_KIT_EMU
   52: 		P1_DIR        		= 0x04; 
000437 759104            MOV      P1_DIR,#04H
   53: 		P1_DATA       		= 0x00;
00043A E4                CLR      A
00043B F590              MOV      P1_DATA,A
   54: 		P3_DIR			  		= 0xFF;
00043D 75B1FF            MOV      P3_DIR,#0FFH
   55: 		P3_DATA						= 0x00;
000440 F5B0              MOV      P3_DATA,A
   56: 	#else
   57: 
   58: 		///  -----------------------------------------------------------------------
   59: 		///  Configuration of Port P0:
   60: 		///  -----------------------------------------------------------------------
   61: 		///  - no pin of port P0 is used
   62: 
   63: 
   64: 		///  -----------------------------------------------------------------------
   65: 		///  Configuration of Port P1:
   66: 		///  -----------------------------------------------------------------------
   67: 		///  P1.0:
   68: 		///  - is used as general purpose output
   69: 		///  - push/pull output is selected
   70: 		///  - the pin status is low level
   71: 		///  - pull-up device is assigned
   72: 		///  P1.1:
   73: 		///  - is used as general purpose output
   74: 		///  - push/pull output is selected
   75: 		///  - the pin status is low level
   76: 		///  - pull-up device is assigned
   77: 		///  P1.2:
   78: 		///  - is used as general purpose output
   79: 		///  - push/pull output is selected
   80: 		///  - the pin status is low level
   81: 		///  - pull-up device is assigned
   82: 		///  P1.3:
   83: 		///  - is used as general purpose output
   84: 		///  - push/pull output is selected
   85: 		///  - the pin status is low level
   86: 		///  - pull-up device is assigned
   87: 		///  P1.4:
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:39:27  PAGE 3


   88: 		///  - is used as general purpose output
   89: 		///  - push/pull output is selected
   90: 		///  - the pin status is low level
   91: 		///  - pull-up device is assigned
   92: 		///  P1.5:
   93: 		///  - is used as general purpose output
   94: 		///  - push/pull output is selected
   95: 		///  - the pin status is low level
   96: 		///  - pull-up device is assigned
   97: 
   98: 
   99: 		P1_DIR        =  0x3F;         // load direction register
  100: 
  101: 		///  -----------------------------------------------------------------------
  102: 		///  Configuration of Port P2:
  103: 		///  -----------------------------------------------------------------------
  104: 		///  - no pin of port P2 is used
  105: 
  106: 
  107: 		///  -----------------------------------------------------------------------
  108: 		///  Configuration of Port P3:
  109: 		///  -----------------------------------------------------------------------
  110: 		///  P3.4:
  111: 		///  - is used as general purpose output
  112: 		///  - push/pull output is selected
  113: 		///  - the pin status is low level
  114: 		///  - pull device is disabled (tristate) 
  115: 		///  P3.5:
  116: 		///  - is used as general purpose output
  117: 		///  - push/pull output is selected
  118: 		///  - the pin status is low level
  119: 		///  - pull device is disabled (tristate) 
  120: 		///  P3.6:
  121: 		///  - is used as general purpose output
  122: 		///  - push/pull output is selected
  123: 		///  - the pin status is low level
  124: 		///  - pull device is disabled (tristate) 
  125: 		///  P3.7:
  126: 		///  - is used as general purpose output
  127: 		///  - push/pull output is selected
  128: 		///  - the pin status is low level
  129: 		///  - pull device is disabled (tristate) 
  130: 
  131: 
  132: 		P3_DIR        =  0xF0;         // load direction register
  133: 
  134: 		///  -----------------------------------------------------------------------
  135: 		///  Configuration of Port P4:
  136: 		///  -----------------------------------------------------------------------
  137: 		///  P4.0:
  138: 		///  - is used as general input
  139: 		///  - pull device is disabled (tristate) 
  140: 		///  P4.1:
  141: 		///  - is used as general input
  142: 		///  - pull device is disabled (tristate) 
  143: 		///  P4.2:
  144: 		///  - is used as general input
  145: 		///  - pull-up device is assigned
  146: 		///  P4.3:
  147: 		///  - is used as general input
  148: 		///  - pull device is disabled (tristate) 
  149: 		///  P4.4:
  150: 		///  - is used as general input
  151: 		///  - pull device is disabled (tristate) 
  152: 		///  P4.5:
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:39:27  PAGE 4


  153: 		///  - is used as general input
  154: 		///  - pull device is disabled (tristate) 
  155: 
  156: 
  157: 		///  -----------------------------------------------------------------------
  158: 		///  Configuration of Port P5:
  159: 		///  -----------------------------------------------------------------------
  160: 		///  - no pin of port P5 is used
  161: 	#endif
  162: 
  163: } //  End of function IO_vInit
000442 22                RET      
----- FUNCTION IO_vInit (END) -------


----- FUNCTION main (BEGIN) -----
 FILE: 'MAIN.C'
   79: void main(void)
   80: {
   81:   MAIN_vInit();
   82: 	
000443 911E              ACALL    MAIN_vInit
000445         ?C0012?MAIN:
   83:   while(1) {
   84: 		
   85: 		if (shouldMonitorHVStatus && !isAllHVRelayOK()) {
000445 30000C            JNB      shouldMonitorHVStatus,?C0014?MAIN
000448 1120              ACALL    isAllHVRelayOK
00044A 4008              JC       ?C0014?MAIN
   86: 			sendUART("HV_NG\r\n");
00044C 7BFF              MOV      R3,#0FFH
00044E 7A03              MOV      R2,#HIGH 010003F6H
000450 79F6              MOV      R1,#LOW 010003F6H
000452 915C              ACALL    _sendUART
   87: 		}
000454         ?C0014?MAIN:
   88: 			
   89: 		delay(1);
000454 7F01              MOV      R7,#01H
000456 7E00              MOV      R6,#00H
000458 F159              ACALL    _delay
   90: 	}
00045A 80E9              SJMP     ?C0012?MAIN
----- FUNCTION main (END) -------


----- FUNCTION _sendUART (BEGIN) -----
 FILE: 'UART.C'
  130: void sendUART(char * message) {
  131: 	char * current = message;
;---- Variable 'message' assigned to Register 'R1/R2/R3' ----
  132: 	while (*current != '\0') {
;---- Variable 'current' assigned to Register 'R1/R2/R3' ----
00045C         ?C0002?UART:
  133: 		SBUF = *current;
00045C 311B              ACALL    ?C?CLDPTR
00045E 6010              JZ       ?C0006?UART
  134: 		while (TI == 0);
000460 F599              MOV      SBUF,A
000462         ?C0004?UART:
  135: 		TI = 0;		
000462 3099FD            JNB      TI,?C0004?UART
000465         ?C0005?UART:
  136: 		current++;
000465 C299              CLR      TI
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:39:27  PAGE 5


  137: 	}
000467 7401              MOV      A,#01H
000469 29                ADD      A,R1
00046A F9                MOV      R1,A
00046B E4                CLR      A
00046C 3A                ADDC     A,R2
00046D FA                MOV      R2,A
  138: }
00046E 80EC              SJMP     ?C0002?UART
  139: 
000470         ?C0006?UART:
000470 22                RET      
----- FUNCTION _sendUART (END) -------


----- FUNCTION sendUUID (BEGIN) -----
 FILE: 'DeviceController.c'
    7: void sendUUID() {
    8: 	char xdata uuidString[50];
    9: 	unsigned char code * currentFlashDataEndAddress = getFlashDataEndAddress();
000471 B1C5              ACALL    getFlashDataEndAddress
;---- Variable 'currentFlashDataEndAddress' assigned to Register 'R2/R3' ----
000473 AB07              MOV      R3,AR7
000475 AA06              MOV      R2,AR6
   10: 	readFlashToBuffer(uuidString, 50, currentFlashDataEndAddress);
000477 7EF0              MOV      R6,#HIGH uuidString
000479 7F64              MOV      R7,#LOW uuidString
00047B 7D32              MOV      R5,#032H
00047D 7C00              MOV      R4,#00H
00047F D19D              ACALL    _readFlashToBuffer
   11: 	sendUART(uuidString);
000481 7B01              MOV      R3,#01H
000483 7AF0              MOV      R2,#HIGH uuidString
000485 7964              MOV      R1,#LOW uuidString
000487 915C              ACALL    _sendUART
   12: 	sendUART("\r\n");
000489 7BFF              MOV      R3,#0FFH
00048B 7A02              MOV      R2,#HIGH 01000225H
00048D 7925              MOV      R1,#LOW 01000225H
00048F 80CB              SJMP     _sendUART
----- FUNCTION sendUUID (END) -------


----- FUNCTION _processCommand (BEGIN) -----
 FILE: 'UART.C'
  140: void processCommand(char * command) {
  141: 	int commandSize = strlen(command);
000491 8B3F              MOV      command,R3
000493 8A40              MOV      command+01H,R2
000495 8941              MOV      command+02H,R1
  142: 	unsigned char code * flashEndAddress = getFlashDataEndAddress();	
000497 71E1              ACALL    _strlen
000499 8E42              MOV      commandSize,R6
00049B 8F43              MOV      commandSize+01H,R7
  143: 	char respondMessage[20] = {0};
00049D B1C5              ACALL    getFlashDataEndAddress
00049F 8E44              MOV      flashEndAddress,R6
0004A1 8F45              MOV      flashEndAddress+01H,R7
  144: 	memset(respondMessage, 0, 20);
0004A3 7846              MOV      R0,#LOW respondMessage
0004A5 7C00              MOV      R4,#HIGH respondMessage
0004A7 7D00              MOV      R5,#00H
0004A9 7BFF              MOV      R3,#0FFH
0004AB 7A03              MOV      R2,#HIGH _?ix1000
0004AD 79CD              MOV      R1,#LOW _?ix1000
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:39:27  PAGE 6


0004AF 7E00              MOV      R6,#00H
0004B1 7F14              MOV      R7,#014H
0004B3 11F5              ACALL    ?C?COPY
  145: 
0004B5 7E00              MOV      R6,#00H
0004B7 7F14              MOV      R7,#014H
0004B9 7D00              MOV      R5,#00H
0004BB 7B00              MOV      R3,#00H
0004BD 7A00              MOV      R2,#HIGH respondMessage
0004BF 7946              MOV      R1,#LOW respondMessage
0004C1 31E3              ACALL    ?C?MEMSET
  146: 	if (commandSize != 5 || command[0] != '$' || command[4] != '$') {
0004C3 E543              MOV      A,commandSize+01H
0004C5 6405              XRL      A,#05H
0004C7 4542              ORL      A,commandSize
0004C9 6002              JZ       $ + 4H
0004CB A168              AJMP     ?C0029?UART
0004CD AB3F              MOV      R3,command
0004CF AA40              MOV      R2,command+01H
0004D1 A941              MOV      R1,command+02H
0004D3 311B              ACALL    ?C?CLDPTR
0004D5 B42409            CJNE     A,#024H,?C0008?UART
0004D8 900004            MOV      DPTR,#04H
0004DB 3134              ACALL    ?C?CLDOPTR
0004DD 6424              XRL      A,#024H
0004DF 6002              JZ       ?C0007?UART
0004E1         ?C0008?UART:
  147: 		sendUART("Unknown Command\r\n");
  148: 	} else {
0004E1 A168              AJMP     ?C0029?UART
0004E3         ?C0007?UART:
  149: 		switch(command[1]) {
0004E3 AB3F              MOV      R3,command
0004E5 AA40              MOV      R2,command+01H
0004E7 A941              MOV      R1,command+02H
0004E9 900001            MOV      DPTR,#01H
0004EC 3134              ACALL    ?C?CLDOPTR
0004EE 249F              ADD      A,#09FH
0004F0 B40700            CJNE     A,#07H,?C0026?UART
0004F3         ?C0026?UART:
0004F3 5073              JNC      ?C0018?UART
0004F5 900503            MOV      DPTR,#0503H
0004F8 75F003            MOV      B,#03H
0004FB A4                MUL      AB
0004FC C583              XCH      A,DPH
0004FE 25F0              ADD      A,B
000500 C583              XCH      A,DPH
000502 73                JMP      @A+DPTR
000503         ?C0027?UART:
000503 020518            LJMP     ?C0011?UART
000506 020520            LJMP     ?C0012?UART
000509 02052E            LJMP     ?C0013?UART
00050C 02053C            LJMP     ?C0014?UART
00050F 02053E            LJMP     ?C0015?UART
000512 02054C            LJMP     ?C0016?UART
000515 02054E            LJMP     ?C0017?UART
  150: 			case 'a':
000518         ?C0011?UART:
  151: 				enableLCRChannel(command[3]);
000518 900003            MOV      DPTR,#03H
00051B 3134              ACALL    ?C?CLDOPTR
00051D FF                MOV      R7,A
00051E C15A              AJMP     _enableLCRChannel
  152: 				break;
  153: 			case 'b':
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:39:27  PAGE 7


000520         ?C0012?UART:
  154: 				enableLCChannel(command[3]);
000520 AB3F              MOV      R3,command
000522 AA40              MOV      R2,command+01H
000524 A941              MOV      R1,command+02H
000526 900003            MOV      DPTR,#03H
000529 3134              ACALL    ?C?CLDOPTR
00052B FF                MOV      R7,A
00052C C117              AJMP     _enableLCChannel
  155: 				break;
  156: 			case 'c':
00052E         ?C0013?UART:
  157: 				setChargeMode(command[3]);
00052E AB3F              MOV      R3,command
000530 AA40              MOV      R2,command+01H
000532 A941              MOV      R1,command+02H
000534 900003            MOV      DPTR,#03H
000537 3134              ACALL    ?C?CLDOPTR
000539 FF                MOV      R7,A
00053A 8046              SJMP     _setChargeMode
  158: 				break;
  159: 			case 'd':
00053C         ?C0014?UART:
  160: 				sendHVRelayStatus();
00053C 8032              SJMP     sendHVRelayStatus
  161: 				break;
  162: 			case 'e':
00053E         ?C0015?UART:
  163: 				setHVMonitorMode(command[3]);
00053E AB3F              MOV      R3,command
000540 AA40              MOV      R2,command+01H
000542 A941              MOV      R1,command+02H
000544 900003            MOV      DPTR,#03H
000547 3134              ACALL    ?C?CLDOPTR
000549 FF                MOV      R7,A
00054A A1EF              AJMP     _setHVMonitorMode
  164: 				break;
  165: 			case 'f':
00054C         ?C0016?UART:
  166: 				sendUUID();
00054C 8171              AJMP     sendUUID
  167: 				break;
  168: 			case 'g':
00054E         ?C0017?UART:
  169: 				writeBufferToFlash("QQFe8400-e29b-41d4-a716-44665544ABCD", &flashEndAddress);
00054E 755D00            MOV      ?_writeBufferToFlash?BYTE+03H,#00H
000551 755E00            MOV      ?_writeBufferToFlash?BYTE+04H,#HIGH flashEndAddress
000554 755F44            MOV      ?_writeBufferToFlash?BYTE+05H,#LOW flashEndAddress
000557 7BFF              MOV      R3,#0FFH
000559 7A03              MOV      R2,#HIGH 010003A1H
00055B 79A1              MOV      R1,#LOW 010003A1H
00055D 1208BA            LCALL    _writeBufferToFlash
  170: 				sendUART("DONE\r\n");
000560 7BFF              MOV      R3,#0FFH
000562 7A03              MOV      R2,#HIGH 010003C6H
000564 79C6              MOV      R1,#LOW 010003C6H
  171: 				break;
000566 8006              SJMP     ?C0030?UART
  172: 			default:
000568         ?C0018?UART:
  173: 				sendUART("Unknown Command\r\n");
000568         
000568 7BFF              MOV      R3,#0FFH
00056A 7A03              MOV      R2,#HIGH 0100038FH
00056C 798F              MOV      R1,#LOW 0100038FH
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:39:27  PAGE 8


00056E         
00056E 815C              AJMP     _sendUART
  174: 		}
  175: 	}
----- FUNCTION _processCommand (END) -------


----- FUNCTION sendHVRelayStatus (BEGIN) -----
 FILE: 'DeviceController.c'
   87: void sendHVRelayStatus() {
   88: 	if (isAllHVRelayOK()) {
   89: 		sendUART("HV_OK\r\n");
000570 1120              ACALL    isAllHVRelayOK
000572 7BFF              MOV      R3,#0FFH
000574 5006              JNC      ?C0017?DEVICECONTROLLER
   90: 	} else {
000576 7A02              MOV      R2,#HIGH 01000295H
000578 7995              MOV      R1,#LOW 01000295H
   91: 		sendUART("HV_NG\r\n");		
00057A 8004              SJMP     ?C0039?DEVICECONTROLLER
00057C         ?C0017?DEVICECONTROLLER:
   92: 	}
00057C 7A02              MOV      R2,#HIGH 0100029DH
00057E 799D              MOV      R1,#LOW 0100029DH
000580         
000580 815C              AJMP     _sendUART
   93: }
----- FUNCTION sendHVRelayStatus (END) -------


----- FUNCTION _setChargeMode (BEGIN) -----
 FILE: 'DeviceController.c'
   95: void setChargeMode(char modeCode) {
   96: 	if (modeCode == '1') {
000582 8F5A              MOV      modeCode,R7
   97: 		if (!isAllHVRelayOK()) {
000584 E55A              MOV      A,modeCode
000586 6431              XRL      A,#031H
000588 7020              JNZ      ?C0020?DEVICECONTROLLER
   98: 			IO_vResetPin(HV_CHANNEL);			
00058A 1120              ACALL    isAllHVRelayOK
00058C 400E              JC       ?C0021?DEVICECONTROLLER
   99: 			IO_vResetPin(CHARGE_CHANNEL);
00058E C2B6              CLR      P3_6
  100: 			IO_vResetPin(DISCHARGE_CHANNEL);
000590 C2B7              CLR      P3_7
  101: 			sendUART("HV_NG\r\n");
000592 C292              CLR      P1_2
  102: 			return;
000594 7BFF              MOV      R3,#0FFH
000596 7A02              MOV      R2,#HIGH 0100029DH
000598 799D              MOV      R1,#LOW 0100029DH
00059A 8027              SJMP     ?C0042?DEVICECONTROLLER
  103: 		}
00059C         ?C0021?DEVICECONTROLLER:
  104: 		IO_vResetPin(DISCHARGE_CHANNEL);
00059C C292              CLR      P1_2
  105: 		IO_vSetPin(HV_CHANNEL);
00059E D2B6              SETB     P3_6
  106: 		IO_vSetPin(CHARGE_CHANNEL);
0005A0 D2B7              SETB     P3_7
  107: 		sendUART("#c#1#\r\n");
0005A2 7BFF              MOV      R3,#0FFH
0005A4 7A02              MOV      R2,#HIGH 010002A5H
0005A6 79A5              MOV      R1,#LOW 010002A5H
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:39:27  PAGE 9


0005A8         
  108: 	} else if (modeCode == '0') {
0005A8 8019              SJMP     ?C0042?DEVICECONTROLLER
0005AA         ?C0020?DEVICECONTROLLER:
0005AA E55A              MOV      A,modeCode
0005AC B4300E            CJNE     A,#030H,?C0024?DEVICECONTROLLER
  109: 		IO_vResetPin(CHARGE_CHANNEL);
0005AF C2B7              CLR      P3_7
  110: 		IO_vResetPin(HV_CHANNEL);
0005B1 C2B6              CLR      P3_6
  111: 		IO_vSetPin(DISCHARGE_CHANNEL);
0005B3 D292              SETB     P1_2
  112: 		sendUART("#c#0#\r\n");
0005B5 7BFF              MOV      R3,#0FFH
0005B7 7A02              MOV      R2,#HIGH 010002ADH
0005B9 79AD              MOV      R1,#LOW 010002ADH
0005BB         
  113: 	} else {
0005BB 8006              SJMP     ?C0042?DEVICECONTROLLER
0005BD         ?C0024?DEVICECONTROLLER:
  114: 		sendUART("Unknown Charge Mode\r\n");		
0005BD 7BFF              MOV      R3,#0FFH
0005BF 7A02              MOV      R2,#HIGH 010002B5H
0005C1 79B5              MOV      R1,#LOW 010002B5H
0005C3         
0005C3 815C              AJMP     _sendUART
  115: 	}
----- FUNCTION _setChargeMode (END) -------


----- FUNCTION getFlashDataEndAddress (BEGIN) -----
 FILE: 'FlashUtils.c'
   12: unsigned char code * getFlashDataEndAddress() {
   13:   // Initialize the pointer to the FLASH (Checking if there is a valid data)
   14:   unsigned char code * EECurrentAddr = (unsigned char code*)FLASH_LAST_ADDR;
;---- Variable 'EECurrentAddr' assigned to Register 'R6/R7' ----
0005C5 7F00              MOV      R7,#00H
0005C7 7EAC              MOV      R6,#0ACH
   15:   unsigned char code * EETempAddr;
   16:           
   17:   for (EETempAddr = (unsigned char code*)FLASH_FIRST_ADDR; EETempAddr <= (unsigned char code*)FLASH_LAST_ADDR; EE
>> TempAddr += BYTES_PER_WORDLINE)
;---- Variable 'EETempAddr' assigned to Register 'DPTR' ----
0005C9 90A000            MOV      DPTR,#0A000H
0005CC         ?C0001?FLASHUTILS:
0005CC D3                SETB     C
0005CD E582              MOV      A,DPL
0005CF 9400              SUBB     A,#00H
0005D1 E583              MOV      A,DPH
0005D3 94AC              SUBB     A,#0ACH
0005D5 5017              JNC      ?C0002?FLASHUTILS
   18: 	{
   19: 		if (*EETempAddr == 0)
0005D7 E4                CLR      A
0005D8 93                MOVC     A,@A+DPTR
0005D9 7006              JNZ      ?C0003?FLASHUTILS
   20: 		{
   21: 			EECurrentAddr = EETempAddr;
0005DB AE83              MOV      R6,DPH
0005DD AF82              MOV      R7,DPL
   22: 			break;
0005DF 800D              SJMP     ?C0002?FLASHUTILS
   23: 		}
   24: 	}
0005E1         ?C0003?FLASHUTILS:
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:39:27  PAGE 10


0005E1 7420              MOV      A,#020H
0005E3 2582              ADD      A,DPL
0005E5 F582              MOV      DPL,A
0005E7 E4                CLR      A
0005E8 3583              ADDC     A,DPH
0005EA F583              MOV      DPH,A
0005EC 80DE              SJMP     ?C0001?FLASHUTILS
0005EE         ?C0002?FLASHUTILS:
   25: 	return EECurrentAddr;
   26: }
0005EE 22                RET      
----- FUNCTION getFlashDataEndAddress (END) -------


----- FUNCTION _setHVMonitorMode (BEGIN) -----
 FILE: 'DeviceController.c'
  118: void setHVMonitorMode(char modeCode) {
  119: 	if (modeCode == '1') {
0005EF 8F5A              MOV      modeCode,R7
  120: 		shouldMonitorHVStatus = 1;
0005F1 E55A              MOV      A,modeCode
0005F3 B4310A            CJNE     A,#031H,?C0026?DEVICECONTROLLER
  121: 		sendUART("#e#1#\r\n");
0005F6 D200              SETB     shouldMonitorHVStatus
  122: 	} else if (modeCode == '0') {
0005F8 7BFF              MOV      R3,#0FFH
0005FA 7A02              MOV      R2,#HIGH 010002CBH
0005FC 79CB              MOV      R1,#LOW 010002CBH
  123: 		shouldMonitorHVStatus = 0;
0005FE 8015              SJMP     ?C0044?DEVICECONTROLLER
000600         ?C0026?DEVICECONTROLLER:
000600 E55A              MOV      A,modeCode
000602 B4300A            CJNE     A,#030H,?C0028?DEVICECONTROLLER
  124: 		sendUART("#e#0#\r\n");
000605 C200              CLR      shouldMonitorHVStatus
  125: 	} else {
000607 7BFF              MOV      R3,#0FFH
000609 7A02              MOV      R2,#HIGH 010002D3H
00060B 79D3              MOV      R1,#LOW 010002D3H
00060D         
  126: 		sendUART("Unknown HV Monitor Code\r\n");
00060D 8006              SJMP     ?C0044?DEVICECONTROLLER
00060F         ?C0028?DEVICECONTROLLER:
  127: 	}
00060F 7BFF              MOV      R3,#0FFH
000611 7A02              MOV      R2,#HIGH 010002DBH
000613 79DB              MOV      R1,#LOW 010002DBH
000615         
000615 815C              AJMP     _sendUART
  128: 	
----- FUNCTION _setHVMonitorMode (END) -------


----- FUNCTION _enableLCChannel (BEGIN) -----
 FILE: 'DeviceController.c'
   15: void enableLCChannel(char channelCode) {
   16: 	// Switch off all LCR channel first.
;---- Variable 'channelCode' assigned to Register 'R7' ----
   17: 	IO_vResetPin(LC_CHANNEL_1);
000617 C2B1              CLR      P3_1
   18: 	IO_vResetPin(LC_CHANNEL_2);
000619 C2B3              CLR      P3_3
   19: 	IO_vResetPin(LC_CHANNEL_3);
00061B C2B5              CLR      P3_5
   20: 	
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:39:27  PAGE 11


   21: 	// Enable coressponding LCR channel GPIO
   22: 	switch(channelCode) {
00061D EF                MOV      A,R7
00061E 24CF              ADD      A,#0CFH
000620 6012              JZ       ?C0004?DEVICECONTROLLER
000622 14                DEC      A
000623 6019              JZ       ?C0005?DEVICECONTROLLER
000625 14                DEC      A
000626 6020              JZ       ?C0006?DEVICECONTROLLER
000628 2403              ADD      A,#03H
00062A 7026              JNZ      ?C0007?DEVICECONTROLLER
   23: 		case '0':
00062C         ?C0003?DEVICECONTROLLER:
   24: 			sendUART("#b#0#\r\n");
00062C 7BFF              MOV      R3,#0FFH
00062E 7A02              MOV      R2,#HIGH 01000228H
000630 7928              MOV      R1,#LOW 01000228H
   25: 			break;
000632 8024              SJMP     ?C0034?DEVICECONTROLLER
   26: 		case '1':
000634         ?C0004?DEVICECONTROLLER:
   27: 			IO_vSetPin(LC_CHANNEL_1);
000634 D2B1              SETB     P3_1
   28: 			sendUART("#b#1#\r\n");
000636 7BFF              MOV      R3,#0FFH
000638 7A02              MOV      R2,#HIGH 01000230H
00063A 7930              MOV      R1,#LOW 01000230H
00063C         
   29: 			break;
00063C 801A              SJMP     ?C0034?DEVICECONTROLLER
   30: 		case '2':
00063E         ?C0005?DEVICECONTROLLER:
   31: 			IO_vSetPin(LC_CHANNEL_2);
00063E D2B3              SETB     P3_3
   32: 			sendUART("#b#2#\r\n");		
000640 7BFF              MOV      R3,#0FFH
000642 7A02              MOV      R2,#HIGH 01000238H
000644 7938              MOV      R1,#LOW 01000238H
000646         
   33: 			break;
000646 8010              SJMP     ?C0034?DEVICECONTROLLER
   34: 		case '3':
000648         ?C0006?DEVICECONTROLLER:
   35: 			IO_vSetPin(LC_CHANNEL_3);
000648 D2B5              SETB     P3_5
   36: 			sendUART("#b#3#\r\n");
00064A 7BFF              MOV      R3,#0FFH
00064C 7A02              MOV      R2,#HIGH 01000240H
00064E 7940              MOV      R1,#LOW 01000240H
000650         
   37: 			break;
000650 8006              SJMP     ?C0034?DEVICECONTROLLER
   38: 		default:
000652         ?C0007?DEVICECONTROLLER:
   39: 			sendUART("Unknown LC Channel.\r\n");			
000652 7BFF              MOV      R3,#0FFH
000654 7A02              MOV      R2,#HIGH 01000248H
000656 7948              MOV      R1,#LOW 01000248H
000658         
000658 815C              AJMP     _sendUART
   40: 			break;
   41: 	}
----- FUNCTION _enableLCChannel (END) -------


LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:39:27  PAGE 12


----- FUNCTION _enableLCRChannel (BEGIN) -----
 FILE: 'DeviceController.c'
   44: void enableLCRChannel(char channelCode) {
   45: 	// Switch off all LCR channel first.
;---- Variable 'channelCode' assigned to Register 'R7' ----
   46: 	IO_vResetPin(LCR_CHANNEL_1);
00065A C2B0              CLR      P3_0
   47: 	IO_vResetPin(LCR_CHANNEL_2);
00065C C2B2              CLR      P3_2
   48: 	IO_vResetPin(LCR_CHANNEL_3);
00065E C2B4              CLR      P3_4
   49: 	
   50: 	// Enable coressponding LCR channel GPIO
   51: 	switch(channelCode) {
000660 EF                MOV      A,R7
000661 24CF              ADD      A,#0CFH
000663 6012              JZ       ?C0011?DEVICECONTROLLER
000665 14                DEC      A
000666 6019              JZ       ?C0012?DEVICECONTROLLER
000668 14                DEC      A
000669 6020              JZ       ?C0013?DEVICECONTROLLER
00066B 2403              ADD      A,#03H
00066D 7026              JNZ      ?C0014?DEVICECONTROLLER
   52: 		case '0':
00066F         ?C0010?DEVICECONTROLLER:
   53: 			sendUART("#a#0#\r\n");
00066F 7BFF              MOV      R3,#0FFH
000671 7A02              MOV      R2,#HIGH 0100025EH
000673 795E              MOV      R1,#LOW 0100025EH
   54: 			break;
000675 8024              SJMP     ?C0038?DEVICECONTROLLER
   55: 		case '1':
000677         ?C0011?DEVICECONTROLLER:
   56: 			IO_vSetPin(LCR_CHANNEL_1);
000677 D2B0              SETB     P3_0
   57: 			sendUART("#a#1#\r\n");
000679 7BFF              MOV      R3,#0FFH
00067B 7A02              MOV      R2,#HIGH 01000266H
00067D 7966              MOV      R1,#LOW 01000266H
00067F         
   58: 			break;
00067F 801A              SJMP     ?C0038?DEVICECONTROLLER
   59: 		case '2':
000681         ?C0012?DEVICECONTROLLER:
   60: 			IO_vSetPin(LCR_CHANNEL_2);
000681 D2B2              SETB     P3_2
   61: 			sendUART("#a#2#\r\n");		
000683 7BFF              MOV      R3,#0FFH
000685 7A02              MOV      R2,#HIGH 0100026EH
000687 796E              MOV      R1,#LOW 0100026EH
000689         
   62: 			break;
000689 8010              SJMP     ?C0038?DEVICECONTROLLER
   63: 		case '3':
00068B         ?C0013?DEVICECONTROLLER:
   64: 			IO_vSetPin(LCR_CHANNEL_3);
00068B D2B4              SETB     P3_4
   65: 			sendUART("#a#3#\r\n");
00068D 7BFF              MOV      R3,#0FFH
00068F 7A02              MOV      R2,#HIGH 01000276H
000691 7976              MOV      R1,#LOW 01000276H
000693         
   66: 			break;
000693 8006              SJMP     ?C0038?DEVICECONTROLLER
   67: 		default:
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:39:27  PAGE 13


000695         ?C0014?DEVICECONTROLLER:
   68: 			sendUART("Unknown LCR Channel.\r\n");			
000695 7BFF              MOV      R3,#0FFH
000697 7A02              MOV      R2,#HIGH 0100027EH
000699 797E              MOV      R1,#LOW 0100027EH
00069B         
00069B 815C              AJMP     _sendUART
   69: 			break;
   70: 	}
----- FUNCTION _enableLCRChannel (END) -------


----- FUNCTION _readFlashToBuffer (BEGIN) -----
 FILE: 'FlashUtils.c'
   46: void readFlashToBuffer(char xdata * buffer, int n, unsigned char code * EECurrentAddr) 
   47: {
00069D 8E5A              MOV      buffer,R6
00069F 8F5B              MOV      buffer+01H,R7
0006A1 8C5C              MOV      n,R4
0006A3 8D5D              MOV      n+01H,R5
0006A5 8A5E              MOV      EECurrentAddr,R2
0006A7 8B5F              MOV      EECurrentAddr+01H,R3
   48: 	unsigned char code * EETempAddr = (unsigned char code*)FLASH_FIRST_ADDR;
   49: 	int i = 0;
0006A9 7560A0            MOV      EETempAddr,#0A0H
0006AC 756100            MOV      EETempAddr+01H,#00H
   50: 	int j = 0;
0006AF E4                CLR      A
0006B0 F562              MOV      i,A
0006B2 F563              MOV      i+01H,A
   51: 	int k = 0;
0006B4 F564              MOV      j,A
0006B6 F565              MOV      j+01H,A
   52: 	memset(buffer, 0, n);
0006B8 F566              MOV      k,A
0006BA F567              MOV      k+01H,A
   53: 	
0006BC AE5C              MOV      R6,n
0006BE AF5D              MOV      R7,n+01H
0006C0 FD                MOV      R5,A
0006C1 AA5A              MOV      R2,buffer
0006C3 A95B              MOV      R1,buffer+01H
0006C5 7B01              MOV      R3,#01H
0006C7 31E3              ACALL    ?C?MEMSET
0006C9         ?C0011?FLASHUTILS:
   54: 	while (FLASH_Ready(FLASH_BANK_TO_CHECK) == 0) {;}
0006C9 7F03              MOV      R7,#03H
0006CB F12F              ACALL    _FLASH_Ready
0006CD 50FA              JNC      ?C0011?FLASHUTILS
0006CF         ?C0012?FLASHUTILS:
0006CF         ?C0013?FLASHUTILS:
   55: 	
   56: 	while (EETempAddr < EECurrentAddr && j < n) 
0006CF C3                CLR      C
0006D0 E561              MOV      A,EETempAddr+01H
0006D2 955F              SUBB     A,EECurrentAddr+01H
0006D4 E560              MOV      A,EETempAddr
0006D6 955E              SUBB     A,EECurrentAddr
0006D8 5054              JNC      ?C0017?FLASHUTILS
0006DA C3                CLR      C
0006DB E565              MOV      A,j+01H
0006DD 955D              SUBB     A,n+01H
0006DF E55C              MOV      A,n
0006E1 6480              XRL      A,#080H
0006E3 F8                MOV      R0,A
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:39:27  PAGE 14


0006E4 E564              MOV      A,j
0006E6 6480              XRL      A,#080H
0006E8 98                SUBB     A,R0
0006E9 5043              JNC      ?C0017?FLASHUTILS
   57: 	{	
   58: 		i = 0;
0006EB E4                CLR      A
0006EC F562              MOV      i,A
0006EE F563              MOV      i+01H,A
0006F0         ?C0015?FLASHUTILS:
   59: 		while (*(EETempAddr+i) != 0) {
0006F0 E561              MOV      A,EETempAddr+01H
0006F2 2563              ADD      A,i+01H
0006F4 F582              MOV      DPL,A
0006F6 E560              MOV      A,EETempAddr
0006F8 3562              ADDC     A,i
0006FA F583              MOV      DPH,A
0006FC E4                CLR      A
0006FD 93                MOVC     A,@A+DPTR
0006FE FF                MOV      R7,A
0006FF 6020              JZ       ?C0016?FLASHUTILS
   60: 			buffer[j] = *(EETempAddr+i);
000701 E55B              MOV      A,buffer+01H
000703 2565              ADD      A,j+01H
000705 F582              MOV      DPL,A
000707 E55A              MOV      A,buffer
000709 3564              ADDC     A,j
00070B F583              MOV      DPH,A
00070D EF                MOV      A,R7
00070E F0                MOVX     @DPTR,A
   61: 			i++;
00070F 0563              INC      i+01H
000711 E563              MOV      A,i+01H
000713 7002              JNZ      ?C0025?FLASHUTILS
000715 0562              INC      i
000717         ?C0025?FLASHUTILS:
   62: 			j++;
000717 0565              INC      j+01H
000719 E565              MOV      A,j+01H
00071B 7002              JNZ      ?C0026?FLASHUTILS
00071D 0564              INC      j
00071F         ?C0026?FLASHUTILS:
   63: 		}
00071F 80CF              SJMP     ?C0015?FLASHUTILS
000721         ?C0016?FLASHUTILS:
   64: 		EETempAddr = EETempAddr + BYTES_PER_WORDLINE;		
000721 7420              MOV      A,#020H
000723 2561              ADD      A,EETempAddr+01H
000725 F561              MOV      EETempAddr+01H,A
000727 E4                CLR      A
000728 3560              ADDC     A,EETempAddr
00072A F560              MOV      EETempAddr,A
   65: 	}	
00072C 80A1              SJMP     ?C0013?FLASHUTILS
   66: }
00072E         ?C0017?FLASHUTILS:
00072E 22                RET      
----- FUNCTION _readFlashToBuffer (END) -------


----- FUNCTION _FLASH_Ready (BEGIN) -----
 FILE: 'FlashHandler.c'
   90: bit FLASH_Ready						(unsigned char BankNum)
   91: {
;---- Variable 'BankNum' assigned to Register 'R7' ----
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:39:27  PAGE 15


   92:     ACC = BankNum;
   93: #ifdef __C51__		
00072F EF                MOV      A,R7
   94: 	((void (code *) (void)) FLASH_READ_STATUS) ();
000730 02DFF0            LJMP     0DFF0H
   95: #endif	// __C51__
   96: #ifdef	SDCC
   97: _asm
   98: 	LCALL FLASH_READ_STATUS;
   99: _endasm;
  100: #endif	// SDCC
  101: 	return(CY);
----- FUNCTION _FLASH_Ready (END) -------


----- FUNCTION UART_vInit (BEGIN) -----
 FILE: 'UART.C'
   57: void UART_vInit(void)
   58: {
   59:   ///  -----------------------------------------------------------------------
   60:   ///  UART settings
   61:   ///  -----------------------------------------------------------------------
   62:   ///  Pin TXD_1 (P0.2) is selected for transmission
   63:   ///  Pin RXD_1 (P0.1) is selected for reception
   64:   ///  Receiver enabled
   65:   ///  Mode 1: 8-bit data, 1 start bit, 1 stop bit, variable baud rate
   66:   ///  Receiver interrupt flag RI will only be activated if a valid stop bit 
   67:   ///  was received
   68:   ///  BRG is selected for baudrate generation
   69: 
   70:   SFR_PAGE(_pp2, noSST);         // switch to page 2 without saving
000733 75B202            MOV      PORT_PAGE,#02H
   71:   P0_ALTSEL0   &= ~(ubyte)0x04;  // configure alternate function register 0
000736 5380FB            ANL      P0_ALTSEL0,#0FBH
   72:   P0_ALTSEL1   |=  (ubyte)0x04;  // configure alternate function register 1
000739 438604            ORL      P0_ALTSEL1,#04H
   73:   SFR_PAGE(_pp0, noSST);         // switch to page 0 without saving
00073C E4                CLR      A
00073D F5B2              MOV      PORT_PAGE,A
   74:   P0_DIR       |=  (ubyte)0x04;  // set output direction
00073F 438604            ORL      P0_DIR,#04H
   75: 
   76: 
   77:   MODPISEL     |=  (ubyte)0x01;  // configure peripheral input select register
000742 43B301            ORL      MODPISEL,#01H
   78:   BCON          =  0x00;         // reset baudrate timer/reload register
000745 F5BD              MOV      BCON,A
   79:   SCON          =  0x70;         // load serial channel control register
000747 759870            MOV      SCON,#070H
   80: 
   81:   ///  -----------------------------------------------------------------------
   82:   ///  Baudrate generator settings
   83:   ///  -----------------------------------------------------------------------
   84:   ///  input clock = fPCLK
   85:   ///  Fractional divider is enabled
   86:   ///  baudrate = 9.6004 kbaud
   87: 
   88:   FDSTEP        =  0xD5;         // load fractional divider reload register
00074A 75EAD5            MOV      FDSTEP,#0D5H
   89:   BG            =  0x81;         // load baudrate timer/reload register
00074D 75BE81            MOV      BG,#081H
   90:   FDCON        |=  0x01;         // load Fractional Divider control register
000750 43E901            ORL      FDCON,#01H
   91:   BCON         |=  0x01;         // load baud rate control register
000753 43BD01            ORL      BCON,#01H
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:39:27  PAGE 16


   92: 
   93:   ///  UART interrupt enabled
   94:   ES = 1;
000756 D2AC              SETB     ES
   95: 
   96: } //  End of function UART_vInit
000758 22                RET      
----- FUNCTION UART_vInit (END) -------


----- FUNCTION _delay (BEGIN) -----
 FILE: 'MAIN.C'
   70: void delay(int second) {
   71:   int i, j, k;
;---- Variable 'second' assigned to Register 'R6/R7' ----
   72:   for (i = 0; i < second; i++) {
;---- Variable 'i' assigned to Register 'R4/R5' ----
000759 E4                CLR      A
00075A FD                MOV      R5,A
00075B FC                MOV      R4,A
00075C         ?C0002?MAIN:
00075C C3                CLR      C
00075D ED                MOV      A,R5
00075E 9F                SUBB     A,R7
00075F EE                MOV      A,R6
000760 6480              XRL      A,#080H
000762 F8                MOV      R0,A
000763 EC                MOV      A,R4
000764 6480              XRL      A,#080H
000766 98                SUBB     A,R0
000767 5023              JNC      ?C0011?MAIN
   73:     for (j = 0; j < 25; j++) {
;---- Variable 'j' assigned to Register 'R2/R3' ----
000769 E4                CLR      A
00076A FB                MOV      R3,A
00076B FA                MOV      R2,A
00076C         ?C0005?MAIN:
   74:       for (k = 0; k < 30000; k++) {
;---- Variable 'k' assigned to Register 'DPTR' ----
00076C 900000            MOV      DPTR,#00H
00076F         ?C0008?MAIN:
   75:       }
00076F A3                INC      DPTR
000770 E582              MOV      A,DPL
000772 B430FA            CJNE     A,#030H,?C0008?MAIN
000775 E583              MOV      A,DPH
000777 B475F5            CJNE     A,#075H,?C0008?MAIN
   76:     }
00077A         ?C0007?MAIN:
00077A 0B                INC      R3
00077B BB0001            CJNE     R3,#00H,?C0017?MAIN
00077E 0A                INC      R2
00077F         ?C0017?MAIN:
00077F EB                MOV      A,R3
000780 6419              XRL      A,#019H
000782 4A                ORL      A,R2
000783 70E7              JNZ      ?C0005?MAIN
   77:   }
000785         ?C0004?MAIN:
000785 0D                INC      R5
000786 BD0001            CJNE     R5,#00H,?C0018?MAIN
000789 0C                INC      R4
00078A         ?C0018?MAIN:
00078A 80D0              SJMP     ?C0002?MAIN
   78: }
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:39:27  PAGE 17


00078C         ?C0011?MAIN:
00078C 22                RET      
----- FUNCTION _delay (END) -------


----- FUNCTION _writeToFlashPage (BEGIN) -----
 FILE: 'FlashUtils.c'
   29: void writeToFlashPage(char xdata * buffer, unsigned char code ** EECurrentAddr) {
   30: 	int i = 0;
00078D 8E65              MOV      buffer,R6
00078F 8F66              MOV      buffer+01H,R7
000791 8B67              MOV      EECurrentAddr,R3
000793 8A68              MOV      EECurrentAddr+01H,R2
000795 8969              MOV      EECurrentAddr+02H,R1
   31: 
;---- Variable 'i' assigned to Register 'R6/R7' ----
000797 E4                CLR      A
000798 FF                MOV      R7,A
000799 FE                MOV      R6,A
   32: 	for (i=0; i < BYTES_PER_WORDLINE; i++) {
00079A         ?C0006?FLASHUTILS:
   33: 		WLBuf[i] = *buffer;
00079A 856682            MOV      DPL,buffer+01H
00079D 856583            MOV      DPH,buffer
0007A0 E0                MOVX     A,@DPTR
0007A1 FD                MOV      R5,A
0007A2 74E0              MOV      A,#LOW WLBuf
0007A4 2F                ADD      A,R7
0007A5 F8                MOV      R0,A
0007A6 A605              MOV      @R0,AR5
   34: 		buffer++;
0007A8 0566              INC      buffer+01H
0007AA E566              MOV      A,buffer+01H
0007AC 7002              JNZ      ?C0023?FLASHUTILS
0007AE 0565              INC      buffer
0007B0         ?C0023?FLASHUTILS:
   35: 	}
0007B0 0F                INC      R7
0007B1 BF0001            CJNE     R7,#00H,?C0024?FLASHUTILS
0007B4 0E                INC      R6
0007B5         ?C0024?FLASHUTILS:
0007B5 EF                MOV      A,R7
0007B6 6420              XRL      A,#020H
0007B8 4E                ORL      A,R6
0007B9 70DF              JNZ      ?C0006?FLASHUTILS
0007BB         ?C0007?FLASHUTILS:
   36: 
   37: 	// Start the Flash Programming
   38: 	if (FLASH_Prog(*EECurrentAddr)) 
0007BB AB67              MOV      R3,EECurrentAddr
0007BD AA68              MOV      R2,EECurrentAddr+01H
0007BF A969              MOV      R1,EECurrentAddr+02H
0007C1 3161              ACALL    ?C?ILDPTR
0007C3 FF                MOV      R7,A
0007C4 AEF0              MOV      R6,B
0007C6 F1DC              ACALL    _FLASH_Prog
0007C8 500C              JNC      ?C0009?FLASHUTILS
   39: 	{
   40: 		*EECurrentAddr = *EECurrentAddr + BYTES_PER_WORDLINE;
0007CA AB67              MOV      R3,EECurrentAddr
0007CC AA68              MOV      R2,EECurrentAddr+01H
0007CE A969              MOV      R1,EECurrentAddr+02H
0007D0 E4                CLR      A
0007D1 75F020            MOV      B,#020H
0007D4 318C              ACALL    ?C?IILDPTR
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:39:27  PAGE 18


   41: 	}
0007D6         ?C0009?FLASHUTILS:
   42: 	delay(2);
0007D6 7F02              MOV      R7,#02H
0007D8 7E00              MOV      R6,#00H
0007DA E159              AJMP     _delay
----- FUNCTION _writeToFlashPage (END) -------


----- FUNCTION _FLASH_Prog (BEGIN) -----
 FILE: 'FlashHandler.c'
  113: bit FLASH_Prog					(unsigned char code* WLAddress) 
  114: {
;---- Variable 'WLAddress' assigned to Register 'R6/R7' ----
  115: #ifdef	XC88x
  116: 	volatile bit success;		    // needed for CY flag saving of the BROM routine's result
  117: #endif	// XC88x
  118: #ifdef	XC866
  119: #define USE_BANK  3					// fix the used registerbank to 3 for XC866 devices
  120: #endif	// XC866
  121: 									// For SDCC parameter is now already in DPTR
  122: #ifdef SDCC
  123: 	*WLAddress;						// avoid warning of 'unreferenced function argument
  124: #endif	// SDCC
  125: #ifdef __C51__
  126:    DPTR = (unsigned int)WLAddress;
0007DC 8E83              MOV      DPH,R6
0007DE 8F82              MOV      DPL,R7
  127: #endif	// __C51__
  128: 
  129:    REG[(0+(USE_BANK*8))] = WORDLINE_BUFFER_ADDRESS;
0007E0 7818              MOV      R0,#018H
0007E2 76E0              MOV      @R0,#0E0H
  130: #ifdef	XC88x
  131: 	PUSH(PSW);
0007E4 C0D0              PUSH     PSW
  132: 	PSW = ((USE_BANK)<<3);
0007E6 75D018            MOV      PSW,#018H
  133: #endif	// XC88x
  134: 
  135: #ifdef	__C51__		
  136: 	((void (code *) (void)) FLASH_PROG) ();
0007E9 12DFF6            LCALL    0DFF6H
  137: #endif	// __C51__
  138: #ifdef	SDCC
  139: _asm
  140: 	LCALL FLASH_PROG;
  141: _endasm;
  142: #endif	// SDCC
  143: 
  144: #ifdef	XC88x
  145: 	success = CY;
0007EC 9201              MOV      success,C
  146: 	POP(PSW);
0007EE D0D0              POP      PSW
  147: 	return(!success);			  
0007F0 A201              MOV      C,success
0007F2 B3                CPL      C
  148: #endif	// XC88x
  149: #ifdef	XC866
  150: 	return (!CY);
  151: #endif	// XC866
  152: }
0007F3 22                RET      
----- FUNCTION _FLASH_Prog (END) -------
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:39:27  PAGE 19




----- FUNCTION UART_viIsr (BEGIN) -----
 FILE: 'UART.C'
  178: void UART_viIsr(void) interrupt UARTINT
0007F4 C0E0              PUSH     ACC
0007F6 C0F0              PUSH     B
0007F8 C083              PUSH     DPH
0007FA C082              PUSH     DPL
0007FC C0D0              PUSH     PSW
0007FE 75D000            MOV      PSW,#00H
000801 C000              PUSH     AR0
000803 C001              PUSH     AR1
000805 C002              PUSH     AR2
000807 C003              PUSH     AR3
000809 C004              PUSH     AR4
00080B C005              PUSH     AR5
00080D C006              PUSH     AR6
00080F C007              PUSH     AR7
  179: {
  180: 	// switch to page 0
  181:   SFR_PAGE(_su0, SST0);
000811 75BF80            MOV      SCU_PAGE,#080H
  182:   if (TI)
000814 309902            JNB      TI,?C0020?UART
  183:   {
  184: 		TI = 0;
000817 C299              CLR      TI
  185:   }
000819         ?C0020?UART:
  186:   if (RI)
000819 30984D            JNB      RI,?C0021?UART
  187:   {
  188: 		char receiveByte = SBUF;
00081C 85993E            MOV      receiveByte,SBUF
  189: 		if (receiveByte == '\r' || receiveByte == '\n' || bufferCount >= 18) {
00081F E53E              MOV      A,receiveByte
000821 640D              XRL      A,#0DH
000823 6013              JZ       ?C0023?UART
000825 E53E              MOV      A,receiveByte
000827 640A              XRL      A,#0AH
000829 600D              JZ       ?C0023?UART
00082B C3                CLR      C
00082C E509              MOV      A,bufferCount+01H
00082E 9412              SUBB     A,#012H
000830 E508              MOV      A,bufferCount
000832 6480              XRL      A,#080H
000834 9480              SUBB     A,#080H
000836 4020              JC       ?C0022?UART
000838         ?C0023?UART:
  190: 			processCommand(receiveBuffer);
000838 7B00              MOV      R3,#00H
00083A 7A00              MOV      R2,#HIGH receiveBuffer
00083C 790A              MOV      R1,#LOW receiveBuffer
00083E 120491            LCALL    _processCommand
  191: 			memset(receiveBuffer, 0, 20);			
000841 7E00              MOV      R6,#00H
000843 7F14              MOV      R7,#014H
000845 7D00              MOV      R5,#00H
000847 7B00              MOV      R3,#00H
000849 7A00              MOV      R2,#HIGH receiveBuffer
00084B 790A              MOV      R1,#LOW receiveBuffer
00084D 1201E3            LCALL    ?C?MEMSET
  192: 			bufferCount = 0;
000850 750800            MOV      bufferCount,#00H
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:39:27  PAGE 20


000853 750900            MOV      bufferCount+01H,#00H
  193: 		} else {
000856 800F              SJMP     ?C0024?UART
000858         ?C0022?UART:
  194: 			receiveBuffer[bufferCount] = receiveByte;
000858 740A              MOV      A,#LOW receiveBuffer
00085A 2509              ADD      A,bufferCount+01H
00085C F8                MOV      R0,A
00085D A63E              MOV      @R0,receiveByte
  195: 			bufferCount++;
00085F 0509              INC      bufferCount+01H
000861 E509              MOV      A,bufferCount+01H
000863 7002              JNZ      ?C0028?UART
000865 0508              INC      bufferCount
000867         ?C0028?UART:
  196: 		}
000867         ?C0024?UART:
  197:     RI = 0;
000867 C298              CLR      RI
  198:   }
000869         ?C0021?UART:
  199: 
  200: 	// restore the old page
  201:   SFR_PAGE(_su0, RST0);
000869 75BFC0            MOV      SCU_PAGE,#0C0H
  202: }
00086C D007              POP      AR7
00086E D006              POP      AR6
000870 D005              POP      AR5
000872 D004              POP      AR4
000874 D003              POP      AR3
000876 D002              POP      AR2
000878 D001              POP      AR1
00087A D000              POP      AR0
00087C D0D0              POP      PSW
00087E D082              POP      DPL
000880 D083              POP      DPH
000882 D0F0              POP      B
000884 D0E0              POP      ACC
000886 32                RETI     
----- FUNCTION UART_viIsr (END) -------


----- FUNCTION FLASH_Erase_Abort (BEGIN) -----
 FILE: 'FlashHandler.c'
   75: bit FLASH_Erase_Abort (void)
   76: {
   77: #ifdef __C51__		
   78: 	((void (code *) (void)) FLASH_ERASE_ABORT) ();
000887 12DFF3            LCALL    0DFF3H
   79: #endif	// __C51__
   80: #ifdef	SDCC
   81: _asm
   82: 	LCALL FLASH_ERASE_ABORT;
   83: _endasm;
   84: #endif	// SDCC
   85: 	return (!CY);  
00088A B3                CPL      C
   86: }
00088B 22                RET      
----- FUNCTION FLASH_Erase_Abort (END) -------


----- FUNCTION _FLASH_Erase (BEGIN) -----
 FILE: 'FlashHandler.c'
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:39:27  PAGE 21


  161: bit FLASH_Erase			(unsigned int DFlash0Sector,unsigned int DFlash1Sector)
  162: #endif	// XC88x
;---- Variable 'DFlash1Sector' assigned to Register 'R4/R5' ----
;---- Variable 'DFlash0Sector' assigned to Register 'R6/R7' ----
  163: {
  164: #ifdef	XC88x
  165:     volatile bit success; 
  166: #endif	// XC88x
  167: 	t_unFLPARAM P1;
  168: #ifdef	XC88x
  169: 	t_unFLPARAM P2;
  170: #endif	// XC88x
  171: 
  172: #ifdef	XC866
  173: #define USE_BANK  3								// fix the used registerbank to 3 for XC866 devices
  174: #endif	// XC866
  175: 
  176: 	P1.UINT_Param = DFlash0Sector;
00088C 8E65              MOV      P1,R6
00088E 8F66              MOV      P1+01H,R7
  177: #ifdef	XC88x
  178: 	P2.UINT_Param = DFlash1Sector;
000890 8C67              MOV      P2,R4
000892 8D68              MOV      P2+01H,R5
  179: #endif	// XC88x
  180: 	
  181: #ifdef	XC866
  182: 	REG[(4+(USE_BANK*8))] = P1.UBYTE_Param[0];	// DFLASH0 Sector - BANK3 - High Adr Byte
  183: 	REG[(3+(USE_BANK*8))] = P1.UBYTE_Param[1];	// DFLASH0 Sector - BANK3 - Low  Adr Byte
  184: #endif	// XC866
  185: #ifdef	XC88x
  186: 	REG[(1+(USE_BANK*8))] = P1.UBYTE_Param[0];	// DFLASH0 Sector -         High Adr Byte
000894 7819              MOV      R0,#019H
000896 A665              MOV      @R0,P1
  187: 	REG[(0+(USE_BANK*8))] = P1.UBYTE_Param[1];	// DFLASH0 Sector -         Low  Adr Byte
000898 18                DEC      R0
000899 A666              MOV      @R0,P1+01H
  188: 	REG[(4+(USE_BANK*8))] = P2.UBYTE_Param[0];	// DFLASH1 Sector  
00089B 781C              MOV      R0,#01CH
00089D A667              MOV      @R0,P2
  189: 	REG[(3+(USE_BANK*8))] = P2.UBYTE_Param[1];	// DFLASH1 Sector  
00089F 18                DEC      R0
0008A0 A668              MOV      @R0,P2+01H
  190: #endif	// XC88x
  191: 	REG[(5+(USE_BANK*8))] = 0;					// PFLASH  
0008A2 781D              MOV      R0,#01DH
0008A4 E4                CLR      A
0008A5 F6                MOV      @R0,A
  192: 	REG[(6+(USE_BANK*8))] = 0;					// PFLASH  
0008A6 08                INC      R0
0008A7 F6                MOV      @R0,A
  193: 	REG[(7+(USE_BANK*8))] = 0;					// PFLASH  
0008A8 08                INC      R0
0008A9 F6                MOV      @R0,A
  194: 
  195: #ifdef XC88x
  196: 	PUSH(PSW);
0008AA C0D0              PUSH     PSW
  197: 	PSW = ((USE_BANK)<<3);
0008AC 75D018            MOV      PSW,#018H
  198: #endif	// XC88x
  199: 
  200: #ifdef	__C51__
  201: 	((void (code *) (void)) FLASH_ERASE) ();
0008AF 12DFF9            LCALL    0DFF9H
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:39:27  PAGE 22


  202: #endif	// __C51__
  203: #ifdef	SDCC
  204: _asm
  205: 	LCALL FLASH_ERASE;
  206: _endasm;
  207: #endif	// SDCC
  208: 
  209: #ifdef	XC866
  210: 	return(!CY);
  211: #endif	// XC866
  212: #ifdef	XC88x
  213: 	success = CY;
0008B2 9201              MOV      success,C
  214: 	POP(PSW);
0008B4 D0D0              POP      PSW
  215: 	return (!success);
0008B6 A201              MOV      C,success
0008B8 B3                CPL      C
  216: #endif	// XC88x
  217: }
0008B9 22                RET      
----- FUNCTION _FLASH_Erase (END) -------


----- FUNCTION _writeBufferToFlash (BEGIN) -----
 FILE: 'FlashUtils.c'
   68: void writeBufferToFlash(char * buffer, unsigned char code ** EECurrentAddr) {
   69: 	char xdata pageBuffer[BYTES_PER_WORDLINE] = {0};
0008BA 8B5A              MOV      buffer,R3
0008BC 8A5B              MOV      buffer+01H,R2
0008BE 895C              MOV      buffer+02H,R1
   70: 	char * currentCharacter = buffer;
0008C0 7864              MOV      R0,#LOW pageBuffer
0008C2 7CF0              MOV      R4,#HIGH pageBuffer
0008C4 7D01              MOV      R5,#01H
0008C6 7BFF              MOV      R3,#0FFH
0008C8 7A03              MOV      R2,#HIGH _?ix1000
0008CA 79FE              MOV      R1,#LOW _?ix1000
0008CC 7E00              MOV      R6,#00H
0008CE 7F20              MOV      R7,#020H
0008D0 1200F5            LCALL    ?C?COPY
   71: 	int i = 0;
0008D3 855A60            MOV      currentCharacter,buffer
0008D6 855B61            MOV      currentCharacter+01H,buffer+01H
0008D9 855C62            MOV      currentCharacter+02H,buffer+02H
   72: 	
0008DC E4                CLR      A
0008DD F563              MOV      i,A
0008DF F564              MOV      i+01H,A
   73: 	FLASH_Erase(SECALL,0);
0008E1 FD                MOV      R5,A
0008E2 FC                MOV      R4,A
0008E3 7FFF              MOV      R7,#0FFH
0008E5 7E03              MOV      R6,#03H
0008E7 118C              ACALL    _FLASH_Erase
   74: 	*EECurrentAddr = (unsigned char code*)FLASH_FIRST_ADDR;			// if erase than 1. WL is current
0008E9 AB5D              MOV      R3,EECurrentAddr
0008EB AA5E              MOV      R2,EECurrentAddr+01H
0008ED A95F              MOV      R1,EECurrentAddr+02H
0008EF 74A0              MOV      A,#0A0H
0008F1 75F000            MOV      B,#00H
0008F4 1201C4            LCALL    ?C?ISTPTR
   75:   delay(2);
0008F7 7F02              MOV      R7,#02H
0008F9 7E00              MOV      R6,#00H
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:39:27  PAGE 23


0008FB 120759            LCALL    _delay
   76: 	
   77: 	memset(pageBuffer, 0, BYTES_PER_WORDLINE);
0008FE 7E00              MOV      R6,#00H
000900 7F20              MOV      R7,#020H
000902 7D00              MOV      R5,#00H
000904 7B01              MOV      R3,#01H
000906 7AF0              MOV      R2,#HIGH pageBuffer
000908 7964              MOV      R1,#LOW pageBuffer
00090A 1201E3            LCALL    ?C?MEMSET
00090D         ?C0018?FLASHUTILS:
   78: 	while (*currentCharacter != 0) {
00090D AB60              MOV      R3,currentCharacter
00090F AA61              MOV      R2,currentCharacter+01H
000911 A962              MOV      R1,currentCharacter+02H
000913 12011B            LCALL    ?C?CLDPTR
000916 FF                MOV      R7,A
000917 604E              JZ       ?C0019?FLASHUTILS
   79: 		
   80: 		pageBuffer[i] = *currentCharacter;
000919 7464              MOV      A,#LOW pageBuffer
00091B 2564              ADD      A,i+01H
00091D F582              MOV      DPL,A
00091F 74F0              MOV      A,#HIGH pageBuffer
000921 3563              ADDC     A,i
000923 F583              MOV      DPH,A
000925 EF                MOV      A,R7
000926 F0                MOVX     @DPTR,A
   81: 		if (i == 25) {
000927 E564              MOV      A,i+01H
000929 6419              XRL      A,#019H
00092B 4563              ORL      A,i
00092D 7023              JNZ      ?C0020?FLASHUTILS
   82: 			writeToFlashPage(pageBuffer, EECurrentAddr);
00092F 7EF0              MOV      R6,#HIGH pageBuffer
000931 7F64              MOV      R7,#LOW pageBuffer
000933 AB5D              MOV      R3,EECurrentAddr
000935 AA5E              MOV      R2,EECurrentAddr+01H
000937 A95F              MOV      R1,EECurrentAddr+02H
000939 12078D            LCALL    _writeToFlashPage
   83: 			memset(pageBuffer, 0, BYTES_PER_WORDLINE);
00093C 7E00              MOV      R6,#00H
00093E 7F20              MOV      R7,#020H
000940 7D00              MOV      R5,#00H
000942 7B01              MOV      R3,#01H
000944 7AF0              MOV      R2,#HIGH pageBuffer
000946 7964              MOV      R1,#LOW pageBuffer
000948 1201E3            LCALL    ?C?MEMSET
   84: 			i = 0;
00094B E4                CLR      A
00094C F563              MOV      i,A
00094E F564              MOV      i+01H,A
   85: 		} else {
000950 8008              SJMP     ?C0021?FLASHUTILS
000952         ?C0020?FLASHUTILS:
   86: 			i++;
000952 0564              INC      i+01H
000954 E564              MOV      A,i+01H
000956 7002              JNZ      ?C0027?FLASHUTILS
000958 0563              INC      i
00095A         ?C0027?FLASHUTILS:
   87: 		}
00095A         ?C0021?FLASHUTILS:
   88: 		currentCharacter++;
00095A 7401              MOV      A,#01H
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  10:39:27  PAGE 24


00095C 2562              ADD      A,currentCharacter+02H
00095E F562              MOV      currentCharacter+02H,A
000960 E4                CLR      A
000961 3561              ADDC     A,currentCharacter+01H
000963 F561              MOV      currentCharacter+01H,A
   89: 	}
000965 80A6              SJMP     ?C0018?FLASHUTILS
000967         ?C0019?FLASHUTILS:
   90: 	writeToFlashPage(pageBuffer, EECurrentAddr);	
000967 7EF0              MOV      R6,#HIGH pageBuffer
000969 7F64              MOV      R7,#LOW pageBuffer
00096B AB5D              MOV      R3,EECurrentAddr
00096D AA5E              MOV      R2,EECurrentAddr+01H
00096F A95F              MOV      R1,EECurrentAddr+02H
000971 02078D            LJMP     _writeToFlashPage
----- FUNCTION _writeBufferToFlash (END) -------


