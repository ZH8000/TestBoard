LX51 LINKER/LOCATER V4.66.41.0                                                          04/14/2016  08:49:06  PAGE 1





ASSEMBLER CODE PACKING OF MODULE:  TestBoard (?C_STARTUP)


000023 020BE0            LJMP     0BE0H
----- FUNCTION MAIN_vInit (BEGIN) -----
 FILE: 'MAIN.C'
   30: void MAIN_vInit(void)
   31: {
   32:   ///  -----------------------------------------------------------------------
   33:   ///  Configuration of the System Clock:
   34:   ///  -----------------------------------------------------------------------
   35:   ///  - On Chip Osc is Selected
   36:   ///  - PLL Mode, NDIV =  20
   37:   ///  - input frequency is 9.6 MHz
   38: 
   39:   //   FCLK runs at 2 times the frequency of PCLK.
   40:   SFR_PAGE(_su1, noSST);         // switch to page1
00067F 75BF01            MOV      SCU_PAGE,#01H
   41:   CMCON         =  0x10;         // load Clock Control Register
000682 75BA10            MOV      CMCON,#010H
   42:   SFR_PAGE(_su0, noSST);         // switch to page0
000685 E4                CLR      A
000686 F5BF              MOV      SCU_PAGE,A
   43: 
   44: 
   45:   ///  *********************************************************************************
   46:   ///  Note : All peripheral related IO configurations are done in the 
   47:   ///  respective peripheral modules (alternate functions selection)
   48:   ///  *********************************************************************************
   49: 
   50:   ///  Initialization of module 'GPIO'
   51:   IO_vInit();
000688 D199              ACALL    IO_vInit
   52: 
   53:   ///  Initialization of module 'UART (Serial Interface)'
   54:   UART_vInit();
00068A 1209A0            LCALL    UART_vInit
   55: 
   56:   //   Interrupt Priority
   57: 
   58:   IP            =  0x00;         // load Interrupt Priority Register
00068D E4                CLR      A
00068E F5B8              MOV      IP,A
   59:   IPH           =  0x00;         // load Interrupt Priority High Register
000690 F5B9              MOV      IPH,A
   60:   IP1           =  0x00;         // load Interrupt Priority 1 Register
000692 F5F8              MOV      IP1,A
   61:   IPH1          =  0x00;         // load Interrupt Priority 1 High Register
000694 F5F9              MOV      IPH1,A
   62: 
   63: 
   64:   //// Interrupt structure 2 mode 0 is selected.
   65:   //// Interrupt service routine choice 2 is selected.
   66:   //   globally enable interrupts
   67:   EA            =  1;           
000696 D2AF              SETB     EA
   68: 
   69: } 
000698 22                RET      
----- FUNCTION MAIN_vInit (END) -------


----- FUNCTION IO_vInit (BEGIN) -----
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  08:49:06  PAGE 2


 FILE: 'IO.C'
   49: void IO_vInit(void)
   50: {
   51: 	#ifdef STARTER_KIT_EMU
   52: 		P1_DIR        		= 0x04; 
   53: 		P1_DATA       		= 0x00;
   54: 		P3_DIR			  		= 0xFF;
   55: 		P3_DATA						= 0x00;
   56: 	#else
   57: 
   58: 		///  -----------------------------------------------------------------------
   59: 		///  Configuration of Port P0:
   60: 		///  -----------------------------------------------------------------------
   61: 		///  - no pin of port P0 is used
   62: 
   63: 
   64: 		///  -----------------------------------------------------------------------
   65: 		///  Configuration of Port P1:
   66: 		///  -----------------------------------------------------------------------
   67: 		///  P1.0:
   68: 		///  - is used as general purpose output
   69: 		///  - push/pull output is selected
   70: 		///  - the pin status is low level
   71: 		///  - pull-up device is assigned
   72: 		///  P1.1:
   73: 		///  - is used as general purpose output
   74: 		///  - push/pull output is selected
   75: 		///  - the pin status is low level
   76: 		///  - pull-up device is assigned
   77: 		///  P1.2:
   78: 		///  - is used as general purpose output
   79: 		///  - push/pull output is selected
   80: 		///  - the pin status is low level
   81: 		///  - pull-up device is assigned
   82: 		///  P1.3:
   83: 		///  - is used as general purpose output
   84: 		///  - push/pull output is selected
   85: 		///  - the pin status is low level
   86: 		///  - pull-up device is assigned
   87: 		///  P1.4:
   88: 		///  - is used as general purpose output
   89: 		///  - push/pull output is selected
   90: 		///  - the pin status is low level
   91: 		///  - pull-up device is assigned
   92: 		///  P1.5:
   93: 		///  - is used as general purpose output
   94: 		///  - push/pull output is selected
   95: 		///  - the pin status is low level
   96: 		///  - pull-up device is assigned
   97: 
   98: 
   99: 		P1_DIR        =  0x3F;         // load direction register
000699 75913F            MOV      P1_DIR,#03FH
  100: 
  101: 		///  -----------------------------------------------------------------------
  102: 		///  Configuration of Port P2:
  103: 		///  -----------------------------------------------------------------------
  104: 		///  - no pin of port P2 is used
  105: 
  106: 
  107: 		///  -----------------------------------------------------------------------
  108: 		///  Configuration of Port P3:
  109: 		///  -----------------------------------------------------------------------
  110: 		///  P3.4:
  111: 		///  - is used as general purpose output
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  08:49:06  PAGE 3


  112: 		///  - push/pull output is selected
  113: 		///  - the pin status is low level
  114: 		///  - pull device is disabled (tristate) 
  115: 		///  P3.5:
  116: 		///  - is used as general purpose output
  117: 		///  - push/pull output is selected
  118: 		///  - the pin status is low level
  119: 		///  - pull device is disabled (tristate) 
  120: 		///  P3.6:
  121: 		///  - is used as general purpose output
  122: 		///  - push/pull output is selected
  123: 		///  - the pin status is low level
  124: 		///  - pull device is disabled (tristate) 
  125: 		///  P3.7:
  126: 		///  - is used as general purpose output
  127: 		///  - push/pull output is selected
  128: 		///  - the pin status is low level
  129: 		///  - pull device is disabled (tristate) 
  130: 
  131: 
  132: 		P3_DIR        =  0xF0;         // load direction register
00069C 75B1F0            MOV      P3_DIR,#0F0H
  133: 
  134: 		///  -----------------------------------------------------------------------
  135: 		///  Configuration of Port P4:
  136: 		///  -----------------------------------------------------------------------
  137: 		///  P4.0:
  138: 		///  - is used as general input
  139: 		///  - pull device is disabled (tristate) 
  140: 		///  P4.1:
  141: 		///  - is used as general input
  142: 		///  - pull device is disabled (tristate) 
  143: 		///  P4.2:
  144: 		///  - is used as general input
  145: 		///  - pull-up device is assigned
  146: 		///  P4.3:
  147: 		///  - is used as general input
  148: 		///  - pull device is disabled (tristate) 
  149: 		///  P4.4:
  150: 		///  - is used as general input
  151: 		///  - pull device is disabled (tristate) 
  152: 		///  P4.5:
  153: 		///  - is used as general input
  154: 		///  - pull device is disabled (tristate) 
  155: 
  156: 
  157: 		///  -----------------------------------------------------------------------
  158: 		///  Configuration of Port P5:
  159: 		///  -----------------------------------------------------------------------
  160: 		///  - no pin of port P5 is used
  161: 	#endif
  162: 
  163: } //  End of function IO_vInit
00069F 22                RET      
----- FUNCTION IO_vInit (END) -------


----- FUNCTION main (BEGIN) -----
 FILE: 'MAIN.C'
   79: void main(void)
   80: {
   81:   MAIN_vInit();
   82: 	
0006A0 D17F              ACALL    MAIN_vInit
0006A2         ?C0012?MAIN:
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  08:49:06  PAGE 4


   83:   while(1) {
   84: 		
   85: 		if (shouldMonitorHVStatus && !isAllHVRelayOK()) {
0006A2 30030C            JNB      shouldMonitorHVStatus,?C0014?MAIN
0006A5 F1DD              ACALL    isAllHVRelayOK
0006A7 4008              JC       ?C0014?MAIN
   86: 			sendUART("HV_NG\r\n");
0006A9 7BFF              MOV      R3,#0FFH
0006AB 7A00              MOV      R2,#HIGH 01000018H
0006AD 7918              MOV      R1,#LOW 01000018H
0006AF D1C2              ACALL    _sendUART
   87: 		}
0006B1         ?C0014?MAIN:
   88: 			
   89: 		delay(1);
0006B1 7F01              MOV      R7,#01H
0006B3 7E00              MOV      R6,#00H
0006B5 12081E            LCALL    _delay
   90: 	}
0006B8 80E8              SJMP     ?C0012?MAIN
----- FUNCTION main (END) -------


----- FUNCTION ?L?COM0001 (BEGIN) -----
0006BA D1C2              ACALL    _sendUART
0006BC 7B01              MOV      R3,#01H
0006BE 7AF0              MOV      R2,#HIGH uuidString
0006C0 79C8              MOV      R1,#LOW uuidString
----- FUNCTION _sendUART (BEGIN) -----
 FILE: 'UART.C'
  133: void sendUART(char * message) {
  134: 	char * current = message;
;---- Variable 'message' assigned to Register 'R1/R2/R3' ----
  135: 	while (*current != '\0') {
;---- Variable 'current' assigned to Register 'R1/R2/R3' ----
0006C2         ?C0002?UART:
  136: 		SBUF = *current;
0006C2 311C              ACALL    ?C?CLDPTR
0006C4 6010              JZ       ?C0006?UART
  137: 		while (TI == 0);
0006C6 F599              MOV      SBUF,A
0006C8         ?C0004?UART:
  138: 		TI = 0;		
0006C8 3099FD            JNB      TI,?C0004?UART
0006CB         ?C0005?UART:
  139: 		current++;
0006CB C299              CLR      TI
  140: 	}
0006CD 7401              MOV      A,#01H
0006CF 29                ADD      A,R1
0006D0 F9                MOV      R1,A
0006D1 E4                CLR      A
0006D2 3A                ADDC     A,R2
0006D3 FA                MOV      R2,A
  141: }
0006D4 80EC              SJMP     ?C0002?UART
  142: 
0006D6         ?C0006?UART:
0006D6 22                RET      
----- FUNCTION _sendUART (END) -------


----- FUNCTION sendHVRelayStatus (BEGIN) -----
 FILE: 'DeviceController.c'
   95: void sendHVRelayStatus() {
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  08:49:06  PAGE 5


   96: 	if (IO_ubReadPin(HV_READY_1)) {
   97: 		sendUART("HV_READY_1: OK\n");
0006D7 7BFF              MOV      R3,#0FFH
0006D9 30C806            JNB      P4_0,?C0019?DEVICECONTROLLER
   98: 	} else {
0006DC 7A02              MOV      R2,#HIGH 010002B6H
0006DE 79B6              MOV      R1,#LOW 010002B6H
   99: 		sendUART("HV_READY_1: NG\n");
0006E0 8004              SJMP     ?C0056?DEVICECONTROLLER
0006E2         ?C0019?DEVICECONTROLLER:
  100: 	}
0006E2 7A02              MOV      R2,#HIGH 010002C6H
0006E4 79C6              MOV      R1,#LOW 010002C6H
0006E6         
0006E6 D1C2              ACALL    _sendUART
  101: 	
0006E8         ?C0020?DEVICECONTROLLER:
  102: 	if (IO_ubReadPin(HV_READY_2)) {
0006E8 7BFF              MOV      R3,#0FFH
0006EA 30CA06            JNB      P4_2,?C0021?DEVICECONTROLLER
  103: 		sendUART("HV_READY_2: OK\n");
0006ED 7A02              MOV      R2,#HIGH 010002D6H
0006EF 79D6              MOV      R1,#LOW 010002D6H
  104: 	} else {
0006F1 8004              SJMP     ?C0057?DEVICECONTROLLER
0006F3         ?C0021?DEVICECONTROLLER:
  105: 		sendUART("HV_READY_2: NG\n");
0006F3 7A02              MOV      R2,#HIGH 010002E6H
0006F5 79E6              MOV      R1,#LOW 010002E6H
0006F7         
0006F7 D1C2              ACALL    _sendUART
  106: 	}
0006F9         ?C0022?DEVICECONTROLLER:
  107: 
  108: 	if (IO_ubReadPin(HV_READY_3)) {
0006F9 7BFF              MOV      R3,#0FFH
0006FB 30CC06            JNB      P4_4,?C0023?DEVICECONTROLLER
  109: 		sendUART("HV_READY_3: OK\n");
0006FE 7A02              MOV      R2,#HIGH 010002F6H
000700 79F6              MOV      R1,#LOW 010002F6H
  110: 	} else {
000702 8004              SJMP     ?C0058?DEVICECONTROLLER
000704         ?C0023?DEVICECONTROLLER:
  111: 		sendUART("HV_READY_3: NG\n");
000704 7A03              MOV      R2,#HIGH 01000306H
000706 7906              MOV      R1,#LOW 01000306H
000708         
000708 D1C2              ACALL    _sendUART
  112: 	}
00070A         ?C0024?DEVICECONTROLLER:
  113: 	
  114: 	if (IO_ubReadPin(HV_FAULT_1)) {
00070A 7BFF              MOV      R3,#0FFH
00070C 30C906            JNB      P4_1,?C0025?DEVICECONTROLLER
  115: 		sendUART("HV_FAULT_1: OK\n");
00070F 7A03              MOV      R2,#HIGH 01000316H
000711 7916              MOV      R1,#LOW 01000316H
  116: 	} else {
000713 8004              SJMP     ?C0059?DEVICECONTROLLER
000715         ?C0025?DEVICECONTROLLER:
  117: 		sendUART("HV_FAULT_1: NG\n");
000715 7A03              MOV      R2,#HIGH 01000326H
000717 7926              MOV      R1,#LOW 01000326H
000719         
000719 D1C2              ACALL    _sendUART
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  08:49:06  PAGE 6


  118: 	}
00071B         ?C0026?DEVICECONTROLLER:
  119: 
  120: 	if (IO_ubReadPin(HV_FAULT_2)) {
00071B 7BFF              MOV      R3,#0FFH
00071D 30CB06            JNB      P4_3,?C0027?DEVICECONTROLLER
  121: 		sendUART("HV_FAULT_2: OK\n");
000720 7A03              MOV      R2,#HIGH 01000336H
000722 7936              MOV      R1,#LOW 01000336H
  122: 	} else {
000724 8004              SJMP     ?C0060?DEVICECONTROLLER
000726         ?C0027?DEVICECONTROLLER:
  123: 		sendUART("HV_FAULT_2: NG\n");
000726 7A03              MOV      R2,#HIGH 01000346H
000728 7946              MOV      R1,#LOW 01000346H
00072A         
00072A D1C2              ACALL    _sendUART
  124: 	}
00072C         ?C0028?DEVICECONTROLLER:
  125: 	
  126: 	if (IO_ubReadPin(HV_FAULT_3)) {
00072C 7BFF              MOV      R3,#0FFH
00072E 30CD06            JNB      P4_5,?C0029?DEVICECONTROLLER
  127: 		sendUART("HV_FAULT_3: OK\n");
000731 7A03              MOV      R2,#HIGH 01000356H
000733 7956              MOV      R1,#LOW 01000356H
  128: 	} else {
000735 8004              SJMP     ?C0061?DEVICECONTROLLER
000737         ?C0029?DEVICECONTROLLER:
  129: 		sendUART("HV_FAULT_3: NG\n");
000737 7A03              MOV      R2,#HIGH 01000366H
000739 7966              MOV      R1,#LOW 01000366H
00073B         
00073B D1C2              ACALL    _sendUART
  130: 	}
00073D         ?C0030?DEVICECONTROLLER:
  131: 	
  132: 	
  133: 	if (isAllHVRelayOK()) {
00073D F1DD              ACALL    isAllHVRelayOK
00073F 7BFF              MOV      R3,#0FFH
000741 5006              JNC      ?C0031?DEVICECONTROLLER
  134: 		sendUART("#d#1#\n");
000743 7A03              MOV      R2,#HIGH 01000376H
000745 7976              MOV      R1,#LOW 01000376H
  135: 	} else {
000747 8004              SJMP     ?C0062?DEVICECONTROLLER
000749         ?C0031?DEVICECONTROLLER:
  136: 		sendUART("#d#0#\n");		
000749 7A03              MOV      R2,#HIGH 0100037DH
00074B 797D              MOV      R1,#LOW 0100037DH
00074D         
00074D C1C2              AJMP     _sendUART
  137: 	}
----- FUNCTION sendHVRelayStatus (END) -------


----- FUNCTION _setUUID (BEGIN) -----
 FILE: 'DeviceController.c'
  181: void setUUID(char * command) {
  182: 	unsigned char code * flashEndAddress = getFlashDataEndAddress();	
00074F 8B44              MOV      command,R3
000751 8A45              MOV      command+01H,R2
000753 8946              MOV      command+02H,R1
  183: 	char xdata uuidString[37] = {0};
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  08:49:06  PAGE 7


000755 F1F4              ACALL    getFlashDataEndAddress
000757 8E47              MOV      flashEndAddress,R6
000759 8F48              MOV      flashEndAddress+01H,R7
  184: 	strncpy(uuidString, command+3, 36);
00075B 78C8              MOV      R0,#LOW uuidString
00075D 7CF0              MOV      R4,#HIGH uuidString
00075F 7D01              MOV      R5,#01H
000761 7BFF              MOV      R3,#0FFH
000763 7A04              MOV      R2,#HIGH _?ix1000
000765 7905              MOV      R1,#LOW _?ix1000
000767 7E00              MOV      R6,#00H
000769 7F25              MOV      R7,#025H
00076B 11F6              ACALL    ?C?COPY
  185: 	sendUART("Setting UUID to ");
00076D E546              MOV      A,command+02H
00076F 2403              ADD      A,#03H
000771 F9                MOV      R1,A
000772 E4                CLR      A
000773 3545              ADDC     A,command+01H
000775 85444C            MOV      ?_strncpy?BYTE+03H,command
000778 F54D              MOV      ?_strncpy?BYTE+04H,A
00077A 894E              MOV      ?_strncpy?BYTE+05H,R1
00077C 754F00            MOV      ?_strncpy?BYTE+06H,#00H
00077F 755024            MOV      ?_strncpy?BYTE+07H,#024H
000782 7B01              MOV      R3,#01H
000784 7AF0              MOV      R2,#HIGH uuidString
000786 79C8              MOV      R1,#LOW uuidString
000788 D10D              ACALL    _strncpy
  186: 	sendUART(uuidString);
00078A 7BFF              MOV      R3,#0FFH
00078C 7A03              MOV      R2,#HIGH 010003D9H
00078E 79D9              MOV      R1,#LOW 010003D9H
000790 D1BA              ACALL    ?L?COM0001
  187: 	sendUART("....\n");
000792 7BFF              MOV      R3,#0FFH
000794 7A03              MOV      R2,#HIGH 010003EAH
000796 79EA              MOV      R1,#LOW 010003EAH
000798 D1C2              ACALL    _sendUART
  188: 	sendUART("Please wait...");
00079A 7BFF              MOV      R3,#0FFH
00079C 7A03              MOV      R2,#HIGH 010003F0H
00079E 79F0              MOV      R1,#LOW 010003F0H
0007A0 D1C2              ACALL    _sendUART
  189: 	writeBufferToFlash(uuidString, &flashEndAddress);
0007A2 754C00            MOV      ?_writeBufferToFlash?BYTE+03H,#00H
0007A5 754D00            MOV      ?_writeBufferToFlash?BYTE+04H,#HIGH flashEndAddress
0007A8 754E47            MOV      ?_writeBufferToFlash?BYTE+05H,#LOW flashEndAddress
0007AB 7B01              MOV      R3,#01H
0007AD 7AF0              MOV      R2,#HIGH uuidString
0007AF 79C8              MOV      R1,#LOW uuidString
0007B1 1208A3            LCALL    _writeBufferToFlash
  190: 	sendUART("DONE\n");
0007B4 7BFF              MOV      R3,#0FFH
0007B6 7A03              MOV      R2,#HIGH 010003FFH
0007B8 79FF              MOV      R1,#LOW 010003FFH
0007BA C1C2              AJMP     _sendUART
----- FUNCTION _setUUID (END) -------


----- FUNCTION sendUUID (BEGIN) -----
 FILE: 'DeviceController.c'
    8: void sendUUID() {
    9: 	char xdata uuidString[50];
   10: 	unsigned char code * currentFlashDataEndAddress = getFlashDataEndAddress();
0007BC F1F4              ACALL    getFlashDataEndAddress
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  08:49:06  PAGE 8


;---- Variable 'currentFlashDataEndAddress' assigned to Register 'R2/R3' ----
0007BE AB07              MOV      R3,AR7
0007C0 AA06              MOV      R2,AR6
   11: 	readFlashToBuffer(uuidString, 50, currentFlashDataEndAddress);
0007C2 7EF0              MOV      R6,#HIGH uuidString
0007C4 7FC8              MOV      R7,#LOW uuidString
0007C6 7D32              MOV      R5,#032H
0007C8 7C00              MOV      R4,#00H
0007CA 120C7E            LCALL    _readFlashToBuffer
   12: 	sendUART("#f#");
0007CD 7BFF              MOV      R3,#0FFH
0007CF 7A02              MOV      R2,#HIGH 01000248H
0007D1 7948              MOV      R1,#LOW 01000248H
0007D3 D1BA              ACALL    ?L?COM0001
   13: 	sendUART(uuidString);
   14: 	sendUART("#\n");
0007D5 7BFF              MOV      R3,#0FFH
0007D7 7A02              MOV      R2,#HIGH 0100024CH
0007D9 794C              MOV      R1,#LOW 0100024CH
0007DB C1C2              AJMP     _sendUART
----- FUNCTION sendUUID (END) -------


----- FUNCTION isAllHVRelayOK (BEGIN) -----
 FILE: 'DeviceController.c'
   81: bool isAllHVRelayOK() {
   82: 	#ifdef STARTER_KIT_EMU
   83: 		return IO_ubReadPin(HV_READY_1);
   84: 	#else
   85: 		return 
0007DD 30C812            JNB      P4_0,?C0016?DEVICECONTROLLER
0007E0 30CA0F            JNB      P4_2,?C0016?DEVICECONTROLLER
0007E3 30CC0C            JNB      P4_4,?C0016?DEVICECONTROLLER
0007E6 30C909            JNB      P4_1,?C0016?DEVICECONTROLLER
0007E9 30CB06            JNB      P4_3,?C0016?DEVICECONTROLLER
0007EC 30CD03            JNB      P4_5,?C0016?DEVICECONTROLLER
0007EF D3                SETB     C
0007F0 8001              SJMP     ?C0017?DEVICECONTROLLER
0007F2         ?C0016?DEVICECONTROLLER:
0007F2 C3                CLR      C
0007F3         ?C0017?DEVICECONTROLLER:
   86: 			IO_ubReadPin(HV_READY_1) &&
   87: 			IO_ubReadPin(HV_READY_2) &&
   88: 			IO_ubReadPin(HV_READY_3) &&
   89: 			IO_ubReadPin(HV_FAULT_1) &&
   90: 			IO_ubReadPin(HV_FAULT_2) &&
   91: 			IO_ubReadPin(HV_FAULT_3);
   92: 	#endif
   93: }
0007F3 22                RET      
----- FUNCTION isAllHVRelayOK (END) -------


----- FUNCTION getFlashDataEndAddress (BEGIN) -----
 FILE: 'FlashUtils.c'
   12: unsigned char code * getFlashDataEndAddress() {
   13:   // Initialize the pointer to the FLASH (Checking if there is a valid data)
   14:   unsigned char code * EECurrentAddr = (unsigned char code*)FLASH_LAST_ADDR;
;---- Variable 'EECurrentAddr' assigned to Register 'R6/R7' ----
0007F4 7F00              MOV      R7,#00H
0007F6 7EAC              MOV      R6,#0ACH
   15:   unsigned char code * EETempAddr;
   16:           
   17:   for (EETempAddr = (unsigned char code*)FLASH_FIRST_ADDR; EETempAddr <= (unsigned char code*)FLASH_LAST_ADDR; EE
>> TempAddr += BYTES_PER_WORDLINE)
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  08:49:06  PAGE 9


;---- Variable 'EETempAddr' assigned to Register 'DPTR' ----
0007F8 90A000            MOV      DPTR,#0A000H
0007FB         ?C0001?FLASHUTILS:
0007FB D3                SETB     C
0007FC E582              MOV      A,DPL
0007FE 9400              SUBB     A,#00H
000800 E583              MOV      A,DPH
000802 94AC              SUBB     A,#0ACH
000804 5017              JNC      ?C0002?FLASHUTILS
   18: 	{
   19: 		if (*EETempAddr == 0)
000806 E4                CLR      A
000807 93                MOVC     A,@A+DPTR
000808 7006              JNZ      ?C0003?FLASHUTILS
   20: 		{
   21: 			EECurrentAddr = EETempAddr;
00080A AE83              MOV      R6,DPH
00080C AF82              MOV      R7,DPL
   22: 			break;
00080E 800D              SJMP     ?C0002?FLASHUTILS
   23: 		}
   24: 	}
000810         ?C0003?FLASHUTILS:
000810 7420              MOV      A,#020H
000812 2582              ADD      A,DPL
000814 F582              MOV      DPL,A
000816 E4                CLR      A
000817 3583              ADDC     A,DPH
000819 F583              MOV      DPH,A
00081B 80DE              SJMP     ?C0001?FLASHUTILS
00081D         ?C0002?FLASHUTILS:
   25: 	return EECurrentAddr;
   26: }
00081D 22                RET      
----- FUNCTION getFlashDataEndAddress (END) -------


----- FUNCTION _delay (BEGIN) -----
 FILE: 'MAIN.C'
   70: void delay(int second) {
   71:   int i, j, k;
;---- Variable 'second' assigned to Register 'R6/R7' ----
   72:   for (i = 0; i < second; i++) {
;---- Variable 'i' assigned to Register 'R4/R5' ----
00081E E4                CLR      A
00081F FD                MOV      R5,A
000820 FC                MOV      R4,A
000821         ?C0002?MAIN:
000821 C3                CLR      C
000822 ED                MOV      A,R5
000823 9F                SUBB     A,R7
000824 EE                MOV      A,R6
000825 6480              XRL      A,#080H
000827 F8                MOV      R0,A
000828 EC                MOV      A,R4
000829 6480              XRL      A,#080H
00082B 98                SUBB     A,R0
00082C 5023              JNC      ?C0011?MAIN
   73:     for (j = 0; j < 25; j++) {
;---- Variable 'j' assigned to Register 'R2/R3' ----
00082E E4                CLR      A
00082F FB                MOV      R3,A
000830 FA                MOV      R2,A
000831         ?C0005?MAIN:
   74:       for (k = 0; k < 30000; k++) {
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  08:49:06  PAGE 10


;---- Variable 'k' assigned to Register 'DPTR' ----
000831 900000            MOV      DPTR,#00H
000834         ?C0008?MAIN:
   75:       }
000834 A3                INC      DPTR
000835 E582              MOV      A,DPL
000837 B430FA            CJNE     A,#030H,?C0008?MAIN
00083A E583              MOV      A,DPH
00083C B475F5            CJNE     A,#075H,?C0008?MAIN
   76:     }
00083F         ?C0007?MAIN:
00083F 0B                INC      R3
000840 BB0001            CJNE     R3,#00H,?C0017?MAIN
000843 0A                INC      R2
000844         ?C0017?MAIN:
000844 EB                MOV      A,R3
000845 6419              XRL      A,#019H
000847 4A                ORL      A,R2
000848 70E7              JNZ      ?C0005?MAIN
   77:   }
00084A         ?C0004?MAIN:
00084A 0D                INC      R5
00084B BD0001            CJNE     R5,#00H,?C0018?MAIN
00084E 0C                INC      R4
00084F         ?C0018?MAIN:
00084F 80D0              SJMP     ?C0002?MAIN
   78: }
000851         ?C0011?MAIN:
000851 22                RET      
----- FUNCTION _delay (END) -------


----- FUNCTION _writeToFlashPage (BEGIN) -----
 FILE: 'FlashUtils.c'
   29: void writeToFlashPage(char xdata * buffer, unsigned char code ** EECurrentAddr) {
   30: 	int i = 0;
000852 8E54              MOV      buffer,R6
000854 8F55              MOV      buffer+01H,R7
000856 8B56              MOV      EECurrentAddr,R3
000858 8A57              MOV      EECurrentAddr+01H,R2
00085A 8958              MOV      EECurrentAddr+02H,R1
   31: 
;---- Variable 'i' assigned to Register 'R6/R7' ----
00085C E4                CLR      A
00085D FF                MOV      R7,A
00085E FE                MOV      R6,A
   32: 	for (i=0; i < BYTES_PER_WORDLINE; i++) {
00085F         ?C0006?FLASHUTILS:
   33: 		WLBuf[i] = *buffer;
00085F 855582            MOV      DPL,buffer+01H
000862 855483            MOV      DPH,buffer
000865 E0                MOVX     A,@DPTR
000866 FD                MOV      R5,A
000867 74E0              MOV      A,#LOW WLBuf
000869 2F                ADD      A,R7
00086A F8                MOV      R0,A
00086B A605              MOV      @R0,AR5
   34: 		buffer++;
00086D 0555              INC      buffer+01H
00086F E555              MOV      A,buffer+01H
000871 7002              JNZ      ?C0023?FLASHUTILS
000873 0554              INC      buffer
000875         ?C0023?FLASHUTILS:
   35: 	}
000875 0F                INC      R7
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  08:49:06  PAGE 11


000876 BF0001            CJNE     R7,#00H,?C0024?FLASHUTILS
000879 0E                INC      R6
00087A         ?C0024?FLASHUTILS:
00087A EF                MOV      A,R7
00087B 6420              XRL      A,#020H
00087D 4E                ORL      A,R6
00087E 70DF              JNZ      ?C0006?FLASHUTILS
000880         ?C0007?FLASHUTILS:
   36: 
   37: 	// Start the Flash Programming
   38: 	if (FLASH_Prog(*EECurrentAddr)) 
000880 AB56              MOV      R3,EECurrentAddr
000882 AA57              MOV      R2,EECurrentAddr+01H
000884 A958              MOV      R1,EECurrentAddr+02H
000886 120162            LCALL    ?C?ILDPTR
000889 FF                MOV      R7,A
00088A AEF0              MOV      R6,B
00088C 315A              ACALL    _FLASH_Prog
00088E 500D              JNC      ?C0009?FLASHUTILS
   39: 	{
   40: 		*EECurrentAddr = *EECurrentAddr + BYTES_PER_WORDLINE;
000890 AB56              MOV      R3,EECurrentAddr
000892 AA57              MOV      R2,EECurrentAddr+01H
000894 A958              MOV      R1,EECurrentAddr+02H
000896 E4                CLR      A
000897 75F020            MOV      B,#020H
00089A 12018D            LCALL    ?C?IILDPTR
   41: 	}
00089D         ?C0009?FLASHUTILS:
   42: 	delay(2);
00089D 7F02              MOV      R7,#02H
00089F 7E00              MOV      R6,#00H
0008A1 011E              AJMP     _delay
----- FUNCTION _writeToFlashPage (END) -------


----- FUNCTION _writeBufferToFlash (BEGIN) -----
 FILE: 'FlashUtils.c'
   68: void writeBufferToFlash(char * buffer, unsigned char code ** EECurrentAddr) {
   69: 	char xdata pageBuffer[BYTES_PER_WORDLINE] = {0};
0008A3 8B49              MOV      buffer,R3
0008A5 8A4A              MOV      buffer+01H,R2
0008A7 894B              MOV      buffer+02H,R1
   70: 	char * currentCharacter = buffer;
0008A9 78ED              MOV      R0,#LOW pageBuffer
0008AB 7CF0              MOV      R4,#HIGH pageBuffer
0008AD 7D01              MOV      R5,#01H
0008AF 7BFF              MOV      R3,#0FFH
0008B1 7A06              MOV      R2,#HIGH _?ix1000
0008B3 795F              MOV      R1,#LOW _?ix1000
0008B5 7E00              MOV      R6,#00H
0008B7 7F20              MOV      R7,#020H
0008B9 1200F6            LCALL    ?C?COPY
   71: 	int i = 0;
0008BC 85494F            MOV      currentCharacter,buffer
0008BF 854A50            MOV      currentCharacter+01H,buffer+01H
0008C2 854B51            MOV      currentCharacter+02H,buffer+02H
   72: 	
0008C5 E4                CLR      A
0008C6 F552              MOV      i,A
0008C8 F553              MOV      i+01H,A
   73: 	FLASH_Erase(SECALL,0);
0008CA FD                MOV      R5,A
0008CB FC                MOV      R4,A
0008CC 7FFF              MOV      R7,#0FFH
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  08:49:06  PAGE 12


0008CE 7E03              MOV      R6,#03H
0008D0 3172              ACALL    _FLASH_Erase
   74: 	*EECurrentAddr = (unsigned char code*)FLASH_FIRST_ADDR;			// if erase than 1. WL is current
0008D2 AB4C              MOV      R3,EECurrentAddr
0008D4 AA4D              MOV      R2,EECurrentAddr+01H
0008D6 A94E              MOV      R1,EECurrentAddr+02H
0008D8 74A0              MOV      A,#0A0H
0008DA 75F000            MOV      B,#00H
0008DD 1201C5            LCALL    ?C?ISTPTR
   75:   delay(2);
0008E0 7F02              MOV      R7,#02H
0008E2 7E00              MOV      R6,#00H
0008E4 111E              ACALL    _delay
   76: 	
   77: 	memset(pageBuffer, 0, BYTES_PER_WORDLINE);
0008E6 7E00              MOV      R6,#00H
0008E8 7F20              MOV      R7,#020H
0008EA 7D00              MOV      R5,#00H
0008EC 7B01              MOV      R3,#01H
0008EE 7AF0              MOV      R2,#HIGH pageBuffer
0008F0 79ED              MOV      R1,#LOW pageBuffer
0008F2 1201E4            LCALL    ?C?MEMSET
0008F5         ?C0018?FLASHUTILS:
   78: 	while (*currentCharacter != 0) {
0008F5 AB4F              MOV      R3,currentCharacter
0008F7 AA50              MOV      R2,currentCharacter+01H
0008F9 A951              MOV      R1,currentCharacter+02H
0008FB 12011C            LCALL    ?C?CLDPTR
0008FE FF                MOV      R7,A
0008FF 604D              JZ       ?C0019?FLASHUTILS
   79: 		
   80: 		pageBuffer[i] = *currentCharacter;
000901 74ED              MOV      A,#LOW pageBuffer
000903 2553              ADD      A,i+01H
000905 F582              MOV      DPL,A
000907 74F0              MOV      A,#HIGH pageBuffer
000909 3552              ADDC     A,i
00090B F583              MOV      DPH,A
00090D EF                MOV      A,R7
00090E F0                MOVX     @DPTR,A
   81: 		if (i == 25) {
00090F E553              MOV      A,i+01H
000911 6419              XRL      A,#019H
000913 4552              ORL      A,i
000915 7022              JNZ      ?C0020?FLASHUTILS
   82: 			writeToFlashPage(pageBuffer, EECurrentAddr);
000917 7EF0              MOV      R6,#HIGH pageBuffer
000919 7FED              MOV      R7,#LOW pageBuffer
00091B AB4C              MOV      R3,EECurrentAddr
00091D AA4D              MOV      R2,EECurrentAddr+01H
00091F A94E              MOV      R1,EECurrentAddr+02H
000921 1152              ACALL    _writeToFlashPage
   83: 			memset(pageBuffer, 0, BYTES_PER_WORDLINE);
000923 7E00              MOV      R6,#00H
000925 7F20              MOV      R7,#020H
000927 7D00              MOV      R5,#00H
000929 7B01              MOV      R3,#01H
00092B 7AF0              MOV      R2,#HIGH pageBuffer
00092D 79ED              MOV      R1,#LOW pageBuffer
00092F 1201E4            LCALL    ?C?MEMSET
   84: 			i = 0;
000932 E4                CLR      A
000933 F552              MOV      i,A
000935 F553              MOV      i+01H,A
   85: 		} else {
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  08:49:06  PAGE 13


000937 8008              SJMP     ?C0021?FLASHUTILS
000939         ?C0020?FLASHUTILS:
   86: 			i++;
000939 0553              INC      i+01H
00093B E553              MOV      A,i+01H
00093D 7002              JNZ      ?C0027?FLASHUTILS
00093F 0552              INC      i
000941         ?C0027?FLASHUTILS:
   87: 		}
000941         ?C0021?FLASHUTILS:
   88: 		currentCharacter++;
000941 7401              MOV      A,#01H
000943 2551              ADD      A,currentCharacter+02H
000945 F551              MOV      currentCharacter+02H,A
000947 E4                CLR      A
000948 3550              ADDC     A,currentCharacter+01H
00094A F550              MOV      currentCharacter+01H,A
   89: 	}
00094C 80A7              SJMP     ?C0018?FLASHUTILS
00094E         ?C0019?FLASHUTILS:
   90: 	writeToFlashPage(pageBuffer, EECurrentAddr);	
00094E 7EF0              MOV      R6,#HIGH pageBuffer
000950 7FED              MOV      R7,#LOW pageBuffer
000952 AB4C              MOV      R3,EECurrentAddr
000954 AA4D              MOV      R2,EECurrentAddr+01H
000956 A94E              MOV      R1,EECurrentAddr+02H
000958 0152              AJMP     _writeToFlashPage
----- FUNCTION _writeBufferToFlash (END) -------


----- FUNCTION _FLASH_Prog (BEGIN) -----
 FILE: 'FlashHandler.c'
  115: bit FLASH_Prog					(unsigned char code* WLAddress) 
  116: {
;---- Variable 'WLAddress' assigned to Register 'R6/R7' ----
  117: #ifdef	XC88x
  118: 	volatile bit success;		    // needed for CY flag saving of the BROM routine's result
  119: #endif	// XC88x
  120: #ifdef	XC866
  121: #define USE_BANK  3					// fix the used registerbank to 3 for XC866 devices
  122: #endif	// XC866
  123: 									// For SDCC parameter is now already in DPTR
  124: #ifdef SDCC
  125: 	*WLAddress;						// avoid warning of 'unreferenced function argument
  126: #endif	// SDCC
  127: #ifdef __C51__
  128:    DPTR = (unsigned int)WLAddress;
00095A 8E83              MOV      DPH,R6
00095C 8F82              MOV      DPL,R7
  129: #endif	// __C51__
  130: 
  131:    REG[(0+(USE_BANK*8))] = WORDLINE_BUFFER_ADDRESS;
00095E 7818              MOV      R0,#018H
000960 76E0              MOV      @R0,#0E0H
  132: #ifdef	XC88x
  133: 	PUSH(PSW);
000962 C0D0              PUSH     PSW
  134: 	PSW = ((USE_BANK)<<3);
000964 75D018            MOV      PSW,#018H
  135: #endif	// XC88x
  136: 
  137: #ifdef	__C51__		
  138: 	((void (code *) (void)) FLASH_PROG) ();
000967 12DFF6            LCALL    0DFF6H
  139: #endif	// __C51__
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  08:49:06  PAGE 14


  140: #ifdef	SDCC
  141: _asm
  142: 	LCALL FLASH_PROG;
  143: _endasm;
  144: #endif	// SDCC
  145: 
  146: #ifdef	XC88x
  147: 	success = CY;
00096A 9202              MOV      success,C
  148: 	POP(PSW);
00096C D0D0              POP      PSW
  149: 	return(!success);			  
00096E A202              MOV      C,success
000970 B3                CPL      C
  150: #endif	// XC88x
  151: #ifdef	XC866
  152: 	return (!CY);
  153: #endif	// XC866
  154: }
000971 22                RET      
----- FUNCTION _FLASH_Prog (END) -------


----- FUNCTION _FLASH_Erase (BEGIN) -----
 FILE: 'FlashHandler.c'
  163: bit FLASH_Erase			(unsigned int DFlash0Sector,unsigned int DFlash1Sector)
  164: #endif	// XC88x
;---- Variable 'DFlash1Sector' assigned to Register 'R4/R5' ----
;---- Variable 'DFlash0Sector' assigned to Register 'R6/R7' ----
  165: {
  166: #ifdef	XC88x
  167:     volatile bit success; 
  168: #endif	// XC88x
  169: 	t_unFLPARAM P1;
  170: #ifdef	XC88x
  171: 	t_unFLPARAM P2;
  172: #endif	// XC88x
  173: 
  174: #ifdef	XC866
  175: #define USE_BANK  3								// fix the used registerbank to 3 for XC866 devices
  176: #endif	// XC866
  177: 
  178: 	P1.UINT_Param = DFlash0Sector;
000972 8E54              MOV      P1,R6
000974 8F55              MOV      P1+01H,R7
  179: #ifdef	XC88x
  180: 	P2.UINT_Param = DFlash1Sector;
000976 8C56              MOV      P2,R4
000978 8D57              MOV      P2+01H,R5
  181: #endif	// XC88x
  182: 	
  183: #ifdef	XC866
  184: 	REG[(4+(USE_BANK*8))] = P1.UBYTE_Param[0];	// DFLASH0 Sector - BANK3 - High Adr Byte
  185: 	REG[(3+(USE_BANK*8))] = P1.UBYTE_Param[1];	// DFLASH0 Sector - BANK3 - Low  Adr Byte
  186: #endif	// XC866
  187: #ifdef	XC88x
  188: 	REG[(1+(USE_BANK*8))] = P1.UBYTE_Param[0];	// DFLASH0 Sector -         High Adr Byte
00097A 7819              MOV      R0,#019H
00097C A654              MOV      @R0,P1
  189: 	REG[(0+(USE_BANK*8))] = P1.UBYTE_Param[1];	// DFLASH0 Sector -         Low  Adr Byte
00097E 18                DEC      R0
00097F A655              MOV      @R0,P1+01H
  190: 	REG[(4+(USE_BANK*8))] = P2.UBYTE_Param[0];	// DFLASH1 Sector  
000981 781C              MOV      R0,#01CH
000983 A656              MOV      @R0,P2
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  08:49:06  PAGE 15


  191: 	REG[(3+(USE_BANK*8))] = P2.UBYTE_Param[1];	// DFLASH1 Sector  
000985 18                DEC      R0
000986 A657              MOV      @R0,P2+01H
  192: #endif	// XC88x
  193: 	REG[(5+(USE_BANK*8))] = 0;					// PFLASH  
000988 781D              MOV      R0,#01DH
00098A E4                CLR      A
00098B F6                MOV      @R0,A
  194: 	REG[(6+(USE_BANK*8))] = 0;					// PFLASH  
00098C 08                INC      R0
00098D F6                MOV      @R0,A
  195: 	REG[(7+(USE_BANK*8))] = 0;					// PFLASH  
00098E 08                INC      R0
00098F F6                MOV      @R0,A
  196: 
  197: #ifdef XC88x
  198: 	PUSH(PSW);
000990 C0D0              PUSH     PSW
  199: 	PSW = ((USE_BANK)<<3);
000992 75D018            MOV      PSW,#018H
  200: #endif	// XC88x
  201: 
  202: #ifdef	__C51__
  203: 	((void (code *) (void)) FLASH_ERASE) ();
000995 12DFF9            LCALL    0DFF9H
  204: #endif	// __C51__
  205: #ifdef	SDCC
  206: _asm
  207: 	LCALL FLASH_ERASE;
  208: _endasm;
  209: #endif	// SDCC
  210: 
  211: #ifdef	XC866
  212: 	return(!CY);
  213: #endif	// XC866
  214: #ifdef	XC88x
  215: 	success = CY;
000998 9202              MOV      success,C
  216: 	POP(PSW);
00099A D0D0              POP      PSW
  217: 	return (!success);
00099C A202              MOV      C,success
00099E B3                CPL      C
  218: #endif	// XC88x
  219: }
00099F 22                RET      
----- FUNCTION _FLASH_Erase (END) -------


----- FUNCTION UART_vInit (BEGIN) -----
 FILE: 'UART.C'
   60: void UART_vInit(void)
   61: {
   62:   ///  -----------------------------------------------------------------------
   63:   ///  UART settings
   64:   ///  -----------------------------------------------------------------------
   65:   ///  Pin TXD_1 (P0.2) is selected for transmission
   66:   ///  Pin RXD_1 (P0.1) is selected for reception
   67:   ///  Receiver enabled
   68:   ///  Mode 1: 8-bit data, 1 start bit, 1 stop bit, variable baud rate
   69:   ///  Receiver interrupt flag RI will only be activated if a valid stop bit 
   70:   ///  was received
   71:   ///  BRG is selected for baudrate generation
   72: 
   73:   SFR_PAGE(_pp2, noSST);         // switch to page 2 without saving
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  08:49:06  PAGE 16


0009A0 75B202            MOV      PORT_PAGE,#02H
   74:   P0_ALTSEL0   &= ~(ubyte)0x04;  // configure alternate function register 0
0009A3 5380FB            ANL      P0_ALTSEL0,#0FBH
   75:   P0_ALTSEL1   |=  (ubyte)0x04;  // configure alternate function register 1
0009A6 438604            ORL      P0_ALTSEL1,#04H
   76:   SFR_PAGE(_pp0, noSST);         // switch to page 0 without saving
0009A9 E4                CLR      A
0009AA F5B2              MOV      PORT_PAGE,A
   77:   P0_DIR       |=  (ubyte)0x04;  // set output direction
0009AC 438604            ORL      P0_DIR,#04H
   78: 
   79: 
   80:   MODPISEL     |=  (ubyte)0x01;  // configure peripheral input select register
0009AF 43B301            ORL      MODPISEL,#01H
   81:   BCON          =  0x00;         // reset baudrate timer/reload register
0009B2 F5BD              MOV      BCON,A
   82:   SCON          =  0x70;         // load serial channel control register
0009B4 759870            MOV      SCON,#070H
   83: 
   84:   ///  -----------------------------------------------------------------------
   85:   ///  Baudrate generator settings
   86:   ///  -----------------------------------------------------------------------
   87:   ///  input clock = fPCLK
   88:   ///  Fractional divider is enabled
   89:   ///  baudrate = 9.6004 kbaud
   90: 
   91:   FDSTEP        =  0xD5;         // load fractional divider reload register
0009B7 75EAD5            MOV      FDSTEP,#0D5H
   92:   BG            =  0x81;         // load baudrate timer/reload register
0009BA 75BE81            MOV      BG,#081H
   93:   FDCON        |=  0x01;         // load Fractional Divider control register
0009BD 43E901            ORL      FDCON,#01H
   94:   BCON         |=  0x01;         // load baud rate control register
0009C0 43BD01            ORL      BCON,#01H
   95: 
   96:   ///  UART interrupt enabled
   97:   ES = 1;
0009C3 D2AC              SETB     ES
   98: 
   99: } //  End of function UART_vInit
0009C5 22                RET      
----- FUNCTION UART_vInit (END) -------


----- FUNCTION _processCommand (BEGIN) -----
 FILE: 'UART.C'
  143: void processCommand(char * command) {
  144: 	
0009C6 8B3F              MOV      command,R3
0009C8 8A40              MOV      command+01H,R2
0009CA 8941              MOV      command+02H,R1
  145: 	int commandSize = strlen(command);
0009CC 120003            LCALL    _strlen
0009CF 8E42              MOV      commandSize,R6
0009D1 8F43              MOV      commandSize+01H,R7
  146: 	char xdata respondMessage[MAX_RESPONSE_LENGTH] = {0};
0009D3 7800              MOV      R0,#LOW respondMessage
0009D5 7CF0              MOV      R4,#HIGH respondMessage
0009D7 7D01              MOV      R5,#01H
0009D9 7BFF              MOV      R3,#0FFH
0009DB 7A04              MOV      R2,#HIGH _?ix1000
0009DD 793C              MOV      R1,#LOW _?ix1000
0009DF 7E00              MOV      R6,#00H
0009E1 7FC8              MOV      R7,#0C8H
0009E3 1200F6            LCALL    ?C?COPY
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  08:49:06  PAGE 17


  147: 	bool isNormalCommand = commandSize == 5 && command[0] == '$' && command[2] == '$' && command[4] == '$';
0009E6 E543              MOV      A,commandSize+01H
0009E8 6405              XRL      A,#05H
0009EA 4542              ORL      A,commandSize
0009EC 7021              JNZ      ?C0007?UART
0009EE AB3F              MOV      R3,command
0009F0 AA40              MOV      R2,command+01H
0009F2 A941              MOV      R1,command+02H
0009F4 12011C            LCALL    ?C?CLDPTR
0009F7 B42415            CJNE     A,#024H,?C0007?UART
0009FA 900002            MOV      DPTR,#02H
0009FD 120135            LCALL    ?C?CLDOPTR
000A00 B4240C            CJNE     A,#024H,?C0007?UART
000A03 900004            MOV      DPTR,#04H
000A06 120135            LCALL    ?C?CLDOPTR
000A09 B42403            CJNE     A,#024H,?C0007?UART
000A0C D3                SETB     C
000A0D 8001              SJMP     ?C0008?UART
000A0F         ?C0007?UART:
000A0F C3                CLR      C
000A10         ?C0008?UART:
000A10 9200              MOV      isNormalCommand,C
  148: 	bool isSetUUIDCommand = commandSize == 40 && command[0] == '$' && command[1] == 'f' && command[2] == '$' && comm
>> and[39] == '$';
000A12 E543              MOV      A,commandSize+01H
000A14 6428              XRL      A,#028H
000A16 4542              ORL      A,commandSize
000A18 702B              JNZ      ?C0009?UART
000A1A AB3F              MOV      R3,command
000A1C AA40              MOV      R2,command+01H
000A1E A941              MOV      R1,command+02H
000A20 12011C            LCALL    ?C?CLDPTR
000A23 6424              XRL      A,#024H
000A25 701E              JNZ      ?C0009?UART
000A27 900001            MOV      DPTR,#01H
000A2A 120135            LCALL    ?C?CLDOPTR
000A2D B46615            CJNE     A,#066H,?C0009?UART
000A30 900002            MOV      DPTR,#02H
000A33 120135            LCALL    ?C?CLDOPTR
000A36 B4240C            CJNE     A,#024H,?C0009?UART
000A39 900027            MOV      DPTR,#027H
000A3C 120135            LCALL    ?C?CLDOPTR
000A3F B42403            CJNE     A,#024H,?C0009?UART
000A42 D3                SETB     C
000A43 8001              SJMP     ?C0010?UART
000A45         ?C0009?UART:
000A45 C3                CLR      C
000A46         ?C0010?UART:
000A46 9201              MOV      isSetUUIDCommand,C
  149: 	
  150: 	memset(respondMessage, 0, MAX_RESPONSE_LENGTH);	
000A48 7E00              MOV      R6,#00H
000A4A 7FC8              MOV      R7,#0C8H
000A4C 7D00              MOV      R5,#00H
000A4E 7B01              MOV      R3,#01H
000A50 7AF0              MOV      R2,#HIGH respondMessage
000A52 7900              MOV      R1,#LOW respondMessage
000A54 1201E4            LCALL    ?C?MEMSET
  151: 
  152: 	if (isNormalCommand) {
000A57 30005C            JNB      isNormalCommand,?C0011?UART
  153: 		switch(command[1]) {
000A5A AB3F              MOV      R3,command
000A5C AA40              MOV      R2,command+01H
000A5E A941              MOV      R1,command+02H
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  08:49:06  PAGE 18


000A60 900001            MOV      DPTR,#01H
000A63 120135            LCALL    ?C?CLDOPTR
000A66 249E              ADD      A,#09EH
000A68 6019              JZ       ?C0014?UART
000A6A 14                DEC      A
000A6B 6025              JZ       ?C0015?UART
000A6D 14                DEC      A
000A6E 6031              JZ       ?C0016?UART
000A70 14                DEC      A
000A71 6031              JZ       ?C0017?UART
000A73 14                DEC      A
000A74 603D              JZ       ?C0018?UART
000A76 2405              ADD      A,#05H
000A78 7048              JNZ      ?C0031?UART
  154: 			case 'a':
000A7A         ?C0013?UART:
  155: 				enableLCRChannel(command[3]);
000A7A 900003            MOV      DPTR,#03H
000A7D 120135            LCALL    ?C?CLDOPTR
000A80 FF                MOV      R7,A
000A81 613E              AJMP     _enableLCRChannel
  156: 				break;
  157: 			case 'b':
000A83         ?C0014?UART:
  158: 				enableLCChannel(command[3]);
000A83 AB3F              MOV      R3,command
000A85 AA40              MOV      R2,command+01H
000A87 A941              MOV      R1,command+02H
000A89 900003            MOV      DPTR,#03H
000A8C 120135            LCALL    ?C?CLDOPTR
000A8F FF                MOV      R7,A
000A90 8062              SJMP     _enableLCChannel
  159: 				break;
  160: 			case 'c':
000A92         ?C0015?UART:
  161: 				setChargeMode(command[3]);
000A92 AB3F              MOV      R3,command
000A94 AA40              MOV      R2,command+01H
000A96 A941              MOV      R1,command+02H
000A98 900003            MOV      DPTR,#03H
000A9B 120135            LCALL    ?C?CLDOPTR
000A9E FF                MOV      R7,A
000A9F 6188              AJMP     _setChargeMode
  162: 				break;
  163: 			case 'd':
000AA1         ?C0016?UART:
  164: 				sendHVRelayStatus();
000AA1 0206D7            LJMP     sendHVRelayStatus
  165: 				break;
  166: 			case 'e':
000AA4         ?C0017?UART:
  167: 				setHVMonitorMode(command[3]);
000AA4 AB3F              MOV      R3,command
000AA6 AA40              MOV      R2,command+01H
000AA8 A941              MOV      R1,command+02H
000AAA 900003            MOV      DPTR,#03H
000AAD 120135            LCALL    ?C?CLDOPTR
000AB0 FF                MOV      R7,A
000AB1 8018              SJMP     _setHVMonitorMode
  168: 				break;
  169: 			case 'f':
000AB3         ?C0018?UART:
  170: 				sendUUID();
000AB3 0207BC            LJMP     sendUUID
  171: 				break;
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  08:49:06  PAGE 19


  172: 			default:
000AB6         ?C0011?UART:
000AB6 300109            JNB      isSetUUIDCommand,?C0021?UART
  173: 				sendUART("Unknown Command\r\n");
  174: 		}		
  175: 	} else if (isSetUUIDCommand) {
  176: 		setUUID(command);
000AB9 AB3F              MOV      R3,command
000ABB AA40              MOV      R2,command+01H
000ABD A941              MOV      R1,command+02H
000ABF 02074F            LJMP     _setUUID
  177: 	} else {
000AC2         ?C0021?UART:
  178: 		sendUART("Unknown Command\r\n");
000AC2         
000AC2 7BFF              MOV      R3,#0FFH
000AC4 7A04              MOV      R2,#HIGH 0100042AH
000AC6 792A              MOV      R1,#LOW 0100042AH
000AC8 0206C2            LJMP     _sendUART
  179: 	}
----- FUNCTION _processCommand (END) -------


----- FUNCTION _setHVMonitorMode (BEGIN) -----
 FILE: 'DeviceController.c'
  168: void setHVMonitorMode(char modeCode) {
  169: 	if (modeCode == '1') {
000ACB 8F44              MOV      modeCode,R7
  170: 		shouldMonitorHVStatus = 1;
000ACD E544              MOV      A,modeCode
000ACF B4310A            CJNE     A,#031H,?C0042?DEVICECONTROLLER
  171: 		sendUART("#e#1#\n");
000AD2 D203              SETB     shouldMonitorHVStatus
  172: 	} else if (modeCode == '0') {
000AD4 7BFF              MOV      R3,#0FFH
000AD6 7A03              MOV      R2,#HIGH 010003B0H
000AD8 79B0              MOV      R1,#LOW 010003B0H
  173: 		shouldMonitorHVStatus = 0;
000ADA 8015              SJMP     ?C0068?DEVICECONTROLLER
000ADC         ?C0042?DEVICECONTROLLER:
000ADC E544              MOV      A,modeCode
000ADE B4300A            CJNE     A,#030H,?C0044?DEVICECONTROLLER
  174: 		sendUART("#e#0#\n");
000AE1 C203              CLR      shouldMonitorHVStatus
  175: 	} else {
000AE3 7BFF              MOV      R3,#0FFH
000AE5 7A03              MOV      R2,#HIGH 010003B7H
000AE7 79B7              MOV      R1,#LOW 010003B7H
000AE9         
  176: 		sendUART("#Unknown HV Monitor Code#\n");
000AE9 8006              SJMP     ?C0068?DEVICECONTROLLER
000AEB         ?C0044?DEVICECONTROLLER:
  177: 	}
000AEB 7BFF              MOV      R3,#0FFH
000AED 7A03              MOV      R2,#HIGH 010003BEH
000AEF 79BE              MOV      R1,#LOW 010003BEH
000AF1         
000AF1 0206C2            LJMP     _sendUART
  178: 	
----- FUNCTION _setHVMonitorMode (END) -------


----- FUNCTION _enableLCChannel (BEGIN) -----
 FILE: 'DeviceController.c'
   17: void enableLCChannel(char channelCode) {
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  08:49:06  PAGE 20


   18: 	// Switch off all LC / LCR channel first.
;---- Variable 'channelCode' assigned to Register 'R7' ----
   19: 	IO_vResetPin(LCR_CHANNEL_1);
000AF4 C290              CLR      P1_0
   20: 	IO_vResetPin(LCR_CHANNEL_2);
000AF6 C292              CLR      P1_2
   21: 	IO_vResetPin(LCR_CHANNEL_3);	
000AF8 C294              CLR      P1_4
   22: 	IO_vResetPin(LC_CHANNEL_1);
000AFA C291              CLR      P1_1
   23: 	IO_vResetPin(LC_CHANNEL_2);
000AFC C293              CLR      P1_3
   24: 	IO_vResetPin(LC_CHANNEL_3);
000AFE C295              CLR      P1_5
   25: 	
   26: 	// Enable coressponding LCR channel GPIO
   27: 	switch(channelCode) {
000B00 EF                MOV      A,R7
000B01 24CF              ADD      A,#0CFH
000B03 6012              JZ       ?C0004?DEVICECONTROLLER
000B05 14                DEC      A
000B06 6019              JZ       ?C0005?DEVICECONTROLLER
000B08 14                DEC      A
000B09 6020              JZ       ?C0006?DEVICECONTROLLER
000B0B 2403              ADD      A,#03H
000B0D 7026              JNZ      ?C0007?DEVICECONTROLLER
   28: 		case '0':
000B0F         ?C0003?DEVICECONTROLLER:
   29: 			sendUART("#b#0#\n");
000B0F 7BFF              MOV      R3,#0FFH
000B11 7A02              MOV      R2,#HIGH 0100024FH
000B13 794F              MOV      R1,#LOW 0100024FH
   30: 			break;
000B15 8024              SJMP     ?C0051?DEVICECONTROLLER
   31: 		case '1':
000B17         ?C0004?DEVICECONTROLLER:
   32: 			IO_vSetPin(LC_CHANNEL_1);
000B17 D291              SETB     P1_1
   33: 			sendUART("#b#1#\n");
000B19 7BFF              MOV      R3,#0FFH
000B1B 7A02              MOV      R2,#HIGH 01000256H
000B1D 7956              MOV      R1,#LOW 01000256H
000B1F         
   34: 			break;
000B1F 801A              SJMP     ?C0051?DEVICECONTROLLER
   35: 		case '2':
000B21         ?C0005?DEVICECONTROLLER:
   36: 			IO_vSetPin(LC_CHANNEL_2);
000B21 D293              SETB     P1_3
   37: 			sendUART("#b#2#\n");		
000B23 7BFF              MOV      R3,#0FFH
000B25 7A02              MOV      R2,#HIGH 0100025DH
000B27 795D              MOV      R1,#LOW 0100025DH
000B29         
   38: 			break;
000B29 8010              SJMP     ?C0051?DEVICECONTROLLER
   39: 		case '3':
000B2B         ?C0006?DEVICECONTROLLER:
   40: 			IO_vSetPin(LC_CHANNEL_3);
000B2B D295              SETB     P1_5
   41: 			sendUART("#b#3#\n");
000B2D 7BFF              MOV      R3,#0FFH
000B2F 7A02              MOV      R2,#HIGH 01000264H
000B31 7964              MOV      R1,#LOW 01000264H
000B33         
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  08:49:06  PAGE 21


   42: 			break;
000B33 8006              SJMP     ?C0051?DEVICECONTROLLER
   43: 		default:
000B35         ?C0007?DEVICECONTROLLER:
   44: 			sendUART("#Unknown LC Channel.#\n");			
000B35 7BFF              MOV      R3,#0FFH
000B37 7A02              MOV      R2,#HIGH 0100026BH
000B39 796B              MOV      R1,#LOW 0100026BH
000B3B         
000B3B 0206C2            LJMP     _sendUART
   45: 			break;
   46: 	}
----- FUNCTION _enableLCChannel (END) -------


----- FUNCTION _enableLCRChannel (BEGIN) -----
 FILE: 'DeviceController.c'
   49: void enableLCRChannel(char channelCode) {
   50: 	// Switch off all LC / LCR channel first.
;---- Variable 'channelCode' assigned to Register 'R7' ----
   51: 	IO_vResetPin(LCR_CHANNEL_1);
000B3E C290              CLR      P1_0
   52: 	IO_vResetPin(LCR_CHANNEL_2);
000B40 C292              CLR      P1_2
   53: 	IO_vResetPin(LCR_CHANNEL_3);
000B42 C294              CLR      P1_4
   54: 	IO_vResetPin(LC_CHANNEL_1);
000B44 C291              CLR      P1_1
   55: 	IO_vResetPin(LC_CHANNEL_2);
000B46 C293              CLR      P1_3
   56: 	IO_vResetPin(LC_CHANNEL_3);
000B48 C295              CLR      P1_5
   57: 	
   58: 	// Enable coressponding LCR channel GPIO
   59: 	switch(channelCode) {
000B4A EF                MOV      A,R7
000B4B 24CF              ADD      A,#0CFH
000B4D 6012              JZ       ?C0011?DEVICECONTROLLER
000B4F 14                DEC      A
000B50 6019              JZ       ?C0012?DEVICECONTROLLER
000B52 14                DEC      A
000B53 6020              JZ       ?C0013?DEVICECONTROLLER
000B55 2403              ADD      A,#03H
000B57 7026              JNZ      ?C0014?DEVICECONTROLLER
   60: 		case '0':
000B59         ?C0010?DEVICECONTROLLER:
   61: 			sendUART("#a#0#\n");
000B59 7BFF              MOV      R3,#0FFH
000B5B 7A02              MOV      R2,#HIGH 01000282H
000B5D 7982              MOV      R1,#LOW 01000282H
   62: 			break;
000B5F 8024              SJMP     ?C0055?DEVICECONTROLLER
   63: 		case '1':
000B61         ?C0011?DEVICECONTROLLER:
   64: 			IO_vSetPin(LCR_CHANNEL_1);
000B61 D290              SETB     P1_0
   65: 			sendUART("#a#1#\n");
000B63 7BFF              MOV      R3,#0FFH
000B65 7A02              MOV      R2,#HIGH 01000289H
000B67 7989              MOV      R1,#LOW 01000289H
000B69         
   66: 			break;
000B69 801A              SJMP     ?C0055?DEVICECONTROLLER
   67: 		case '2':
000B6B         ?C0012?DEVICECONTROLLER:
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  08:49:06  PAGE 22


   68: 			IO_vSetPin(LCR_CHANNEL_2);
000B6B D292              SETB     P1_2
   69: 			sendUART("#a#2#\n");		
000B6D 7BFF              MOV      R3,#0FFH
000B6F 7A02              MOV      R2,#HIGH 01000290H
000B71 7990              MOV      R1,#LOW 01000290H
000B73         
   70: 			break;
000B73 8010              SJMP     ?C0055?DEVICECONTROLLER
   71: 		case '3':
000B75         ?C0013?DEVICECONTROLLER:
   72: 			IO_vSetPin(LCR_CHANNEL_3);
000B75 D294              SETB     P1_4
   73: 			sendUART("#a#3#\n");
000B77 7BFF              MOV      R3,#0FFH
000B79 7A02              MOV      R2,#HIGH 01000297H
000B7B 7997              MOV      R1,#LOW 01000297H
000B7D         
   74: 			break;
000B7D 8006              SJMP     ?C0055?DEVICECONTROLLER
   75: 		default:
000B7F         ?C0014?DEVICECONTROLLER:
   76: 			sendUART("#Unknown LCR Channel.#\n");			
000B7F 7BFF              MOV      R3,#0FFH
000B81 7A02              MOV      R2,#HIGH 0100029EH
000B83 799E              MOV      R1,#LOW 0100029EH
000B85         
000B85 0206C2            LJMP     _sendUART
   77: 			break;
   78: 	}
----- FUNCTION _enableLCRChannel (END) -------


----- FUNCTION _setChargeMode (BEGIN) -----
 FILE: 'DeviceController.c'
  140: void setChargeMode(char modeCode) {
  141: 	if (modeCode == '0') {
000B88 8F44              MOV      modeCode,R7
  142: 		IO_vResetPin(HV_CHANNEL);		
000B8A E544              MOV      A,modeCode
000B8C B4300E            CJNE     A,#030H,?C0034?DEVICECONTROLLER
  143: 		IO_vSetPin(DISCHARGE_CHANNEL);
000B8F C2B7              CLR      P3_7
  144: 		IO_vSetPin(CHARGE_CHANNEL);
000B91 D2CE              SETB     P4_6
  145: 		sendUART("#c#0#\n");		
000B93 D2B4              SETB     P3_4
  146: 	} else if (modeCode == '1') {
000B95 7BFF              MOV      R3,#0FFH
000B97 7A03              MOV      R2,#HIGH 01000384H
000B99 7984              MOV      R1,#LOW 01000384H
  147: 		if (!isAllHVRelayOK()) {
000B9B 8040              SJMP     ?C0066?DEVICECONTROLLER
000B9D         ?C0034?DEVICECONTROLLER:
000B9D E544              MOV      A,modeCode
000B9F 6431              XRL      A,#031H
000BA1 7021              JNZ      ?C0036?DEVICECONTROLLER
  148: 			IO_vResetPin(HV_CHANNEL);			
000BA3 1207DD            LCALL    isAllHVRelayOK
000BA6 400E              JC       ?C0037?DEVICECONTROLLER
  149: 			IO_vSetPin(CHARGE_CHANNEL);
000BA8 C2B7              CLR      P3_7
  150: 			IO_vSetPin(DISCHARGE_CHANNEL);
000BAA D2B4              SETB     P3_4
  151: 			sendUART("#d#0#\n");
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  08:49:06  PAGE 23


000BAC D2CE              SETB     P4_6
  152: 			return;
000BAE 7BFF              MOV      R3,#0FFH
000BB0 7A03              MOV      R2,#HIGH 0100037DH
000BB2 797D              MOV      R1,#LOW 0100037DH
000BB4         
000BB4 8027              SJMP     ?C0066?DEVICECONTROLLER
  153: 		}
000BB6         ?C0037?DEVICECONTROLLER:
  154: 		IO_vSetPin(DISCHARGE_CHANNEL);
000BB6 D2CE              SETB     P4_6
  155: 		IO_vSetPin(HV_CHANNEL);
000BB8 D2B7              SETB     P3_7
  156: 		IO_vResetPin(CHARGE_CHANNEL);
000BBA C2B4              CLR      P3_4
  157: 		sendUART("#c#1#\n");
000BBC 7BFF              MOV      R3,#0FFH
000BBE 7A03              MOV      R2,#HIGH 0100038BH
000BC0 798B              MOV      R1,#LOW 0100038BH
000BC2         
  158: 	} else if (modeCode == '2') {
000BC2 8019              SJMP     ?C0066?DEVICECONTROLLER
000BC4         ?C0036?DEVICECONTROLLER:
000BC4 E544              MOV      A,modeCode
000BC6 B4320E            CJNE     A,#032H,?C0040?DEVICECONTROLLER
  159: 		IO_vSetPin(CHARGE_CHANNEL);
000BC9 D2B4              SETB     P3_4
  160: 		IO_vResetPin(HV_CHANNEL);
000BCB C2B7              CLR      P3_7
  161: 		IO_vResetPin(DISCHARGE_CHANNEL);
000BCD C2CE              CLR      P4_6
  162: 		sendUART("#c#2#\n");
000BCF 7BFF              MOV      R3,#0FFH
000BD1 7A03              MOV      R2,#HIGH 01000392H
000BD3 7992              MOV      R1,#LOW 01000392H
000BD5         
  163: 	} else {
000BD5 8006              SJMP     ?C0066?DEVICECONTROLLER
000BD7         ?C0040?DEVICECONTROLLER:
  164: 		sendUART("#Unknown Charge Mode#\n");		
000BD7 7BFF              MOV      R3,#0FFH
000BD9 7A03              MOV      R2,#HIGH 01000399H
000BDB 7999              MOV      R1,#LOW 01000399H
000BDD         
000BDD 0206C2            LJMP     _sendUART
  165: 	}
----- FUNCTION _setChargeMode (END) -------


----- FUNCTION UART_viIsr (BEGIN) -----
 FILE: 'UART.C'
  182: void UART_viIsr(void) interrupt UARTINT
000BE0 C0E0              PUSH     ACC
000BE2 C0F0              PUSH     B
000BE4 C083              PUSH     DPH
000BE6 C082              PUSH     DPL
000BE8 C0D0              PUSH     PSW
000BEA 75D000            MOV      PSW,#00H
000BED C000              PUSH     AR0
000BEF C001              PUSH     AR1
000BF1 C002              PUSH     AR2
000BF3 C003              PUSH     AR3
000BF5 C004              PUSH     AR4
000BF7 C005              PUSH     AR5
000BF9 C006              PUSH     AR6
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  08:49:06  PAGE 24


000BFB C007              PUSH     AR7
  183: {
  184: 	// switch to page 0
  185:   SFR_PAGE(_su0, SST0);
000BFD 75BF80            MOV      SCU_PAGE,#080H
  186:   if (TI)
000C00 309902            JNB      TI,?C0024?UART
  187:   {
  188: 		TI = 0;
000C03 C299              CLR      TI
  189:   }
000C05         ?C0024?UART:
  190:   if (RI)
000C05 309854            JNB      RI,?C0025?UART
  191:   {
  192: 		char receiveByte = SBUF;
000C08 85993E            MOV      receiveByte,SBUF
  193: 		if (receiveByte == '\r' || receiveByte == '\n' || bufferCount >= MAX_COMMAND_LENGTH-1) {
000C0B E53E              MOV      A,receiveByte
000C0D 640D              XRL      A,#0DH
000C0F 6013              JZ       ?C0027?UART
000C11 E53E              MOV      A,receiveByte
000C13 640A              XRL      A,#0AH
000C15 600D              JZ       ?C0027?UART
000C17 C3                CLR      C
000C18 E509              MOV      A,bufferCount+01H
000C1A 9463              SUBB     A,#063H
000C1C E508              MOV      A,bufferCount
000C1E 6480              XRL      A,#080H
000C20 9480              SUBB     A,#080H
000C22 401F              JC       ?C0026?UART
000C24         ?C0027?UART:
  194: 			processCommand(receiveBuffer);
000C24 7B01              MOV      R3,#01H
000C26 7AF1              MOV      R2,#HIGH receiveBuffer
000C28 7971              MOV      R1,#LOW receiveBuffer
000C2A 31C6              ACALL    _processCommand
  195: 			memset(receiveBuffer, 0, MAX_COMMAND_LENGTH);			
000C2C 7E00              MOV      R6,#00H
000C2E 7F64              MOV      R7,#064H
000C30 7D00              MOV      R5,#00H
000C32 7B01              MOV      R3,#01H
000C34 7AF1              MOV      R2,#HIGH receiveBuffer
000C36 7971              MOV      R1,#LOW receiveBuffer
000C38 1201E4            LCALL    ?C?MEMSET
  196: 			bufferCount = 0;
000C3B 750800            MOV      bufferCount,#00H
000C3E 750900            MOV      bufferCount+01H,#00H
  197: 		} else {
000C41 8017              SJMP     ?C0028?UART
000C43         ?C0026?UART:
  198: 			receiveBuffer[bufferCount] = receiveByte;
000C43 7471              MOV      A,#LOW receiveBuffer
000C45 2509              ADD      A,bufferCount+01H
000C47 F582              MOV      DPL,A
000C49 74F1              MOV      A,#HIGH receiveBuffer
000C4B 3508              ADDC     A,bufferCount
000C4D F583              MOV      DPH,A
000C4F E53E              MOV      A,receiveByte
000C51 F0                MOVX     @DPTR,A
  199: 			bufferCount++;
000C52 0509              INC      bufferCount+01H
000C54 E509              MOV      A,bufferCount+01H
000C56 7002              JNZ      ?C0030?UART
000C58 0508              INC      bufferCount
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  08:49:06  PAGE 25


000C5A         ?C0030?UART:
  200: 		}
000C5A         ?C0028?UART:
  201:     RI = 0;
000C5A C298              CLR      RI
  202:   }
000C5C         ?C0025?UART:
  203: 
  204: 	// restore the old page
  205:   SFR_PAGE(_su0, RST0);
000C5C 75BFC0            MOV      SCU_PAGE,#0C0H
  206: }
000C5F D007              POP      AR7
000C61 D006              POP      AR6
000C63 D005              POP      AR5
000C65 D004              POP      AR4
000C67 D003              POP      AR3
000C69 D002              POP      AR2
000C6B D001              POP      AR1
000C6D D000              POP      AR0
000C6F D0D0              POP      PSW
000C71 D082              POP      DPL
000C73 D083              POP      DPH
000C75 D0F0              POP      B
000C77 D0E0              POP      ACC
000C79 32                RETI     
----- FUNCTION UART_viIsr (END) -------


----- FUNCTION _FLASH_Ready (BEGIN) -----
 FILE: 'FlashHandler.c'
   92: bit FLASH_Ready						(unsigned char BankNum)
   93: {
;---- Variable 'BankNum' assigned to Register 'R7' ----
   94:     ACC = BankNum;
   95: #ifdef __C51__		
000C7A EF                MOV      A,R7
   96: 	((void (code *) (void)) FLASH_READ_STATUS) ();
000C7B 02DFF0            LJMP     0DFF0H
   97: #endif	// __C51__
   98: #ifdef	SDCC
   99: _asm
  100: 	LCALL FLASH_READ_STATUS;
  101: _endasm;
  102: #endif	// SDCC
  103: 	return(CY);
----- FUNCTION _FLASH_Ready (END) -------


----- FUNCTION _readFlashToBuffer (BEGIN) -----
 FILE: 'FlashUtils.c'
   46: void readFlashToBuffer(char xdata * buffer, int n, unsigned char code * EECurrentAddr) 
   47: {
000C7E 8E44              MOV      buffer,R6
000C80 8F45              MOV      buffer+01H,R7
000C82 8C46              MOV      n,R4
000C84 8D47              MOV      n+01H,R5
000C86 8A48              MOV      EECurrentAddr,R2
000C88 8B49              MOV      EECurrentAddr+01H,R3
   48: 	unsigned char code * EETempAddr = (unsigned char code*)FLASH_FIRST_ADDR;
   49: 	int i = 0;
000C8A 754AA0            MOV      EETempAddr,#0A0H
000C8D 754B00            MOV      EETempAddr+01H,#00H
   50: 	int j = 0;
000C90 E4                CLR      A
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  08:49:06  PAGE 26


000C91 F54C              MOV      i,A
000C93 F54D              MOV      i+01H,A
   51: 	int k = 0;
000C95 F54E              MOV      j,A
000C97 F54F              MOV      j+01H,A
   52: 	memset(buffer, 0, n);
000C99 F550              MOV      k,A
000C9B F551              MOV      k+01H,A
   53: 	
000C9D AE46              MOV      R6,n
000C9F AF47              MOV      R7,n+01H
000CA1 FD                MOV      R5,A
000CA2 AA44              MOV      R2,buffer
000CA4 A945              MOV      R1,buffer+01H
000CA6 7B01              MOV      R3,#01H
000CA8 1201E4            LCALL    ?C?MEMSET
000CAB         ?C0011?FLASHUTILS:
   54: 	while (FLASH_Ready(FLASH_BANK_TO_CHECK) == 0) {;}
000CAB 7F03              MOV      R7,#03H
000CAD 917A              ACALL    _FLASH_Ready
000CAF 50FA              JNC      ?C0011?FLASHUTILS
000CB1         ?C0012?FLASHUTILS:
000CB1         ?C0013?FLASHUTILS:
   55: 	
   56: 	while (EETempAddr < EECurrentAddr && j < n) 
000CB1 C3                CLR      C
000CB2 E54B              MOV      A,EETempAddr+01H
000CB4 9549              SUBB     A,EECurrentAddr+01H
000CB6 E54A              MOV      A,EETempAddr
000CB8 9548              SUBB     A,EECurrentAddr
000CBA 5054              JNC      ?C0017?FLASHUTILS
000CBC C3                CLR      C
000CBD E54F              MOV      A,j+01H
000CBF 9547              SUBB     A,n+01H
000CC1 E546              MOV      A,n
000CC3 6480              XRL      A,#080H
000CC5 F8                MOV      R0,A
000CC6 E54E              MOV      A,j
000CC8 6480              XRL      A,#080H
000CCA 98                SUBB     A,R0
000CCB 5043              JNC      ?C0017?FLASHUTILS
   57: 	{	
   58: 		i = 0;
000CCD E4                CLR      A
000CCE F54C              MOV      i,A
000CD0 F54D              MOV      i+01H,A
000CD2         ?C0015?FLASHUTILS:
   59: 		while (*(EETempAddr+i) != 0) {
000CD2 E54B              MOV      A,EETempAddr+01H
000CD4 254D              ADD      A,i+01H
000CD6 F582              MOV      DPL,A
000CD8 E54A              MOV      A,EETempAddr
000CDA 354C              ADDC     A,i
000CDC F583              MOV      DPH,A
000CDE E4                CLR      A
000CDF 93                MOVC     A,@A+DPTR
000CE0 FF                MOV      R7,A
000CE1 6020              JZ       ?C0016?FLASHUTILS
   60: 			buffer[j] = *(EETempAddr+i);
000CE3 E545              MOV      A,buffer+01H
000CE5 254F              ADD      A,j+01H
000CE7 F582              MOV      DPL,A
000CE9 E544              MOV      A,buffer
000CEB 354E              ADDC     A,j
000CED F583              MOV      DPH,A
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  08:49:06  PAGE 27


000CEF EF                MOV      A,R7
000CF0 F0                MOVX     @DPTR,A
   61: 			i++;
000CF1 054D              INC      i+01H
000CF3 E54D              MOV      A,i+01H
000CF5 7002              JNZ      ?C0025?FLASHUTILS
000CF7 054C              INC      i
000CF9         ?C0025?FLASHUTILS:
   62: 			j++;
000CF9 054F              INC      j+01H
000CFB E54F              MOV      A,j+01H
000CFD 7002              JNZ      ?C0026?FLASHUTILS
000CFF 054E              INC      j
000D01         ?C0026?FLASHUTILS:
   63: 		}
000D01 80CF              SJMP     ?C0015?FLASHUTILS
000D03         ?C0016?FLASHUTILS:
   64: 		EETempAddr = EETempAddr + BYTES_PER_WORDLINE;		
000D03 7420              MOV      A,#020H
000D05 254B              ADD      A,EETempAddr+01H
000D07 F54B              MOV      EETempAddr+01H,A
000D09 E4                CLR      A
000D0A 354A              ADDC     A,EETempAddr
000D0C F54A              MOV      EETempAddr,A
   65: 	}	
000D0E 80A1              SJMP     ?C0013?FLASHUTILS
   66: }
000D10         ?C0017?FLASHUTILS:
000D10 22                RET      
----- FUNCTION _readFlashToBuffer (END) -------


