LX51 LINKER/LOCATER V4.66.41.0                                                          04/14/2016  10:04:31  PAGE 1





ASSEMBLER CODE PACKING OF MODULE:  TestBoard (?C_STARTUP)


000023 020BE5            LJMP     0BE5H
----- FUNCTION MAIN_vInit (BEGIN) -----
 FILE: 'MAIN.C'
   30: void MAIN_vInit(void)
   31: {
   32:   ///  -----------------------------------------------------------------------
   33:   ///  Configuration of the System Clock:
   34:   ///  -----------------------------------------------------------------------
   35:   ///  - On Chip Osc is Selected
   36:   ///  - PLL Mode, NDIV =  20
   37:   ///  - input frequency is 9.6 MHz
   38: 
   39:   //   FCLK runs at 2 times the frequency of PCLK.
   40:   SFR_PAGE(_su1, noSST);         // switch to page1
00069B 75BF01            MOV      SCU_PAGE,#01H
   41:   CMCON         =  0x10;         // load Clock Control Register
00069E 75BA10            MOV      CMCON,#010H
   42:   SFR_PAGE(_su0, noSST);         // switch to page0
0006A1 E4                CLR      A
0006A2 F5BF              MOV      SCU_PAGE,A
   43: 
   44: 
   45:   ///  *********************************************************************************
   46:   ///  Note : All peripheral related IO configurations are done in the 
   47:   ///  respective peripheral modules (alternate functions selection)
   48:   ///  *********************************************************************************
   49: 
   50:   ///  Initialization of module 'GPIO'
   51:   IO_vInit();
0006A4 D1B5              ACALL    IO_vInit
   52: 
   53:   ///  Initialization of module 'UART (Serial Interface)'
   54:   UART_vInit();
0006A6 120994            LCALL    UART_vInit
   55: 
   56:   //   Interrupt Priority
   57: 
   58:   IP            =  0x00;         // load Interrupt Priority Register
0006A9 E4                CLR      A
0006AA F5B8              MOV      IP,A
   59:   IPH           =  0x00;         // load Interrupt Priority High Register
0006AC F5B9              MOV      IPH,A
   60:   IP1           =  0x00;         // load Interrupt Priority 1 Register
0006AE F5F8              MOV      IP1,A
   61:   IPH1          =  0x00;         // load Interrupt Priority 1 High Register
0006B0 F5F9              MOV      IPH1,A
   62: 
   63: 
   64:   //// Interrupt structure 2 mode 0 is selected.
   65:   //// Interrupt service routine choice 2 is selected.
   66:   //   globally enable interrupts
   67:   EA            =  1;           
0006B2 D2AF              SETB     EA
   68: 
   69: } 
0006B4 22                RET      
----- FUNCTION MAIN_vInit (END) -------


----- FUNCTION IO_vInit (BEGIN) -----
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  10:04:31  PAGE 2


 FILE: 'IO.C'
   49: void IO_vInit(void)
   50: {
   51: 	#ifdef STARTER_KIT_EMU
   52: 		P1_DIR        		= 0x04; 
   53: 		P1_DATA       		= 0x00;
   54: 		P3_DIR			  		= 0xFF;
   55: 		P3_DATA						= 0x00;
   56: 	#else
   57: 
   58: 		///  -----------------------------------------------------------------------
   59: 		///  Configuration of Port P0:
   60: 		///  -----------------------------------------------------------------------
   61: 		///  - no pin of port P0 is used
   62: 
   63: 
   64: 		///  -----------------------------------------------------------------------
   65: 		///  Configuration of Port P1:
   66: 		///  -----------------------------------------------------------------------
   67: 		///  P1.0:
   68: 		///  - is used as general purpose output
   69: 		///  - push/pull output is selected
   70: 		///  - the pin status is low level
   71: 		///  - pull-up device is assigned
   72: 		///  P1.1:
   73: 		///  - is used as general purpose output
   74: 		///  - push/pull output is selected
   75: 		///  - the pin status is low level
   76: 		///  - pull-up device is assigned
   77: 		///  P1.2:
   78: 		///  - is used as general purpose output
   79: 		///  - push/pull output is selected
   80: 		///  - the pin status is low level
   81: 		///  - pull-up device is assigned
   82: 		///  P1.3:
   83: 		///  - is used as general purpose output
   84: 		///  - push/pull output is selected
   85: 		///  - the pin status is low level
   86: 		///  - pull-up device is assigned
   87: 		///  P1.4:
   88: 		///  - is used as general purpose output
   89: 		///  - push/pull output is selected
   90: 		///  - the pin status is low level
   91: 		///  - pull-up device is assigned
   92: 		///  P1.5:
   93: 		///  - is used as general purpose output
   94: 		///  - push/pull output is selected
   95: 		///  - the pin status is low level
   96: 		///  - pull-up device is assigned
   97: 
   98: 
   99: 		P1_DIR        =  0x3F;         // load direction register
0006B5 75913F            MOV      P1_DIR,#03FH
  100: 
  101: 		///  -----------------------------------------------------------------------
  102: 		///  Configuration of Port P2:
  103: 		///  -----------------------------------------------------------------------
  104: 		///  - no pin of port P2 is used
  105: 
  106: 
  107: 		///  -----------------------------------------------------------------------
  108: 		///  Configuration of Port P3:
  109: 		///  -----------------------------------------------------------------------
  110: 		///  P3.4:
  111: 		///  - is used as general purpose output
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  10:04:31  PAGE 3


  112: 		///  - push/pull output is selected
  113: 		///  - the pin status is low level
  114: 		///  - pull device is disabled (tristate) 
  115: 		///  P3.5:
  116: 		///  - is used as general purpose output
  117: 		///  - push/pull output is selected
  118: 		///  - the pin status is low level
  119: 		///  - pull device is disabled (tristate) 
  120: 		///  P3.6:
  121: 		///  - is used as general purpose output
  122: 		///  - push/pull output is selected
  123: 		///  - the pin status is low level
  124: 		///  - pull device is disabled (tristate) 
  125: 		///  P3.7:
  126: 		///  - is used as general purpose output
  127: 		///  - push/pull output is selected
  128: 		///  - the pin status is low level
  129: 		///  - pull device is disabled (tristate) 
  130: 
  131: 
  132: 		P3_DIR        =  0xF0;         // load direction register
0006B8 75B1F0            MOV      P3_DIR,#0F0H
  133: 
  134: 		///  -----------------------------------------------------------------------
  135: 		///  Configuration of Port P4:
  136: 		///  -----------------------------------------------------------------------
  137: 		///  P4.0:
  138: 		///  - is used as general input
  139: 		///  - pull device is disabled (tristate) 
  140: 		///  P4.1:
  141: 		///  - is used as general input
  142: 		///  - pull device is disabled (tristate) 
  143: 		///  P4.2:
  144: 		///  - is used as general input
  145: 		///  - pull-up device is assigned
  146: 		///  P4.3:
  147: 		///  - is used as general input
  148: 		///  - pull device is disabled (tristate) 
  149: 		///  P4.4:
  150: 		///  - is used as general input
  151: 		///  - pull device is disabled (tristate) 
  152: 		///  P4.5:
  153: 		///  - is used as general input
  154: 		///  - pull device is disabled (tristate) 
  155: 
  156: 
  157: 		///  -----------------------------------------------------------------------
  158: 		///  Configuration of Port P5:
  159: 		///  -----------------------------------------------------------------------
  160: 		///  - no pin of port P5 is used
  161: 	#endif
  162: 
  163: } //  End of function IO_vInit
0006BB 22                RET      
----- FUNCTION IO_vInit (END) -------


----- FUNCTION main (BEGIN) -----
 FILE: 'MAIN.C'
   79: void main(void)
   80: {
   81:   MAIN_vInit();
   82: 	
0006BC D19B              ACALL    MAIN_vInit
0006BE         ?C0012?MAIN:
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  10:04:31  PAGE 4


   83:   while(1) {
   84: 		
   85: 		if (shouldMonitorHVStatus && !isAllHVRelayOK()) {
0006BE 30030C            JNB      shouldMonitorHVStatus,?C0014?MAIN
0006C1 F1FB              ACALL    isAllHVRelayOK
0006C3 4008              JC       ?C0014?MAIN
   86: 			sendUART("HV_NG\r\n");
0006C5 7BFF              MOV      R3,#0FFH
0006C7 7A00              MOV      R2,#HIGH 01000018H
0006C9 7918              MOV      R1,#LOW 01000018H
0006CB D1DE              ACALL    _sendUART
   87: 		}
0006CD         ?C0014?MAIN:
   88: 			
   89: 		delay(1);
0006CD 7F01              MOV      R7,#01H
0006CF 7E00              MOV      R6,#00H
0006D1 120812            LCALL    _delay
   90: 	}
0006D4 80E8              SJMP     ?C0012?MAIN
----- FUNCTION main (END) -------


----- FUNCTION ?L?COM0001 (BEGIN) -----
0006D6 D1DE              ACALL    _sendUART
0006D8 7B01              MOV      R3,#01H
0006DA 7AF0              MOV      R2,#HIGH uuidString
0006DC 79C8              MOV      R1,#LOW uuidString
----- FUNCTION _sendUART (BEGIN) -----
 FILE: 'UART.C'
  133: void sendUART(char * message) {
  134: 	char * current = message;
;---- Variable 'message' assigned to Register 'R1/R2/R3' ----
  135: 	while (*current != '\0') {
;---- Variable 'current' assigned to Register 'R1/R2/R3' ----
0006DE         ?C0002?UART:
  136: 		SBUF = *current;
0006DE 311C              ACALL    ?C?CLDPTR
0006E0 6010              JZ       ?C0006?UART
  137: 		while (TI == 0);
0006E2 F599              MOV      SBUF,A
0006E4         ?C0004?UART:
  138: 		TI = 0;		
0006E4 3099FD            JNB      TI,?C0004?UART
0006E7         ?C0005?UART:
  139: 		current++;
0006E7 C299              CLR      TI
  140: 	}
0006E9 7401              MOV      A,#01H
0006EB 29                ADD      A,R1
0006EC F9                MOV      R1,A
0006ED E4                CLR      A
0006EE 3A                ADDC     A,R2
0006EF FA                MOV      R2,A
  141: }
0006F0 80EC              SJMP     ?C0002?UART
  142: 
0006F2         ?C0006?UART:
0006F2 22                RET      
----- FUNCTION _sendUART (END) -------


----- FUNCTION sendHVRelayStatus (BEGIN) -----
 FILE: 'DeviceController.c'
   95: void sendHVRelayStatus() {
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  10:04:31  PAGE 5


   96: 	if (IO_ubReadPin(HV_READY_1)) {
   97: 		sendUART("HV_READY_1: OK\n");
0006F3 7BFF              MOV      R3,#0FFH
0006F5 30C806            JNB      P4_0,?C0019?DEVICECONTROLLER
   98: 	} else {
0006F8 7A02              MOV      R2,#HIGH 010002B6H
0006FA 79B6              MOV      R1,#LOW 010002B6H
   99: 		sendUART("HV_READY_1: NG\n");
0006FC 8004              SJMP     ?C0056?DEVICECONTROLLER
0006FE         ?C0019?DEVICECONTROLLER:
  100: 	}
0006FE 7A02              MOV      R2,#HIGH 010002C6H
000700 79C6              MOV      R1,#LOW 010002C6H
000702         
000702 D1DE              ACALL    _sendUART
  101: 	
000704         ?C0020?DEVICECONTROLLER:
  102: 	if (IO_ubReadPin(HV_READY_2)) {
000704 7BFF              MOV      R3,#0FFH
000706 30CA06            JNB      P4_2,?C0021?DEVICECONTROLLER
  103: 		sendUART("HV_READY_2: OK\n");
000709 7A02              MOV      R2,#HIGH 010002D6H
00070B 79D6              MOV      R1,#LOW 010002D6H
  104: 	} else {
00070D 8004              SJMP     ?C0057?DEVICECONTROLLER
00070F         ?C0021?DEVICECONTROLLER:
  105: 		sendUART("HV_READY_2: NG\n");
00070F 7A02              MOV      R2,#HIGH 010002E6H
000711 79E6              MOV      R1,#LOW 010002E6H
000713         
000713 D1DE              ACALL    _sendUART
  106: 	}
000715         ?C0022?DEVICECONTROLLER:
  107: 
  108: 	if (IO_ubReadPin(HV_READY_3)) {
000715 7BFF              MOV      R3,#0FFH
000717 30CC06            JNB      P4_4,?C0023?DEVICECONTROLLER
  109: 		sendUART("HV_READY_3: OK\n");
00071A 7A02              MOV      R2,#HIGH 010002F6H
00071C 79F6              MOV      R1,#LOW 010002F6H
  110: 	} else {
00071E 8004              SJMP     ?C0058?DEVICECONTROLLER
000720         ?C0023?DEVICECONTROLLER:
  111: 		sendUART("HV_READY_3: NG\n");
000720 7A03              MOV      R2,#HIGH 01000306H
000722 7906              MOV      R1,#LOW 01000306H
000724         
000724 D1DE              ACALL    _sendUART
  112: 	}
000726         ?C0024?DEVICECONTROLLER:
  113: 	
  114: 	if (IO_ubReadPin(HV_FAULT_1)) {
000726 7BFF              MOV      R3,#0FFH
000728 30C906            JNB      P4_1,?C0025?DEVICECONTROLLER
  115: 		sendUART("HV_FAULT_1: OK\n");
00072B 7A03              MOV      R2,#HIGH 01000316H
00072D 7916              MOV      R1,#LOW 01000316H
  116: 	} else {
00072F 8004              SJMP     ?C0059?DEVICECONTROLLER
000731         ?C0025?DEVICECONTROLLER:
  117: 		sendUART("HV_FAULT_1: NG\n");
000731 7A03              MOV      R2,#HIGH 01000326H
000733 7926              MOV      R1,#LOW 01000326H
000735         
000735 D1DE              ACALL    _sendUART
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  10:04:31  PAGE 6


  118: 	}
000737         ?C0026?DEVICECONTROLLER:
  119: 
  120: 	if (IO_ubReadPin(HV_FAULT_2)) {
000737 7BFF              MOV      R3,#0FFH
000739 30CB06            JNB      P4_3,?C0027?DEVICECONTROLLER
  121: 		sendUART("HV_FAULT_2: OK\n");
00073C 7A03              MOV      R2,#HIGH 01000336H
00073E 7936              MOV      R1,#LOW 01000336H
  122: 	} else {
000740 8004              SJMP     ?C0060?DEVICECONTROLLER
000742         ?C0027?DEVICECONTROLLER:
  123: 		sendUART("HV_FAULT_2: NG\n");
000742 7A03              MOV      R2,#HIGH 01000346H
000744 7946              MOV      R1,#LOW 01000346H
000746         
000746 D1DE              ACALL    _sendUART
  124: 	}
000748         ?C0028?DEVICECONTROLLER:
  125: 	
  126: 	if (IO_ubReadPin(HV_FAULT_3)) {
000748 7BFF              MOV      R3,#0FFH
00074A 30CD06            JNB      P4_5,?C0029?DEVICECONTROLLER
  127: 		sendUART("HV_FAULT_3: OK\n");
00074D 7A03              MOV      R2,#HIGH 01000356H
00074F 7956              MOV      R1,#LOW 01000356H
  128: 	} else {
000751 8004              SJMP     ?C0061?DEVICECONTROLLER
000753         ?C0029?DEVICECONTROLLER:
  129: 		sendUART("HV_FAULT_3: NG\n");
000753 7A03              MOV      R2,#HIGH 01000366H
000755 7966              MOV      R1,#LOW 01000366H
000757         
000757 D1DE              ACALL    _sendUART
  130: 	}
000759         ?C0030?DEVICECONTROLLER:
  131: 	
  132: 	
  133: 	if (isAllHVRelayOK()) {
000759 F1FB              ACALL    isAllHVRelayOK
00075B 7BFF              MOV      R3,#0FFH
00075D 5006              JNC      ?C0031?DEVICECONTROLLER
  134: 		sendUART("#d#1#\n");
00075F 7A03              MOV      R2,#HIGH 01000376H
000761 7976              MOV      R1,#LOW 01000376H
  135: 	} else {
000763 8004              SJMP     ?C0062?DEVICECONTROLLER
000765         ?C0031?DEVICECONTROLLER:
  136: 		sendUART("#d#0#\n");		
000765 7A03              MOV      R2,#HIGH 0100037DH
000767 797D              MOV      R1,#LOW 0100037DH
000769         
000769 C1DE              AJMP     _sendUART
  137: 	}
----- FUNCTION sendHVRelayStatus (END) -------


----- FUNCTION _setUUID (BEGIN) -----
 FILE: 'DeviceController.c'
  181: void setUUID(char * command) {
  182: 	unsigned char code * flashEndAddress = getFlashDataEndAddress();	
00076B 8B44              MOV      command,R3
00076D 8A45              MOV      command+01H,R2
00076F 8946              MOV      command+02H,R1
  183: 	char xdata uuidString[37] = {0};
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  10:04:31  PAGE 7


000771 120D16            LCALL    getFlashDataEndAddress
000774 8E47              MOV      flashEndAddress,R6
000776 8F48              MOV      flashEndAddress+01H,R7
  184: 	strncpy(uuidString, command+3, 36);
000778 78C8              MOV      R0,#LOW uuidString
00077A 7CF0              MOV      R4,#HIGH uuidString
00077C 7D01              MOV      R5,#01H
00077E 7BFF              MOV      R3,#0FFH
000780 7A04              MOV      R2,#HIGH _?ix1000
000782 7905              MOV      R1,#LOW _?ix1000
000784 7E00              MOV      R6,#00H
000786 7F25              MOV      R7,#025H
000788 11F6              ACALL    ?C?COPY
  185: 	sendUART("Setting UUID to ");
00078A E546              MOV      A,command+02H
00078C 2403              ADD      A,#03H
00078E F9                MOV      R1,A
00078F E4                CLR      A
000790 3545              ADDC     A,command+01H
000792 85444C            MOV      ?_strncpy?BYTE+03H,command
000795 F54D              MOV      ?_strncpy?BYTE+04H,A
000797 894E              MOV      ?_strncpy?BYTE+05H,R1
000799 754F00            MOV      ?_strncpy?BYTE+06H,#00H
00079C 755024            MOV      ?_strncpy?BYTE+07H,#024H
00079F 7B01              MOV      R3,#01H
0007A1 7AF0              MOV      R2,#HIGH uuidString
0007A3 79C8              MOV      R1,#LOW uuidString
0007A5 D129              ACALL    _strncpy
  186: 	sendUART(uuidString);
0007A7 7BFF              MOV      R3,#0FFH
0007A9 7A03              MOV      R2,#HIGH 010003D9H
0007AB 79D9              MOV      R1,#LOW 010003D9H
0007AD D1D6              ACALL    ?L?COM0001
  187: 	sendUART("....\n");
0007AF 7BFF              MOV      R3,#0FFH
0007B1 7A03              MOV      R2,#HIGH 010003EAH
0007B3 79EA              MOV      R1,#LOW 010003EAH
0007B5 D1DE              ACALL    _sendUART
  188: 	sendUART("Please wait...");
0007B7 7BFF              MOV      R3,#0FFH
0007B9 7A03              MOV      R2,#HIGH 010003F0H
0007BB 79F0              MOV      R1,#LOW 010003F0H
0007BD D1DE              ACALL    _sendUART
  189: 	writeBufferToFlash(uuidString, &flashEndAddress);
0007BF 754C00            MOV      ?_writeBufferToFlash?BYTE+03H,#00H
0007C2 754D00            MOV      ?_writeBufferToFlash?BYTE+04H,#HIGH flashEndAddress
0007C5 754E47            MOV      ?_writeBufferToFlash?BYTE+05H,#LOW flashEndAddress
0007C8 7B01              MOV      R3,#01H
0007CA 7AF0              MOV      R2,#HIGH uuidString
0007CC 79C8              MOV      R1,#LOW uuidString
0007CE 120897            LCALL    _writeBufferToFlash
  190: 	sendUART("DONE\n");
0007D1 7BFF              MOV      R3,#0FFH
0007D3 7A03              MOV      R2,#HIGH 010003FFH
0007D5 79FF              MOV      R1,#LOW 010003FFH
0007D7 C1DE              AJMP     _sendUART
----- FUNCTION _setUUID (END) -------


----- FUNCTION sendUUID (BEGIN) -----
 FILE: 'DeviceController.c'
    8: void sendUUID() {
    9: 	char xdata uuidString[50];
   10: 	unsigned char code * currentFlashDataEndAddress = getFlashDataEndAddress();
0007D9 120D16            LCALL    getFlashDataEndAddress
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  10:04:31  PAGE 8


;---- Variable 'currentFlashDataEndAddress' assigned to Register 'R2/R3' ----
0007DC AB07              MOV      R3,AR7
0007DE AA06              MOV      R2,AR6
   11: 	readFlashToBuffer(uuidString, 50, currentFlashDataEndAddress);
0007E0 7EF0              MOV      R6,#HIGH uuidString
0007E2 7FC8              MOV      R7,#LOW uuidString
0007E4 7D32              MOV      R5,#032H
0007E6 7C00              MOV      R4,#00H
0007E8 120C83            LCALL    _readFlashToBuffer
   12: 	sendUART("#f#");
0007EB 7BFF              MOV      R3,#0FFH
0007ED 7A02              MOV      R2,#HIGH 01000248H
0007EF 7948              MOV      R1,#LOW 01000248H
0007F1 D1D6              ACALL    ?L?COM0001
   13: 	sendUART(uuidString);
   14: 	sendUART("#\n");
0007F3 7BFF              MOV      R3,#0FFH
0007F5 7A02              MOV      R2,#HIGH 0100024CH
0007F7 794C              MOV      R1,#LOW 0100024CH
0007F9 C1DE              AJMP     _sendUART
----- FUNCTION sendUUID (END) -------


----- FUNCTION isAllHVRelayOK (BEGIN) -----
 FILE: 'DeviceController.c'
   81: bool isAllHVRelayOK() {
   82: 	#ifdef STARTER_KIT_EMU
   83: 		return IO_ubReadPin(HV_READY_1);
   84: 	#else
   85: 		return 
0007FB 30C812            JNB      P4_0,?C0016?DEVICECONTROLLER
0007FE 30CA0F            JNB      P4_2,?C0016?DEVICECONTROLLER
000801 30CC0C            JNB      P4_4,?C0016?DEVICECONTROLLER
000804 30C909            JNB      P4_1,?C0016?DEVICECONTROLLER
000807 30CB06            JNB      P4_3,?C0016?DEVICECONTROLLER
00080A 30CD03            JNB      P4_5,?C0016?DEVICECONTROLLER
00080D D3                SETB     C
00080E 8001              SJMP     ?C0017?DEVICECONTROLLER
000810         ?C0016?DEVICECONTROLLER:
000810 C3                CLR      C
000811         ?C0017?DEVICECONTROLLER:
   86: 			IO_ubReadPin(HV_READY_1) &&
   87: 			IO_ubReadPin(HV_READY_2) &&
   88: 			IO_ubReadPin(HV_READY_3) &&
   89: 			IO_ubReadPin(HV_FAULT_1) &&
   90: 			IO_ubReadPin(HV_FAULT_2) &&
   91: 			IO_ubReadPin(HV_FAULT_3);
   92: 	#endif
   93: }
000811 22                RET      
----- FUNCTION isAllHVRelayOK (END) -------


----- FUNCTION _delay (BEGIN) -----
 FILE: 'MAIN.C'
   70: void delay(int second) {
   71:   int i, j, k;
;---- Variable 'second' assigned to Register 'R6/R7' ----
   72:   for (i = 0; i < second; i++) {
;---- Variable 'i' assigned to Register 'R4/R5' ----
000812 E4                CLR      A
000813 FD                MOV      R5,A
000814 FC                MOV      R4,A
000815         ?C0002?MAIN:
000815 C3                CLR      C
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  10:04:31  PAGE 9


000816 ED                MOV      A,R5
000817 9F                SUBB     A,R7
000818 EE                MOV      A,R6
000819 6480              XRL      A,#080H
00081B F8                MOV      R0,A
00081C EC                MOV      A,R4
00081D 6480              XRL      A,#080H
00081F 98                SUBB     A,R0
000820 5023              JNC      ?C0011?MAIN
   73:     for (j = 0; j < 25; j++) {
;---- Variable 'j' assigned to Register 'R2/R3' ----
000822 E4                CLR      A
000823 FB                MOV      R3,A
000824 FA                MOV      R2,A
000825         ?C0005?MAIN:
   74:       for (k = 0; k < 30000; k++) {
;---- Variable 'k' assigned to Register 'DPTR' ----
000825 900000            MOV      DPTR,#00H
000828         ?C0008?MAIN:
   75:       }
000828 A3                INC      DPTR
000829 E582              MOV      A,DPL
00082B B430FA            CJNE     A,#030H,?C0008?MAIN
00082E E583              MOV      A,DPH
000830 B475F5            CJNE     A,#075H,?C0008?MAIN
   76:     }
000833         ?C0007?MAIN:
000833 0B                INC      R3
000834 BB0001            CJNE     R3,#00H,?C0017?MAIN
000837 0A                INC      R2
000838         ?C0017?MAIN:
000838 EB                MOV      A,R3
000839 6419              XRL      A,#019H
00083B 4A                ORL      A,R2
00083C 70E7              JNZ      ?C0005?MAIN
   77:   }
00083E         ?C0004?MAIN:
00083E 0D                INC      R5
00083F BD0001            CJNE     R5,#00H,?C0018?MAIN
000842 0C                INC      R4
000843         ?C0018?MAIN:
000843 80D0              SJMP     ?C0002?MAIN
   78: }
000845         ?C0011?MAIN:
000845 22                RET      
----- FUNCTION _delay (END) -------


----- FUNCTION _writeToFlashPage (BEGIN) -----
 FILE: 'FlashUtils.c'
   29: void writeToFlashPage(char xdata * buffer, unsigned char code ** EECurrentAddr) {
   30: 	int i = 0;
000846 8E54              MOV      buffer,R6
000848 8F55              MOV      buffer+01H,R7
00084A 8B56              MOV      EECurrentAddr,R3
00084C 8A57              MOV      EECurrentAddr+01H,R2
00084E 8958              MOV      EECurrentAddr+02H,R1
   31: 
;---- Variable 'i' assigned to Register 'R6/R7' ----
000850 E4                CLR      A
000851 FF                MOV      R7,A
000852 FE                MOV      R6,A
   32: 	for (i=0; i < BYTES_PER_WORDLINE; i++) {
000853         ?C0006?FLASHUTILS:
   33: 		WLBuf[i] = *buffer;
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  10:04:31  PAGE 10


000853 855582            MOV      DPL,buffer+01H
000856 855483            MOV      DPH,buffer
000859 E0                MOVX     A,@DPTR
00085A FD                MOV      R5,A
00085B 74E0              MOV      A,#LOW WLBuf
00085D 2F                ADD      A,R7
00085E F8                MOV      R0,A
00085F A605              MOV      @R0,AR5
   34: 		buffer++;
000861 0555              INC      buffer+01H
000863 E555              MOV      A,buffer+01H
000865 7002              JNZ      ?C0023?FLASHUTILS
000867 0554              INC      buffer
000869         ?C0023?FLASHUTILS:
   35: 	}
000869 0F                INC      R7
00086A BF0001            CJNE     R7,#00H,?C0024?FLASHUTILS
00086D 0E                INC      R6
00086E         ?C0024?FLASHUTILS:
00086E EF                MOV      A,R7
00086F 6420              XRL      A,#020H
000871 4E                ORL      A,R6
000872 70DF              JNZ      ?C0006?FLASHUTILS
000874         ?C0007?FLASHUTILS:
   36: 
   37: 	// Start the Flash Programming
   38: 	if (FLASH_Prog(*EECurrentAddr)) 
000874 AB56              MOV      R3,EECurrentAddr
000876 AA57              MOV      R2,EECurrentAddr+01H
000878 A958              MOV      R1,EECurrentAddr+02H
00087A 120162            LCALL    ?C?ILDPTR
00087D FF                MOV      R7,A
00087E AEF0              MOV      R6,B
000880 314E              ACALL    _FLASH_Prog
000882 500D              JNC      ?C0009?FLASHUTILS
   39: 	{
   40: 		*EECurrentAddr = *EECurrentAddr + BYTES_PER_WORDLINE;
000884 AB56              MOV      R3,EECurrentAddr
000886 AA57              MOV      R2,EECurrentAddr+01H
000888 A958              MOV      R1,EECurrentAddr+02H
00088A E4                CLR      A
00088B 75F020            MOV      B,#020H
00088E 12018D            LCALL    ?C?IILDPTR
   41: 	}
000891         ?C0009?FLASHUTILS:
   42: 	delay(2);
000891 7F02              MOV      R7,#02H
000893 7E00              MOV      R6,#00H
000895 0112              AJMP     _delay
----- FUNCTION _writeToFlashPage (END) -------


----- FUNCTION _writeBufferToFlash (BEGIN) -----
 FILE: 'FlashUtils.c'
   68: void writeBufferToFlash(char * buffer, unsigned char code ** EECurrentAddr) {
   69: 	char xdata pageBuffer[BYTES_PER_WORDLINE] = {0};
000897 8B49              MOV      buffer,R3
000899 8A4A              MOV      buffer+01H,R2
00089B 894B              MOV      buffer+02H,R1
   70: 	char * currentCharacter = buffer;
00089D 78ED              MOV      R0,#LOW pageBuffer
00089F 7CF0              MOV      R4,#HIGH pageBuffer
0008A1 7D01              MOV      R5,#01H
0008A3 7BFF              MOV      R3,#0FFH
0008A5 7A06              MOV      R2,#HIGH _?ix1000
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  10:04:31  PAGE 11


0008A7 797B              MOV      R1,#LOW _?ix1000
0008A9 7E00              MOV      R6,#00H
0008AB 7F20              MOV      R7,#020H
0008AD 1200F6            LCALL    ?C?COPY
   71: 	int i = 0;
0008B0 85494F            MOV      currentCharacter,buffer
0008B3 854A50            MOV      currentCharacter+01H,buffer+01H
0008B6 854B51            MOV      currentCharacter+02H,buffer+02H
   72: 	
0008B9 E4                CLR      A
0008BA F552              MOV      i,A
0008BC F553              MOV      i+01H,A
   73: 	FLASH_Erase(SECALL,0);
0008BE FD                MOV      R5,A
0008BF FC                MOV      R4,A
0008C0 7FFF              MOV      R7,#0FFH
0008C2 7E03              MOV      R6,#03H
0008C4 3166              ACALL    _FLASH_Erase
   74: 	*EECurrentAddr = (unsigned char code*)FLASH_FIRST_ADDR;			// if erase than 1. WL is current
0008C6 AB4C              MOV      R3,EECurrentAddr
0008C8 AA4D              MOV      R2,EECurrentAddr+01H
0008CA A94E              MOV      R1,EECurrentAddr+02H
0008CC 74A0              MOV      A,#0A0H
0008CE 75F000            MOV      B,#00H
0008D1 1201C5            LCALL    ?C?ISTPTR
   75:   delay(2);
0008D4 7F02              MOV      R7,#02H
0008D6 7E00              MOV      R6,#00H
0008D8 1112              ACALL    _delay
   76: 	
   77: 	memset(pageBuffer, 0, BYTES_PER_WORDLINE);
0008DA 7E00              MOV      R6,#00H
0008DC 7F20              MOV      R7,#020H
0008DE 7D00              MOV      R5,#00H
0008E0 7B01              MOV      R3,#01H
0008E2 7AF0              MOV      R2,#HIGH pageBuffer
0008E4 79ED              MOV      R1,#LOW pageBuffer
0008E6 1201E4            LCALL    ?C?MEMSET
0008E9         ?C0018?FLASHUTILS:
   78: 	while (*currentCharacter != 0) {
0008E9 AB4F              MOV      R3,currentCharacter
0008EB AA50              MOV      R2,currentCharacter+01H
0008ED A951              MOV      R1,currentCharacter+02H
0008EF 12011C            LCALL    ?C?CLDPTR
0008F2 FF                MOV      R7,A
0008F3 604D              JZ       ?C0019?FLASHUTILS
   79: 		
   80: 		pageBuffer[i] = *currentCharacter;
0008F5 74ED              MOV      A,#LOW pageBuffer
0008F7 2553              ADD      A,i+01H
0008F9 F582              MOV      DPL,A
0008FB 74F0              MOV      A,#HIGH pageBuffer
0008FD 3552              ADDC     A,i
0008FF F583              MOV      DPH,A
000901 EF                MOV      A,R7
000902 F0                MOVX     @DPTR,A
   81: 		if (i == 25) {
000903 E553              MOV      A,i+01H
000905 6419              XRL      A,#019H
000907 4552              ORL      A,i
000909 7022              JNZ      ?C0020?FLASHUTILS
   82: 			writeToFlashPage(pageBuffer, EECurrentAddr);
00090B 7EF0              MOV      R6,#HIGH pageBuffer
00090D 7FED              MOV      R7,#LOW pageBuffer
00090F AB4C              MOV      R3,EECurrentAddr
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  10:04:31  PAGE 12


000911 AA4D              MOV      R2,EECurrentAddr+01H
000913 A94E              MOV      R1,EECurrentAddr+02H
000915 1146              ACALL    _writeToFlashPage
   83: 			memset(pageBuffer, 0, BYTES_PER_WORDLINE);
000917 7E00              MOV      R6,#00H
000919 7F20              MOV      R7,#020H
00091B 7D00              MOV      R5,#00H
00091D 7B01              MOV      R3,#01H
00091F 7AF0              MOV      R2,#HIGH pageBuffer
000921 79ED              MOV      R1,#LOW pageBuffer
000923 1201E4            LCALL    ?C?MEMSET
   84: 			i = 0;
000926 E4                CLR      A
000927 F552              MOV      i,A
000929 F553              MOV      i+01H,A
   85: 		} else {
00092B 8008              SJMP     ?C0021?FLASHUTILS
00092D         ?C0020?FLASHUTILS:
   86: 			i++;
00092D 0553              INC      i+01H
00092F E553              MOV      A,i+01H
000931 7002              JNZ      ?C0027?FLASHUTILS
000933 0552              INC      i
000935         ?C0027?FLASHUTILS:
   87: 		}
000935         ?C0021?FLASHUTILS:
   88: 		currentCharacter++;
000935 7401              MOV      A,#01H
000937 2551              ADD      A,currentCharacter+02H
000939 F551              MOV      currentCharacter+02H,A
00093B E4                CLR      A
00093C 3550              ADDC     A,currentCharacter+01H
00093E F550              MOV      currentCharacter+01H,A
   89: 	}
000940 80A7              SJMP     ?C0018?FLASHUTILS
000942         ?C0019?FLASHUTILS:
   90: 	writeToFlashPage(pageBuffer, EECurrentAddr);	
000942 7EF0              MOV      R6,#HIGH pageBuffer
000944 7FED              MOV      R7,#LOW pageBuffer
000946 AB4C              MOV      R3,EECurrentAddr
000948 AA4D              MOV      R2,EECurrentAddr+01H
00094A A94E              MOV      R1,EECurrentAddr+02H
00094C 0146              AJMP     _writeToFlashPage
----- FUNCTION _writeBufferToFlash (END) -------


----- FUNCTION _FLASH_Prog (BEGIN) -----
 FILE: 'FlashHandler.c'
  115: bit FLASH_Prog					(unsigned char code* WLAddress) 
  116: {
;---- Variable 'WLAddress' assigned to Register 'R6/R7' ----
  117: #ifdef	XC88x
  118: 	volatile bit success;		    // needed for CY flag saving of the BROM routine's result
  119: #endif	// XC88x
  120: #ifdef	XC866
  121: #define USE_BANK  3					// fix the used registerbank to 3 for XC866 devices
  122: #endif	// XC866
  123: 									// For SDCC parameter is now already in DPTR
  124: #ifdef SDCC
  125: 	*WLAddress;						// avoid warning of 'unreferenced function argument
  126: #endif	// SDCC
  127: #ifdef __C51__
  128:    DPTR = (unsigned int)WLAddress;
00094E 8E83              MOV      DPH,R6
000950 8F82              MOV      DPL,R7
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  10:04:31  PAGE 13


  129: #endif	// __C51__
  130: 
  131:    REG[(0+(USE_BANK*8))] = WORDLINE_BUFFER_ADDRESS;
000952 7818              MOV      R0,#018H
000954 76E0              MOV      @R0,#0E0H
  132: #ifdef	XC88x
  133: 	PUSH(PSW);
000956 C0D0              PUSH     PSW
  134: 	PSW = ((USE_BANK)<<3);
000958 75D018            MOV      PSW,#018H
  135: #endif	// XC88x
  136: 
  137: #ifdef	__C51__		
  138: 	((void (code *) (void)) FLASH_PROG) ();
00095B 12DFF6            LCALL    0DFF6H
  139: #endif	// __C51__
  140: #ifdef	SDCC
  141: _asm
  142: 	LCALL FLASH_PROG;
  143: _endasm;
  144: #endif	// SDCC
  145: 
  146: #ifdef	XC88x
  147: 	success = CY;
00095E 9202              MOV      success,C
  148: 	POP(PSW);
000960 D0D0              POP      PSW
  149: 	return(!success);			  
000962 A202              MOV      C,success
000964 B3                CPL      C
  150: #endif	// XC88x
  151: #ifdef	XC866
  152: 	return (!CY);
  153: #endif	// XC866
  154: }
000965 22                RET      
----- FUNCTION _FLASH_Prog (END) -------


----- FUNCTION _FLASH_Erase (BEGIN) -----
 FILE: 'FlashHandler.c'
  163: bit FLASH_Erase			(unsigned int DFlash0Sector,unsigned int DFlash1Sector)
  164: #endif	// XC88x
;---- Variable 'DFlash1Sector' assigned to Register 'R4/R5' ----
;---- Variable 'DFlash0Sector' assigned to Register 'R6/R7' ----
  165: {
  166: #ifdef	XC88x
  167:     volatile bit success; 
  168: #endif	// XC88x
  169: 	t_unFLPARAM P1;
  170: #ifdef	XC88x
  171: 	t_unFLPARAM P2;
  172: #endif	// XC88x
  173: 
  174: #ifdef	XC866
  175: #define USE_BANK  3								// fix the used registerbank to 3 for XC866 devices
  176: #endif	// XC866
  177: 
  178: 	P1.UINT_Param = DFlash0Sector;
000966 8E54              MOV      P1,R6
000968 8F55              MOV      P1+01H,R7
  179: #ifdef	XC88x
  180: 	P2.UINT_Param = DFlash1Sector;
00096A 8C56              MOV      P2,R4
00096C 8D57              MOV      P2+01H,R5
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  10:04:31  PAGE 14


  181: #endif	// XC88x
  182: 	
  183: #ifdef	XC866
  184: 	REG[(4+(USE_BANK*8))] = P1.UBYTE_Param[0];	// DFLASH0 Sector - BANK3 - High Adr Byte
  185: 	REG[(3+(USE_BANK*8))] = P1.UBYTE_Param[1];	// DFLASH0 Sector - BANK3 - Low  Adr Byte
  186: #endif	// XC866
  187: #ifdef	XC88x
  188: 	REG[(1+(USE_BANK*8))] = P1.UBYTE_Param[0];	// DFLASH0 Sector -         High Adr Byte
00096E 7819              MOV      R0,#019H
000970 A654              MOV      @R0,P1
  189: 	REG[(0+(USE_BANK*8))] = P1.UBYTE_Param[1];	// DFLASH0 Sector -         Low  Adr Byte
000972 18                DEC      R0
000973 A655              MOV      @R0,P1+01H
  190: 	REG[(4+(USE_BANK*8))] = P2.UBYTE_Param[0];	// DFLASH1 Sector  
000975 781C              MOV      R0,#01CH
000977 A656              MOV      @R0,P2
  191: 	REG[(3+(USE_BANK*8))] = P2.UBYTE_Param[1];	// DFLASH1 Sector  
000979 18                DEC      R0
00097A A657              MOV      @R0,P2+01H
  192: #endif	// XC88x
  193: 	REG[(5+(USE_BANK*8))] = 0;					// PFLASH  
00097C 781D              MOV      R0,#01DH
00097E E4                CLR      A
00097F F6                MOV      @R0,A
  194: 	REG[(6+(USE_BANK*8))] = 0;					// PFLASH  
000980 08                INC      R0
000981 F6                MOV      @R0,A
  195: 	REG[(7+(USE_BANK*8))] = 0;					// PFLASH  
000982 08                INC      R0
000983 F6                MOV      @R0,A
  196: 
  197: #ifdef XC88x
  198: 	PUSH(PSW);
000984 C0D0              PUSH     PSW
  199: 	PSW = ((USE_BANK)<<3);
000986 75D018            MOV      PSW,#018H
  200: #endif	// XC88x
  201: 
  202: #ifdef	__C51__
  203: 	((void (code *) (void)) FLASH_ERASE) ();
000989 12DFF9            LCALL    0DFF9H
  204: #endif	// __C51__
  205: #ifdef	SDCC
  206: _asm
  207: 	LCALL FLASH_ERASE;
  208: _endasm;
  209: #endif	// SDCC
  210: 
  211: #ifdef	XC866
  212: 	return(!CY);
  213: #endif	// XC866
  214: #ifdef	XC88x
  215: 	success = CY;
00098C 9202              MOV      success,C
  216: 	POP(PSW);
00098E D0D0              POP      PSW
  217: 	return (!success);
000990 A202              MOV      C,success
000992 B3                CPL      C
  218: #endif	// XC88x
  219: }
000993 22                RET      
----- FUNCTION _FLASH_Erase (END) -------


LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  10:04:31  PAGE 15


----- FUNCTION UART_vInit (BEGIN) -----
 FILE: 'UART.C'
   60: void UART_vInit(void)
   61: {
   62:   ///  -----------------------------------------------------------------------
   63:   ///  UART settings
   64:   ///  -----------------------------------------------------------------------
   65:   ///  Pin TXD_1 (P0.2) is selected for transmission
   66:   ///  Pin RXD_1 (P0.1) is selected for reception
   67:   ///  Receiver enabled
   68:   ///  Mode 1: 8-bit data, 1 start bit, 1 stop bit, variable baud rate
   69:   ///  Receiver interrupt flag RI will only be activated if a valid stop bit 
   70:   ///  was received
   71:   ///  BRG is selected for baudrate generation
   72: 
   73:   SFR_PAGE(_pp2, noSST);         // switch to page 2 without saving
000994 75B202            MOV      PORT_PAGE,#02H
   74:   P0_ALTSEL0   &= ~(ubyte)0x04;  // configure alternate function register 0
000997 5380FB            ANL      P0_ALTSEL0,#0FBH
   75:   P0_ALTSEL1   |=  (ubyte)0x04;  // configure alternate function register 1
00099A 438604            ORL      P0_ALTSEL1,#04H
   76:   SFR_PAGE(_pp0, noSST);         // switch to page 0 without saving
00099D E4                CLR      A
00099E F5B2              MOV      PORT_PAGE,A
   77:   P0_DIR       |=  (ubyte)0x04;  // set output direction
0009A0 438604            ORL      P0_DIR,#04H
   78: 
   79: 
   80:   MODPISEL     |=  (ubyte)0x01;  // configure peripheral input select register
0009A3 43B301            ORL      MODPISEL,#01H
   81:   BCON          =  0x00;         // reset baudrate timer/reload register
0009A6 F5BD              MOV      BCON,A
   82:   SCON          =  0x70;         // load serial channel control register
0009A8 759870            MOV      SCON,#070H
   83: 
   84:   ///  -----------------------------------------------------------------------
   85:   ///  Baudrate generator settings
   86:   ///  -----------------------------------------------------------------------
   87:   ///  input clock = fPCLK
   88:   ///  Fractional divider is enabled
   89:   ///  baudrate = 9.6004 kbaud
   90: 
   91:   FDSTEP        =  0xD5;         // load fractional divider reload register
0009AB 75EAD5            MOV      FDSTEP,#0D5H
   92:   BG            =  0x81;         // load baudrate timer/reload register
0009AE 75BE81            MOV      BG,#081H
   93:   FDCON        |=  0x01;         // load Fractional Divider control register
0009B1 43E901            ORL      FDCON,#01H
   94:   BCON         |=  0x01;         // load baud rate control register
0009B4 43BD01            ORL      BCON,#01H
   95: 
   96:   ///  UART interrupt enabled
   97:   ES = 1;
0009B7 D2AC              SETB     ES
   98: 
   99: } //  End of function UART_vInit
0009B9 22                RET      
----- FUNCTION UART_vInit (END) -------


----- FUNCTION _processCommand (BEGIN) -----
 FILE: 'UART.C'
  143: void processCommand(char * command) {
  144: 	
0009BA 8B3F              MOV      command,R3
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  10:04:31  PAGE 16


0009BC 8A40              MOV      command+01H,R2
0009BE 8941              MOV      command+02H,R1
  145: 	int commandSize = strlen(command);
0009C0 120003            LCALL    _strlen
0009C3 8E42              MOV      commandSize,R6
0009C5 8F43              MOV      commandSize+01H,R7
  146: 	char xdata respondMessage[MAX_RESPONSE_LENGTH] = {0};
0009C7 7800              MOV      R0,#LOW respondMessage
0009C9 7CF0              MOV      R4,#HIGH respondMessage
0009CB 7D01              MOV      R5,#01H
0009CD 7BFF              MOV      R3,#0FFH
0009CF 7A04              MOV      R2,#HIGH _?ix1000
0009D1 7958              MOV      R1,#LOW _?ix1000
0009D3 7E00              MOV      R6,#00H
0009D5 7FC8              MOV      R7,#0C8H
0009D7 1200F6            LCALL    ?C?COPY
  147: 	bool isNormalCommand = commandSize == 5 && command[0] == '$' && command[2] == '$' && command[4] == '$';
0009DA E543              MOV      A,commandSize+01H
0009DC 6405              XRL      A,#05H
0009DE 4542              ORL      A,commandSize
0009E0 7021              JNZ      ?C0007?UART
0009E2 AB3F              MOV      R3,command
0009E4 AA40              MOV      R2,command+01H
0009E6 A941              MOV      R1,command+02H
0009E8 12011C            LCALL    ?C?CLDPTR
0009EB B42415            CJNE     A,#024H,?C0007?UART
0009EE 900002            MOV      DPTR,#02H
0009F1 120135            LCALL    ?C?CLDOPTR
0009F4 B4240C            CJNE     A,#024H,?C0007?UART
0009F7 900004            MOV      DPTR,#04H
0009FA 120135            LCALL    ?C?CLDOPTR
0009FD B42403            CJNE     A,#024H,?C0007?UART
000A00 D3                SETB     C
000A01 8001              SJMP     ?C0008?UART
000A03         ?C0007?UART:
000A03 C3                CLR      C
000A04         ?C0008?UART:
000A04 9200              MOV      isNormalCommand,C
  148: 	bool isSetUUIDCommand = commandSize == 40 && command[0] == '$' && command[1] == 'f' && command[2] == '$' && comm
>> and[39] == '$';
000A06 E543              MOV      A,commandSize+01H
000A08 6428              XRL      A,#028H
000A0A 4542              ORL      A,commandSize
000A0C 702B              JNZ      ?C0009?UART
000A0E AB3F              MOV      R3,command
000A10 AA40              MOV      R2,command+01H
000A12 A941              MOV      R1,command+02H
000A14 12011C            LCALL    ?C?CLDPTR
000A17 6424              XRL      A,#024H
000A19 701E              JNZ      ?C0009?UART
000A1B 900001            MOV      DPTR,#01H
000A1E 120135            LCALL    ?C?CLDOPTR
000A21 B46615            CJNE     A,#066H,?C0009?UART
000A24 900002            MOV      DPTR,#02H
000A27 120135            LCALL    ?C?CLDOPTR
000A2A B4240C            CJNE     A,#024H,?C0009?UART
000A2D 900027            MOV      DPTR,#027H
000A30 120135            LCALL    ?C?CLDOPTR
000A33 B42403            CJNE     A,#024H,?C0009?UART
000A36 D3                SETB     C
000A37 8001              SJMP     ?C0010?UART
000A39         ?C0009?UART:
000A39 C3                CLR      C
000A3A         ?C0010?UART:
000A3A 9201              MOV      isSetUUIDCommand,C
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  10:04:31  PAGE 17


  149: 	
  150: 	memset(respondMessage, 0, MAX_RESPONSE_LENGTH);
000A3C 7E00              MOV      R6,#00H
000A3E 7FC8              MOV      R7,#0C8H
000A40 7D00              MOV      R5,#00H
000A42 7B01              MOV      R3,#01H
000A44 7AF0              MOV      R2,#HIGH respondMessage
000A46 7900              MOV      R1,#LOW respondMessage
000A48 1201E4            LCALL    ?C?MEMSET
  151: 
  152: 	if (isNormalCommand) {
000A4B 30006D            JNB      isNormalCommand,?C0011?UART
  153: 		switch(command[1]) {
000A4E AB3F              MOV      R3,command
000A50 AA40              MOV      R2,command+01H
000A52 A941              MOV      R1,command+02H
000A54 900001            MOV      DPTR,#01H
000A57 120135            LCALL    ?C?CLDOPTR
000A5A 249E              ADD      A,#09EH
000A5C 6019              JZ       ?C0014?UART
000A5E 14                DEC      A
000A5F 6025              JZ       ?C0015?UART
000A61 14                DEC      A
000A62 6031              JZ       ?C0016?UART
000A64 14                DEC      A
000A65 6031              JZ       ?C0017?UART
000A67 14                DEC      A
000A68 603D              JZ       ?C0018?UART
000A6A 2405              ADD      A,#05H
000A6C 703C              JNZ      ?C0019?UART
  154: 			case 'a':
000A6E         ?C0013?UART:
  155: 				enableLCRChannel(command[3]);
000A6E 900003            MOV      DPTR,#03H
000A71 120135            LCALL    ?C?CLDOPTR
000A74 FF                MOV      R7,A
000A75 6143              AJMP     _enableLCRChannel
  156: 				break;
  157: 			case 'b':
000A77         ?C0014?UART:
  158: 				enableLCChannel(command[3]);
000A77 AB3F              MOV      R3,command
000A79 AA40              MOV      R2,command+01H
000A7B A941              MOV      R1,command+02H
000A7D 900003            MOV      DPTR,#03H
000A80 120135            LCALL    ?C?CLDOPTR
000A83 FF                MOV      R7,A
000A84 8073              SJMP     _enableLCChannel
  159: 				break;
  160: 			case 'c':
000A86         ?C0015?UART:
  161: 				setChargeMode(command[3]);
000A86 AB3F              MOV      R3,command
000A88 AA40              MOV      R2,command+01H
000A8A A941              MOV      R1,command+02H
000A8C 900003            MOV      DPTR,#03H
000A8F 120135            LCALL    ?C?CLDOPTR
000A92 FF                MOV      R7,A
000A93 618D              AJMP     _setChargeMode
  162: 				break;
  163: 			case 'd':
000A95         ?C0016?UART:
  164: 				sendHVRelayStatus();
000A95 0206F3            LJMP     sendHVRelayStatus
  165: 				break;
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  10:04:31  PAGE 18


  166: 			case 'e':
000A98         ?C0017?UART:
  167: 				setHVMonitorMode(command[3]);
000A98 AB3F              MOV      R3,command
000A9A AA40              MOV      R2,command+01H
000A9C A941              MOV      R1,command+02H
000A9E 900003            MOV      DPTR,#03H
000AA1 120135            LCALL    ?C?CLDOPTR
000AA4 FF                MOV      R7,A
000AA5 8029              SJMP     _setHVMonitorMode
  168: 				break;
  169: 			case 'f':
000AA7         ?C0018?UART:
  170: 				sendUUID();
000AA7 0207D9            LJMP     sendUUID
  171: 				break;
  172: 			default:
000AAA         ?C0019?UART:
  173: 				sendUART("Unknown Command1\r\n");
000AAA 7BFF              MOV      R3,#0FFH
000AAC 7A04              MOV      R2,#HIGH 0100042AH
000AAE 792A              MOV      R1,#LOW 0100042AH
000AB0 1206DE            LCALL    _sendUART
  174: 				sendUART(command);
000AB3 AB3F              MOV      R3,command
000AB5 AA40              MOV      R2,command+01H
000AB7 A941              MOV      R1,command+02H
  175: 		}		
  176: 	} else if (isSetUUIDCommand) {
000AB9 8012              SJMP     ?C0031?UART
000ABB         ?C0011?UART:
000ABB 300109            JNB      isSetUUIDCommand,?C0021?UART
  177: 		setUUID(command);
000ABE AB3F              MOV      R3,command
000AC0 AA40              MOV      R2,command+01H
000AC2 A941              MOV      R1,command+02H
000AC4 02076B            LJMP     _setUUID
  178: 	} else {
000AC7         ?C0021?UART:
  179: 		sendUART("Incorrect Command Format\r\n");		
000AC7 7BFF              MOV      R3,#0FFH
000AC9 7A04              MOV      R2,#HIGH 0100043DH
000ACB 793D              MOV      R1,#LOW 0100043DH
000ACD         
000ACD 0206DE            LJMP     _sendUART
  180: 	}
----- FUNCTION _processCommand (END) -------


----- FUNCTION _setHVMonitorMode (BEGIN) -----
 FILE: 'DeviceController.c'
  168: void setHVMonitorMode(char modeCode) {
  169: 	if (modeCode == '1') {
000AD0 8F44              MOV      modeCode,R7
  170: 		shouldMonitorHVStatus = 1;
000AD2 E544              MOV      A,modeCode
000AD4 B4310A            CJNE     A,#031H,?C0042?DEVICECONTROLLER
  171: 		sendUART("#e#1#\n");
000AD7 D203              SETB     shouldMonitorHVStatus
  172: 	} else if (modeCode == '0') {
000AD9 7BFF              MOV      R3,#0FFH
000ADB 7A03              MOV      R2,#HIGH 010003B0H
000ADD 79B0              MOV      R1,#LOW 010003B0H
  173: 		shouldMonitorHVStatus = 0;
000ADF 8015              SJMP     ?C0068?DEVICECONTROLLER
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  10:04:31  PAGE 19


000AE1         ?C0042?DEVICECONTROLLER:
000AE1 E544              MOV      A,modeCode
000AE3 B4300A            CJNE     A,#030H,?C0044?DEVICECONTROLLER
  174: 		sendUART("#e#0#\n");
000AE6 C203              CLR      shouldMonitorHVStatus
  175: 	} else {
000AE8 7BFF              MOV      R3,#0FFH
000AEA 7A03              MOV      R2,#HIGH 010003B7H
000AEC 79B7              MOV      R1,#LOW 010003B7H
000AEE         
  176: 		sendUART("#Unknown HV Monitor Code#\n");
000AEE 8006              SJMP     ?C0068?DEVICECONTROLLER
000AF0         ?C0044?DEVICECONTROLLER:
  177: 	}
000AF0 7BFF              MOV      R3,#0FFH
000AF2 7A03              MOV      R2,#HIGH 010003BEH
000AF4 79BE              MOV      R1,#LOW 010003BEH
000AF6         
000AF6 0206DE            LJMP     _sendUART
  178: 	
----- FUNCTION _setHVMonitorMode (END) -------


----- FUNCTION _enableLCChannel (BEGIN) -----
 FILE: 'DeviceController.c'
   17: void enableLCChannel(char channelCode) {
   18: 	// Switch off all LC / LCR channel first.
;---- Variable 'channelCode' assigned to Register 'R7' ----
   19: 	IO_vResetPin(LCR_CHANNEL_1);
000AF9 C290              CLR      P1_0
   20: 	IO_vResetPin(LCR_CHANNEL_2);
000AFB C292              CLR      P1_2
   21: 	IO_vResetPin(LCR_CHANNEL_3);	
000AFD C294              CLR      P1_4
   22: 	IO_vResetPin(LC_CHANNEL_1);
000AFF C291              CLR      P1_1
   23: 	IO_vResetPin(LC_CHANNEL_2);
000B01 C293              CLR      P1_3
   24: 	IO_vResetPin(LC_CHANNEL_3);
000B03 C295              CLR      P1_5
   25: 	
   26: 	// Enable coressponding LCR channel GPIO
   27: 	switch(channelCode) {
000B05 EF                MOV      A,R7
000B06 24CF              ADD      A,#0CFH
000B08 6012              JZ       ?C0004?DEVICECONTROLLER
000B0A 14                DEC      A
000B0B 6019              JZ       ?C0005?DEVICECONTROLLER
000B0D 14                DEC      A
000B0E 6020              JZ       ?C0006?DEVICECONTROLLER
000B10 2403              ADD      A,#03H
000B12 7026              JNZ      ?C0007?DEVICECONTROLLER
   28: 		case '0':
000B14         ?C0003?DEVICECONTROLLER:
   29: 			sendUART("#b#0#\n");
000B14 7BFF              MOV      R3,#0FFH
000B16 7A02              MOV      R2,#HIGH 0100024FH
000B18 794F              MOV      R1,#LOW 0100024FH
   30: 			break;
000B1A 8024              SJMP     ?C0051?DEVICECONTROLLER
   31: 		case '1':
000B1C         ?C0004?DEVICECONTROLLER:
   32: 			IO_vSetPin(LC_CHANNEL_1);
000B1C D291              SETB     P1_1
   33: 			sendUART("#b#1#\n");
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  10:04:31  PAGE 20


000B1E 7BFF              MOV      R3,#0FFH
000B20 7A02              MOV      R2,#HIGH 01000256H
000B22 7956              MOV      R1,#LOW 01000256H
000B24         
   34: 			break;
000B24 801A              SJMP     ?C0051?DEVICECONTROLLER
   35: 		case '2':
000B26         ?C0005?DEVICECONTROLLER:
   36: 			IO_vSetPin(LC_CHANNEL_2);
000B26 D293              SETB     P1_3
   37: 			sendUART("#b#2#\n");		
000B28 7BFF              MOV      R3,#0FFH
000B2A 7A02              MOV      R2,#HIGH 0100025DH
000B2C 795D              MOV      R1,#LOW 0100025DH
000B2E         
   38: 			break;
000B2E 8010              SJMP     ?C0051?DEVICECONTROLLER
   39: 		case '3':
000B30         ?C0006?DEVICECONTROLLER:
   40: 			IO_vSetPin(LC_CHANNEL_3);
000B30 D295              SETB     P1_5
   41: 			sendUART("#b#3#\n");
000B32 7BFF              MOV      R3,#0FFH
000B34 7A02              MOV      R2,#HIGH 01000264H
000B36 7964              MOV      R1,#LOW 01000264H
000B38         
   42: 			break;
000B38 8006              SJMP     ?C0051?DEVICECONTROLLER
   43: 		default:
000B3A         ?C0007?DEVICECONTROLLER:
   44: 			sendUART("#Unknown LC Channel.#\n");			
000B3A 7BFF              MOV      R3,#0FFH
000B3C 7A02              MOV      R2,#HIGH 0100026BH
000B3E 796B              MOV      R1,#LOW 0100026BH
000B40         
000B40 0206DE            LJMP     _sendUART
   45: 			break;
   46: 	}
----- FUNCTION _enableLCChannel (END) -------


----- FUNCTION _enableLCRChannel (BEGIN) -----
 FILE: 'DeviceController.c'
   49: void enableLCRChannel(char channelCode) {
   50: 	// Switch off all LC / LCR channel first.
;---- Variable 'channelCode' assigned to Register 'R7' ----
   51: 	IO_vResetPin(LCR_CHANNEL_1);
000B43 C290              CLR      P1_0
   52: 	IO_vResetPin(LCR_CHANNEL_2);
000B45 C292              CLR      P1_2
   53: 	IO_vResetPin(LCR_CHANNEL_3);
000B47 C294              CLR      P1_4
   54: 	IO_vResetPin(LC_CHANNEL_1);
000B49 C291              CLR      P1_1
   55: 	IO_vResetPin(LC_CHANNEL_2);
000B4B C293              CLR      P1_3
   56: 	IO_vResetPin(LC_CHANNEL_3);
000B4D C295              CLR      P1_5
   57: 	
   58: 	// Enable coressponding LCR channel GPIO
   59: 	switch(channelCode) {
000B4F EF                MOV      A,R7
000B50 24CF              ADD      A,#0CFH
000B52 6012              JZ       ?C0011?DEVICECONTROLLER
000B54 14                DEC      A
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  10:04:31  PAGE 21


000B55 6019              JZ       ?C0012?DEVICECONTROLLER
000B57 14                DEC      A
000B58 6020              JZ       ?C0013?DEVICECONTROLLER
000B5A 2403              ADD      A,#03H
000B5C 7026              JNZ      ?C0014?DEVICECONTROLLER
   60: 		case '0':
000B5E         ?C0010?DEVICECONTROLLER:
   61: 			sendUART("#a#0#\n");
000B5E 7BFF              MOV      R3,#0FFH
000B60 7A02              MOV      R2,#HIGH 01000282H
000B62 7982              MOV      R1,#LOW 01000282H
   62: 			break;
000B64 8024              SJMP     ?C0055?DEVICECONTROLLER
   63: 		case '1':
000B66         ?C0011?DEVICECONTROLLER:
   64: 			IO_vSetPin(LCR_CHANNEL_1);
000B66 D290              SETB     P1_0
   65: 			sendUART("#a#1#\n");
000B68 7BFF              MOV      R3,#0FFH
000B6A 7A02              MOV      R2,#HIGH 01000289H
000B6C 7989              MOV      R1,#LOW 01000289H
000B6E         
   66: 			break;
000B6E 801A              SJMP     ?C0055?DEVICECONTROLLER
   67: 		case '2':
000B70         ?C0012?DEVICECONTROLLER:
   68: 			IO_vSetPin(LCR_CHANNEL_2);
000B70 D292              SETB     P1_2
   69: 			sendUART("#a#2#\n");		
000B72 7BFF              MOV      R3,#0FFH
000B74 7A02              MOV      R2,#HIGH 01000290H
000B76 7990              MOV      R1,#LOW 01000290H
000B78         
   70: 			break;
000B78 8010              SJMP     ?C0055?DEVICECONTROLLER
   71: 		case '3':
000B7A         ?C0013?DEVICECONTROLLER:
   72: 			IO_vSetPin(LCR_CHANNEL_3);
000B7A D294              SETB     P1_4
   73: 			sendUART("#a#3#\n");
000B7C 7BFF              MOV      R3,#0FFH
000B7E 7A02              MOV      R2,#HIGH 01000297H
000B80 7997              MOV      R1,#LOW 01000297H
000B82         
   74: 			break;
000B82 8006              SJMP     ?C0055?DEVICECONTROLLER
   75: 		default:
000B84         ?C0014?DEVICECONTROLLER:
   76: 			sendUART("#Unknown LCR Channel.#\n");			
000B84 7BFF              MOV      R3,#0FFH
000B86 7A02              MOV      R2,#HIGH 0100029EH
000B88 799E              MOV      R1,#LOW 0100029EH
000B8A         
000B8A 0206DE            LJMP     _sendUART
   77: 			break;
   78: 	}
----- FUNCTION _enableLCRChannel (END) -------


----- FUNCTION _setChargeMode (BEGIN) -----
 FILE: 'DeviceController.c'
  140: void setChargeMode(char modeCode) {
  141: 	if (modeCode == '0') {
000B8D 8F44              MOV      modeCode,R7
  142: 		IO_vResetPin(HV_CHANNEL);		
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  10:04:31  PAGE 22


000B8F E544              MOV      A,modeCode
000B91 B4300E            CJNE     A,#030H,?C0034?DEVICECONTROLLER
  143: 		IO_vSetPin(DISCHARGE_CHANNEL);
000B94 C2B7              CLR      P3_7
  144: 		IO_vSetPin(CHARGE_CHANNEL);
000B96 D2CE              SETB     P4_6
  145: 		sendUART("#c#0#\n");		
000B98 D2B4              SETB     P3_4
  146: 	} else if (modeCode == '1') {
000B9A 7BFF              MOV      R3,#0FFH
000B9C 7A03              MOV      R2,#HIGH 01000384H
000B9E 7984              MOV      R1,#LOW 01000384H
  147: 		if (!isAllHVRelayOK()) {
000BA0 8040              SJMP     ?C0066?DEVICECONTROLLER
000BA2         ?C0034?DEVICECONTROLLER:
000BA2 E544              MOV      A,modeCode
000BA4 6431              XRL      A,#031H
000BA6 7021              JNZ      ?C0036?DEVICECONTROLLER
  148: 			IO_vResetPin(HV_CHANNEL);			
000BA8 1207FB            LCALL    isAllHVRelayOK
000BAB 400E              JC       ?C0037?DEVICECONTROLLER
  149: 			IO_vSetPin(CHARGE_CHANNEL);
000BAD C2B7              CLR      P3_7
  150: 			IO_vSetPin(DISCHARGE_CHANNEL);
000BAF D2B4              SETB     P3_4
  151: 			sendUART("#d#0#\n");
000BB1 D2CE              SETB     P4_6
  152: 			return;
000BB3 7BFF              MOV      R3,#0FFH
000BB5 7A03              MOV      R2,#HIGH 0100037DH
000BB7 797D              MOV      R1,#LOW 0100037DH
000BB9         
000BB9 8027              SJMP     ?C0066?DEVICECONTROLLER
  153: 		}
000BBB         ?C0037?DEVICECONTROLLER:
  154: 		IO_vSetPin(DISCHARGE_CHANNEL);
000BBB D2CE              SETB     P4_6
  155: 		IO_vSetPin(HV_CHANNEL);
000BBD D2B7              SETB     P3_7
  156: 		IO_vResetPin(CHARGE_CHANNEL);
000BBF C2B4              CLR      P3_4
  157: 		sendUART("#c#1#\n");
000BC1 7BFF              MOV      R3,#0FFH
000BC3 7A03              MOV      R2,#HIGH 0100038BH
000BC5 798B              MOV      R1,#LOW 0100038BH
000BC7         
  158: 	} else if (modeCode == '2') {
000BC7 8019              SJMP     ?C0066?DEVICECONTROLLER
000BC9         ?C0036?DEVICECONTROLLER:
000BC9 E544              MOV      A,modeCode
000BCB B4320E            CJNE     A,#032H,?C0040?DEVICECONTROLLER
  159: 		IO_vSetPin(CHARGE_CHANNEL);
000BCE D2B4              SETB     P3_4
  160: 		IO_vResetPin(HV_CHANNEL);
000BD0 C2B7              CLR      P3_7
  161: 		IO_vResetPin(DISCHARGE_CHANNEL);
000BD2 C2CE              CLR      P4_6
  162: 		sendUART("#c#2#\n");
000BD4 7BFF              MOV      R3,#0FFH
000BD6 7A03              MOV      R2,#HIGH 01000392H
000BD8 7992              MOV      R1,#LOW 01000392H
000BDA         
  163: 	} else {
000BDA 8006              SJMP     ?C0066?DEVICECONTROLLER
000BDC         ?C0040?DEVICECONTROLLER:
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  10:04:31  PAGE 23


  164: 		sendUART("#Unknown Charge Mode#\n");		
000BDC 7BFF              MOV      R3,#0FFH
000BDE 7A03              MOV      R2,#HIGH 01000399H
000BE0 7999              MOV      R1,#LOW 01000399H
000BE2         
000BE2 0206DE            LJMP     _sendUART
  165: 	}
----- FUNCTION _setChargeMode (END) -------


----- FUNCTION UART_viIsr (BEGIN) -----
 FILE: 'UART.C'
  183: void UART_viIsr(void) interrupt UARTINT
000BE5 C0E0              PUSH     ACC
000BE7 C0F0              PUSH     B
000BE9 C083              PUSH     DPH
000BEB C082              PUSH     DPL
000BED C0D0              PUSH     PSW
000BEF 75D000            MOV      PSW,#00H
000BF2 C000              PUSH     AR0
000BF4 C001              PUSH     AR1
000BF6 C002              PUSH     AR2
000BF8 C003              PUSH     AR3
000BFA C004              PUSH     AR4
000BFC C005              PUSH     AR5
000BFE C006              PUSH     AR6
000C00 C007              PUSH     AR7
  184: {
  185: 	// switch to page 0
  186:   SFR_PAGE(_su0, SST0);
000C02 75BF80            MOV      SCU_PAGE,#080H
  187:   if (TI)
000C05 309902            JNB      TI,?C0024?UART
  188:   {
  189: 		TI = 0;
000C08 C299              CLR      TI
  190:   }
000C0A         ?C0024?UART:
  191:   if (RI)
000C0A 309854            JNB      RI,?C0025?UART
  192:   {
  193: 		char receiveByte = SBUF;
000C0D 85993E            MOV      receiveByte,SBUF
  194: 		if (receiveByte == '\r' || receiveByte == '\n' || bufferCount >= MAX_COMMAND_LENGTH-1) {
000C10 E53E              MOV      A,receiveByte
000C12 640D              XRL      A,#0DH
000C14 6013              JZ       ?C0027?UART
000C16 E53E              MOV      A,receiveByte
000C18 640A              XRL      A,#0AH
000C1A 600D              JZ       ?C0027?UART
000C1C C3                CLR      C
000C1D E509              MOV      A,bufferCount+01H
000C1F 9463              SUBB     A,#063H
000C21 E508              MOV      A,bufferCount
000C23 6480              XRL      A,#080H
000C25 9480              SUBB     A,#080H
000C27 401F              JC       ?C0026?UART
000C29         ?C0027?UART:
  195: 			processCommand(receiveBuffer);
000C29 7B01              MOV      R3,#01H
000C2B 7AF1              MOV      R2,#HIGH receiveBuffer
000C2D 7971              MOV      R1,#LOW receiveBuffer
000C2F 31BA              ACALL    _processCommand
  196: 			memset(receiveBuffer, 0, MAX_COMMAND_LENGTH);			
000C31 7E00              MOV      R6,#00H
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  10:04:31  PAGE 24


000C33 7F64              MOV      R7,#064H
000C35 7D00              MOV      R5,#00H
000C37 7B01              MOV      R3,#01H
000C39 7AF1              MOV      R2,#HIGH receiveBuffer
000C3B 7971              MOV      R1,#LOW receiveBuffer
000C3D 1201E4            LCALL    ?C?MEMSET
  197: 			bufferCount = 0;
000C40 750800            MOV      bufferCount,#00H
000C43 750900            MOV      bufferCount+01H,#00H
  198: 		} else {
000C46 8017              SJMP     ?C0028?UART
000C48         ?C0026?UART:
  199: 			receiveBuffer[bufferCount] = receiveByte;
000C48 7471              MOV      A,#LOW receiveBuffer
000C4A 2509              ADD      A,bufferCount+01H
000C4C F582              MOV      DPL,A
000C4E 74F1              MOV      A,#HIGH receiveBuffer
000C50 3508              ADDC     A,bufferCount
000C52 F583              MOV      DPH,A
000C54 E53E              MOV      A,receiveByte
000C56 F0                MOVX     @DPTR,A
  200: 			bufferCount++;
000C57 0509              INC      bufferCount+01H
000C59 E509              MOV      A,bufferCount+01H
000C5B 7002              JNZ      ?C0030?UART
000C5D 0508              INC      bufferCount
000C5F         ?C0030?UART:
  201: 		}
000C5F         ?C0028?UART:
  202:     RI = 0;
000C5F C298              CLR      RI
  203:   }
000C61         ?C0025?UART:
  204: 
  205: 	// restore the old page
  206:   SFR_PAGE(_su0, RST0);
000C61 75BFC0            MOV      SCU_PAGE,#0C0H
  207: }
000C64 D007              POP      AR7
000C66 D006              POP      AR6
000C68 D005              POP      AR5
000C6A D004              POP      AR4
000C6C D003              POP      AR3
000C6E D002              POP      AR2
000C70 D001              POP      AR1
000C72 D000              POP      AR0
000C74 D0D0              POP      PSW
000C76 D082              POP      DPL
000C78 D083              POP      DPH
000C7A D0F0              POP      B
000C7C D0E0              POP      ACC
000C7E 32                RETI     
----- FUNCTION UART_viIsr (END) -------


----- FUNCTION _FLASH_Ready (BEGIN) -----
 FILE: 'FlashHandler.c'
   92: bit FLASH_Ready						(unsigned char BankNum)
   93: {
;---- Variable 'BankNum' assigned to Register 'R7' ----
   94:     ACC = BankNum;
   95: #ifdef __C51__		
000C7F EF                MOV      A,R7
   96: 	((void (code *) (void)) FLASH_READ_STATUS) ();
000C80 02DFF0            LJMP     0DFF0H
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  10:04:31  PAGE 25


   97: #endif	// __C51__
   98: #ifdef	SDCC
   99: _asm
  100: 	LCALL FLASH_READ_STATUS;
  101: _endasm;
  102: #endif	// SDCC
  103: 	return(CY);
----- FUNCTION _FLASH_Ready (END) -------


----- FUNCTION _readFlashToBuffer (BEGIN) -----
 FILE: 'FlashUtils.c'
   46: void readFlashToBuffer(char xdata * buffer, int n, unsigned char code * EECurrentAddr) 
   47: {
000C83 8E44              MOV      buffer,R6
000C85 8F45              MOV      buffer+01H,R7
000C87 8C46              MOV      n,R4
000C89 8D47              MOV      n+01H,R5
000C8B 8A48              MOV      EECurrentAddr,R2
000C8D 8B49              MOV      EECurrentAddr+01H,R3
   48: 	unsigned char code * EETempAddr = (unsigned char code*)FLASH_FIRST_ADDR;
   49: 	int i = 0;
000C8F 754AA0            MOV      EETempAddr,#0A0H
000C92 754B00            MOV      EETempAddr+01H,#00H
   50: 	int j = 0;
000C95 E4                CLR      A
000C96 F54C              MOV      i,A
000C98 F54D              MOV      i+01H,A
   51: 	int k = 0;
000C9A F54E              MOV      j,A
000C9C F54F              MOV      j+01H,A
   52: 	memset(buffer, 0, n);
000C9E F550              MOV      k,A
000CA0 F551              MOV      k+01H,A
   53: 	
000CA2 AE46              MOV      R6,n
000CA4 AF47              MOV      R7,n+01H
000CA6 FD                MOV      R5,A
000CA7 AA44              MOV      R2,buffer
000CA9 A945              MOV      R1,buffer+01H
000CAB 7B01              MOV      R3,#01H
000CAD 1201E4            LCALL    ?C?MEMSET
000CB0         ?C0011?FLASHUTILS:
   54: 	while (FLASH_Ready(FLASH_BANK_TO_CHECK) == 0) {;}
000CB0 7F03              MOV      R7,#03H
000CB2 917F              ACALL    _FLASH_Ready
000CB4 50FA              JNC      ?C0011?FLASHUTILS
000CB6         ?C0012?FLASHUTILS:
000CB6         ?C0013?FLASHUTILS:
   55: 	
   56: 	while (EETempAddr < EECurrentAddr && j < n) 
000CB6 C3                CLR      C
000CB7 E54B              MOV      A,EETempAddr+01H
000CB9 9549              SUBB     A,EECurrentAddr+01H
000CBB E54A              MOV      A,EETempAddr
000CBD 9548              SUBB     A,EECurrentAddr
000CBF 5054              JNC      ?C0017?FLASHUTILS
000CC1 C3                CLR      C
000CC2 E54F              MOV      A,j+01H
000CC4 9547              SUBB     A,n+01H
000CC6 E546              MOV      A,n
000CC8 6480              XRL      A,#080H
000CCA F8                MOV      R0,A
000CCB E54E              MOV      A,j
000CCD 6480              XRL      A,#080H
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  10:04:31  PAGE 26


000CCF 98                SUBB     A,R0
000CD0 5043              JNC      ?C0017?FLASHUTILS
   57: 	{	
   58: 		i = 0;
000CD2 E4                CLR      A
000CD3 F54C              MOV      i,A
000CD5 F54D              MOV      i+01H,A
000CD7         ?C0015?FLASHUTILS:
   59: 		while (*(EETempAddr+i) != 0) {
000CD7 E54B              MOV      A,EETempAddr+01H
000CD9 254D              ADD      A,i+01H
000CDB F582              MOV      DPL,A
000CDD E54A              MOV      A,EETempAddr
000CDF 354C              ADDC     A,i
000CE1 F583              MOV      DPH,A
000CE3 E4                CLR      A
000CE4 93                MOVC     A,@A+DPTR
000CE5 FF                MOV      R7,A
000CE6 6020              JZ       ?C0016?FLASHUTILS
   60: 			buffer[j] = *(EETempAddr+i);
000CE8 E545              MOV      A,buffer+01H
000CEA 254F              ADD      A,j+01H
000CEC F582              MOV      DPL,A
000CEE E544              MOV      A,buffer
000CF0 354E              ADDC     A,j
000CF2 F583              MOV      DPH,A
000CF4 EF                MOV      A,R7
000CF5 F0                MOVX     @DPTR,A
   61: 			i++;
000CF6 054D              INC      i+01H
000CF8 E54D              MOV      A,i+01H
000CFA 7002              JNZ      ?C0025?FLASHUTILS
000CFC 054C              INC      i
000CFE         ?C0025?FLASHUTILS:
   62: 			j++;
000CFE 054F              INC      j+01H
000D00 E54F              MOV      A,j+01H
000D02 7002              JNZ      ?C0026?FLASHUTILS
000D04 054E              INC      j
000D06         ?C0026?FLASHUTILS:
   63: 		}
000D06 80CF              SJMP     ?C0015?FLASHUTILS
000D08         ?C0016?FLASHUTILS:
   64: 		EETempAddr = EETempAddr + BYTES_PER_WORDLINE;		
000D08 7420              MOV      A,#020H
000D0A 254B              ADD      A,EETempAddr+01H
000D0C F54B              MOV      EETempAddr+01H,A
000D0E E4                CLR      A
000D0F 354A              ADDC     A,EETempAddr
000D11 F54A              MOV      EETempAddr,A
   65: 	}	
000D13 80A1              SJMP     ?C0013?FLASHUTILS
   66: }
000D15         ?C0017?FLASHUTILS:
000D15 22                RET      
----- FUNCTION _readFlashToBuffer (END) -------


----- FUNCTION getFlashDataEndAddress (BEGIN) -----
 FILE: 'FlashUtils.c'
   12: unsigned char code * getFlashDataEndAddress() {
   13:   // Initialize the pointer to the FLASH (Checking if there is a valid data)
   14:   unsigned char code * EECurrentAddr = (unsigned char code*)FLASH_LAST_ADDR;
;---- Variable 'EECurrentAddr' assigned to Register 'R6/R7' ----
000D16 7F00              MOV      R7,#00H
LX51 LINKER/LOCATER V4.66.41.0                                                        04/14/2016  10:04:31  PAGE 27


000D18 7EAC              MOV      R6,#0ACH
   15:   unsigned char code * EETempAddr;
   16:           
   17:   for (EETempAddr = (unsigned char code*)FLASH_FIRST_ADDR; EETempAddr <= (unsigned char code*)FLASH_LAST_ADDR; EE
>> TempAddr += BYTES_PER_WORDLINE)
;---- Variable 'EETempAddr' assigned to Register 'DPTR' ----
000D1A 90A000            MOV      DPTR,#0A000H
000D1D         ?C0001?FLASHUTILS:
000D1D D3                SETB     C
000D1E E582              MOV      A,DPL
000D20 9400              SUBB     A,#00H
000D22 E583              MOV      A,DPH
000D24 94AC              SUBB     A,#0ACH
000D26 5017              JNC      ?C0002?FLASHUTILS
   18: 	{
   19: 		if (*EETempAddr == 0)
000D28 E4                CLR      A
000D29 93                MOVC     A,@A+DPTR
000D2A 7006              JNZ      ?C0003?FLASHUTILS
   20: 		{
   21: 			EECurrentAddr = EETempAddr;
000D2C AE83              MOV      R6,DPH
000D2E AF82              MOV      R7,DPL
   22: 			break;
000D30 800D              SJMP     ?C0002?FLASHUTILS
   23: 		}
   24: 	}
000D32         ?C0003?FLASHUTILS:
000D32 7420              MOV      A,#020H
000D34 2582              ADD      A,DPL
000D36 F582              MOV      DPL,A
000D38 E4                CLR      A
000D39 3583              ADDC     A,DPH
000D3B F583              MOV      DPH,A
000D3D 80DE              SJMP     ?C0001?FLASHUTILS
000D3F         ?C0002?FLASHUTILS:
   25: 	return EECurrentAddr;
   26: }
000D3F 22                RET      
----- FUNCTION getFlashDataEndAddress (END) -------


