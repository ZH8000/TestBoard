LX51 LINKER/LOCATER V4.66.41.0                                                          03/18/2016  11:02:42  PAGE 1





ASSEMBLER CODE PACKING OF MODULE:  TestBoard (?C_STARTUP)


----- FUNCTION isAllHVRelayOK (BEGIN) -----
 FILE: 'DeviceController.c'
   74: bool isAllHVRelayOK() {
   75: 	#ifdef STARTER_KIT_EMU
   76: 		return IO_ubReadPin(HV_READY_1);
000020 A2C8              MOV      C,P4_0
   77: 	#else
   78: 		return 
   79: 			IO_ubReadPin(HV_READY_1) &&
   80: 			IO_ubReadPin(HV_READY_2) &&
   81: 			IO_ubReadPin(HV_READY_3) &&
   82: 			IO_ubReadPin(HV_FAULT_1) &&
   83: 			IO_ubReadPin(HV_FAULT_2) &&
   84: 			IO_ubReadPin(HV_FAULT_3);
   85: 	#endif
   86: }
000022 22                RET      
----- FUNCTION isAllHVRelayOK (END) -------


000023 02082F            LJMP     082FH
----- FUNCTION MAIN_vInit (BEGIN) -----
 FILE: 'MAIN.C'
   30: void MAIN_vInit(void)
   31: {
   32:   ///  -----------------------------------------------------------------------
   33:   ///  Configuration of the System Clock:
   34:   ///  -----------------------------------------------------------------------
   35:   ///  - On Chip Osc is Selected
   36:   ///  - PLL Mode, NDIV =  20
   37:   ///  - input frequency is 9.6 MHz
   38: 
   39:   //   FCLK runs at 2 times the frequency of PCLK.
   40:   SFR_PAGE(_su1, noSST);         // switch to page1
0005C0 75BF01            MOV      SCU_PAGE,#01H
   41:   CMCON         =  0x10;         // load Clock Control Register
0005C3 75BA10            MOV      CMCON,#010H
   42:   SFR_PAGE(_su0, noSST);         // switch to page0
0005C6 E4                CLR      A
0005C7 F5BF              MOV      SCU_PAGE,A
   43: 
   44: 
   45:   ///  *********************************************************************************
   46:   ///  Note : All peripheral related IO configurations are done in the 
   47:   ///  respective peripheral modules (alternate functions selection)
   48:   ///  *********************************************************************************
   49: 
   50:   ///  Initialization of module 'GPIO'
   51:   IO_vInit();
0005C9 B1D9              ACALL    IO_vInit
   52: 
   53:   ///  Initialization of module 'UART (Serial Interface)'
   54:   UART_vInit();
0005CB F1D5              ACALL    UART_vInit
   55: 
   56:   //   Interrupt Priority
   57: 
   58:   IP            =  0x00;         // load Interrupt Priority Register
0005CD E4                CLR      A
0005CE F5B8              MOV      IP,A
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  11:02:42  PAGE 2


   59:   IPH           =  0x00;         // load Interrupt Priority High Register
0005D0 F5B9              MOV      IPH,A
   60:   IP1           =  0x00;         // load Interrupt Priority 1 Register
0005D2 F5F8              MOV      IP1,A
   61:   IPH1          =  0x00;         // load Interrupt Priority 1 High Register
0005D4 F5F9              MOV      IPH1,A
   62: 
   63: 
   64:   //// Interrupt structure 2 mode 0 is selected.
   65:   //// Interrupt service routine choice 2 is selected.
   66:   //   globally enable interrupts
   67:   EA            =  1;           
0005D6 D2AF              SETB     EA
   68: 
   69: } 
0005D8 22                RET      
----- FUNCTION MAIN_vInit (END) -------


----- FUNCTION IO_vInit (BEGIN) -----
 FILE: 'IO.C'
   49: void IO_vInit(void)
   50: {
   51: 	#ifdef STARTER_KIT_EMU
   52: 		P1_DIR        		= 0x04; 
0005D9 759104            MOV      P1_DIR,#04H
   53: 		P1_DATA       		= 0x00;
0005DC E4                CLR      A
0005DD F590              MOV      P1_DATA,A
   54: 		P3_DIR			  		= 0xFF;
0005DF 75B1FF            MOV      P3_DIR,#0FFH
   55: 		P3_DATA						= 0x00;
0005E2 F5B0              MOV      P3_DATA,A
   56: 	#else
   57: 
   58: 		///  -----------------------------------------------------------------------
   59: 		///  Configuration of Port P0:
   60: 		///  -----------------------------------------------------------------------
   61: 		///  - no pin of port P0 is used
   62: 
   63: 
   64: 		///  -----------------------------------------------------------------------
   65: 		///  Configuration of Port P1:
   66: 		///  -----------------------------------------------------------------------
   67: 		///  P1.0:
   68: 		///  - is used as general purpose output
   69: 		///  - push/pull output is selected
   70: 		///  - the pin status is low level
   71: 		///  - pull-up device is assigned
   72: 		///  P1.1:
   73: 		///  - is used as general purpose output
   74: 		///  - push/pull output is selected
   75: 		///  - the pin status is low level
   76: 		///  - pull-up device is assigned
   77: 		///  P1.2:
   78: 		///  - is used as general purpose output
   79: 		///  - push/pull output is selected
   80: 		///  - the pin status is low level
   81: 		///  - pull-up device is assigned
   82: 		///  P1.3:
   83: 		///  - is used as general purpose output
   84: 		///  - push/pull output is selected
   85: 		///  - the pin status is low level
   86: 		///  - pull-up device is assigned
   87: 		///  P1.4:
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  11:02:42  PAGE 3


   88: 		///  - is used as general purpose output
   89: 		///  - push/pull output is selected
   90: 		///  - the pin status is low level
   91: 		///  - pull-up device is assigned
   92: 		///  P1.5:
   93: 		///  - is used as general purpose output
   94: 		///  - push/pull output is selected
   95: 		///  - the pin status is low level
   96: 		///  - pull-up device is assigned
   97: 
   98: 
   99: 		P1_DIR        =  0x3F;         // load direction register
  100: 
  101: 		///  -----------------------------------------------------------------------
  102: 		///  Configuration of Port P2:
  103: 		///  -----------------------------------------------------------------------
  104: 		///  - no pin of port P2 is used
  105: 
  106: 
  107: 		///  -----------------------------------------------------------------------
  108: 		///  Configuration of Port P3:
  109: 		///  -----------------------------------------------------------------------
  110: 		///  P3.4:
  111: 		///  - is used as general purpose output
  112: 		///  - push/pull output is selected
  113: 		///  - the pin status is low level
  114: 		///  - pull device is disabled (tristate) 
  115: 		///  P3.5:
  116: 		///  - is used as general purpose output
  117: 		///  - push/pull output is selected
  118: 		///  - the pin status is low level
  119: 		///  - pull device is disabled (tristate) 
  120: 		///  P3.6:
  121: 		///  - is used as general purpose output
  122: 		///  - push/pull output is selected
  123: 		///  - the pin status is low level
  124: 		///  - pull device is disabled (tristate) 
  125: 		///  P3.7:
  126: 		///  - is used as general purpose output
  127: 		///  - push/pull output is selected
  128: 		///  - the pin status is low level
  129: 		///  - pull device is disabled (tristate) 
  130: 
  131: 
  132: 		P3_DIR        =  0xF0;         // load direction register
  133: 
  134: 		///  -----------------------------------------------------------------------
  135: 		///  Configuration of Port P4:
  136: 		///  -----------------------------------------------------------------------
  137: 		///  P4.0:
  138: 		///  - is used as general input
  139: 		///  - pull device is disabled (tristate) 
  140: 		///  P4.1:
  141: 		///  - is used as general input
  142: 		///  - pull device is disabled (tristate) 
  143: 		///  P4.2:
  144: 		///  - is used as general input
  145: 		///  - pull-up device is assigned
  146: 		///  P4.3:
  147: 		///  - is used as general input
  148: 		///  - pull device is disabled (tristate) 
  149: 		///  P4.4:
  150: 		///  - is used as general input
  151: 		///  - pull device is disabled (tristate) 
  152: 		///  P4.5:
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  11:02:42  PAGE 4


  153: 		///  - is used as general input
  154: 		///  - pull device is disabled (tristate) 
  155: 
  156: 
  157: 		///  -----------------------------------------------------------------------
  158: 		///  Configuration of Port P5:
  159: 		///  -----------------------------------------------------------------------
  160: 		///  - no pin of port P5 is used
  161: 	#endif
  162: 
  163: } //  End of function IO_vInit
0005E4 22                RET      
----- FUNCTION IO_vInit (END) -------


----- FUNCTION main (BEGIN) -----
 FILE: 'MAIN.C'
   79: void main(void)
   80: {
   81:   MAIN_vInit();
   82: 	
0005E5 B1C0              ACALL    MAIN_vInit
0005E7         ?C0012?MAIN:
   83:   while(1) {
   84: 		
   85: 		if (shouldMonitorHVStatus && !isAllHVRelayOK()) {
0005E7 30030C            JNB      shouldMonitorHVStatus,?C0014?MAIN
0005EA 1120              ACALL    isAllHVRelayOK
0005EC 4008              JC       ?C0014?MAIN
   86: 			sendUART("HV_NG\r\n");
0005EE 7BFF              MOV      R3,#0FFH
0005F0 7A00              MOV      R2,#HIGH 01000018H
0005F2 7918              MOV      R1,#LOW 01000018H
0005F4 D104              ACALL    _sendUART
   87: 		}
0005F6         ?C0014?MAIN:
   88: 			
   89: 		delay(1);
0005F6 7F01              MOV      R7,#01H
0005F8 7E00              MOV      R6,#00H
0005FA F1FB              ACALL    _delay
   90: 	}
0005FC 80E9              SJMP     ?C0012?MAIN
----- FUNCTION main (END) -------


----- FUNCTION ?L?COM0001 (BEGIN) -----
0005FE 7B01              MOV      R3,#01H
000600 7AF0              MOV      R2,#HIGH uuidString
000602 79C8              MOV      R1,#LOW uuidString
----- FUNCTION _sendUART (BEGIN) -----
 FILE: 'UART.C'
  133: void sendUART(char * message) {
  134: 	char * current = message;
;---- Variable 'message' assigned to Register 'R1/R2/R3' ----
  135: 	while (*current != '\0') {
;---- Variable 'current' assigned to Register 'R1/R2/R3' ----
000604         ?C0002?UART:
  136: 		SBUF = *current;
000604 311C              ACALL    ?C?CLDPTR
000606 6010              JZ       ?C0006?UART
  137: 		while (TI == 0);
000608 F599              MOV      SBUF,A
00060A         ?C0004?UART:
  138: 		TI = 0;		
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  11:02:42  PAGE 5


00060A 3099FD            JNB      TI,?C0004?UART
00060D         ?C0005?UART:
  139: 		current++;
00060D C299              CLR      TI
  140: 	}
00060F 7401              MOV      A,#01H
000611 29                ADD      A,R1
000612 F9                MOV      R1,A
000613 E4                CLR      A
000614 3A                ADDC     A,R2
000615 FA                MOV      R2,A
  141: }
000616 80EC              SJMP     ?C0002?UART
  142: 
000618         ?C0006?UART:
000618 22                RET      
----- FUNCTION _sendUART (END) -------


----- FUNCTION _setUUID (BEGIN) -----
 FILE: 'DeviceController.c'
  132: void setUUID(char * command) {
  133: 	unsigned char code * flashEndAddress = getFlashDataEndAddress();	
000619 8B44              MOV      command,R3
00061B 8A45              MOV      command+01H,R2
00061D 8946              MOV      command+02H,R1
  134: 	char xdata uuidString[37] = {0};
00061F F1AB              ACALL    getFlashDataEndAddress
000621 8E47              MOV      flashEndAddress,R6
000623 8F48              MOV      flashEndAddress+01H,R7
  135: 	strncpy(uuidString, command+3, 36);
000625 78C8              MOV      R0,#LOW uuidString
000627 7CF0              MOV      R4,#HIGH uuidString
000629 7D01              MOV      R5,#01H
00062B 7BFF              MOV      R3,#0FFH
00062D 7A03              MOV      R2,#HIGH _?ix1000
00062F 7946              MOV      R1,#LOW _?ix1000
000631 7E00              MOV      R6,#00H
000633 7F25              MOV      R7,#025H
000635 11F6              ACALL    ?C?COPY
  136: 	sendUART("Setting UUID to ");
000637 E546              MOV      A,command+02H
000639 2403              ADD      A,#03H
00063B F9                MOV      R1,A
00063C E4                CLR      A
00063D 3545              ADDC     A,command+01H
00063F 85444C            MOV      ?_strncpy?BYTE+03H,command
000642 F54D              MOV      ?_strncpy?BYTE+04H,A
000644 894E              MOV      ?_strncpy?BYTE+05H,R1
000646 754F00            MOV      ?_strncpy?BYTE+06H,#00H
000649 755024            MOV      ?_strncpy?BYTE+07H,#024H
00064C 7B01              MOV      R3,#01H
00064E 7AF0              MOV      R2,#HIGH uuidString
000650 79C8              MOV      R1,#LOW uuidString
000652 B14E              ACALL    _strncpy
  137: 	sendUART(uuidString);
000654 7BFF              MOV      R3,#0FFH
000656 7A03              MOV      R2,#HIGH 01000318H
000658 7918              MOV      R1,#LOW 01000318H
00065A D104              ACALL    _sendUART
  138: 	sendUART("....\r\n");
00065C B1FE              ACALL    ?L?COM0001
  139: 	sendUART("Please wait...");
00065E 7BFF              MOV      R3,#0FFH
000660 7A03              MOV      R2,#HIGH 01000329H
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  11:02:42  PAGE 6


000662 7929              MOV      R1,#LOW 01000329H
000664 D104              ACALL    _sendUART
  140: 	writeBufferToFlash(uuidString, &flashEndAddress);
000666 7BFF              MOV      R3,#0FFH
000668 7A03              MOV      R2,#HIGH 01000330H
00066A 7930              MOV      R1,#LOW 01000330H
00066C D104              ACALL    _sendUART
  141: 	sendUART("DONE\r\n");
00066E 754C00            MOV      ?_writeBufferToFlash?BYTE+03H,#00H
000671 754D00            MOV      ?_writeBufferToFlash?BYTE+04H,#HIGH flashEndAddress
000674 754E47            MOV      ?_writeBufferToFlash?BYTE+05H,#LOW flashEndAddress
000677 7B01              MOV      R3,#01H
000679 7AF0              MOV      R2,#HIGH uuidString
00067B 79C8              MOV      R1,#LOW uuidString
00067D 120AC6            LCALL    _writeBufferToFlash
  141: }
000680 7BFF              MOV      R3,#0FFH
000682 7A03              MOV      R2,#HIGH 0100033FH
000684 793F              MOV      R1,#LOW 0100033FH
000686 C104              AJMP     _sendUART
----- FUNCTION _setUUID (END) -------


----- FUNCTION sendUUID (BEGIN) -----
 FILE: 'DeviceController.c'
    8: void sendUUID() {
    9: 	char xdata uuidString[50];
   10: 	unsigned char code * currentFlashDataEndAddress = getFlashDataEndAddress();
000688 F1AB              ACALL    getFlashDataEndAddress
;---- Variable 'currentFlashDataEndAddress' assigned to Register 'R2/R3' ----
00068A AB07              MOV      R3,AR7
00068C AA06              MOV      R2,AR6
   11: 	readFlashToBuffer(uuidString, 50, currentFlashDataEndAddress);
00068E 7EF0              MOV      R6,#HIGH uuidString
000690 7FC8              MOV      R7,#LOW uuidString
000692 7D32              MOV      R5,#032H
000694 7C00              MOV      R4,#00H
000696 1209C9            LCALL    _readFlashToBuffer
   12: 	sendUART(uuidString);
000699 B1FE              ACALL    ?L?COM0001
   13: 	sendUART("\r\n");
00069B 7BFF              MOV      R3,#0FFH
00069D 7A02              MOV      R2,#HIGH 01000248H
00069F 7948              MOV      R1,#LOW 01000248H
0006A1 C104              AJMP     _sendUART
----- FUNCTION sendUUID (END) -------


----- FUNCTION _processCommand (BEGIN) -----
 FILE: 'UART.C'
  143: void processCommand(char * command) {
  144: 	
0006A3 8B3F              MOV      command,R3
0006A5 8A40              MOV      command+01H,R2
0006A7 8941              MOV      command+02H,R1
  145: 	int commandSize = strlen(command);
0006A9 1103              ACALL    _strlen
0006AB 8E42              MOV      commandSize,R6
0006AD 8F43              MOV      commandSize+01H,R7
  146: 	char xdata respondMessage[MAX_RESPONSE_LENGTH] = {0};
0006AF 7800              MOV      R0,#LOW respondMessage
0006B1 7CF0              MOV      R4,#HIGH respondMessage
0006B3 7D01              MOV      R5,#01H
0006B5 7BFF              MOV      R3,#0FFH
0006B7 7A03              MOV      R2,#HIGH _?ix1000
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  11:02:42  PAGE 7


0006B9 797D              MOV      R1,#LOW _?ix1000
0006BB 7E00              MOV      R6,#00H
0006BD 7FC8              MOV      R7,#0C8H
0006BF 11F6              ACALL    ?C?COPY
  147: 	bool isNormalCommand = commandSize == 5 && command[0] == '$' && command[2] == '$' && command[4] == '$';
0006C1 E543              MOV      A,commandSize+01H
0006C3 6405              XRL      A,#05H
0006C5 4542              ORL      A,commandSize
0006C7 701E              JNZ      ?C0007?UART
0006C9 AB3F              MOV      R3,command
0006CB AA40              MOV      R2,command+01H
0006CD A941              MOV      R1,command+02H
0006CF 311C              ACALL    ?C?CLDPTR
0006D1 B42413            CJNE     A,#024H,?C0007?UART
0006D4 900002            MOV      DPTR,#02H
0006D7 3135              ACALL    ?C?CLDOPTR
0006D9 B4240B            CJNE     A,#024H,?C0007?UART
0006DC 900004            MOV      DPTR,#04H
0006DF 3135              ACALL    ?C?CLDOPTR
0006E1 B42403            CJNE     A,#024H,?C0007?UART
0006E4 D3                SETB     C
0006E5 8001              SJMP     ?C0008?UART
0006E7         ?C0007?UART:
0006E7 C3                CLR      C
0006E8         ?C0008?UART:
0006E8 9200              MOV      isNormalCommand,C
  148: 	bool isSetUUIDCommand = commandSize == 40 && command[0] == '$' && command[1] == 'f' && command[2] == '$' && comm
>> and[39] == '$';
0006EA E543              MOV      A,commandSize+01H
0006EC 6428              XRL      A,#028H
0006EE 4542              ORL      A,commandSize
0006F0 7027              JNZ      ?C0009?UART
0006F2 AB3F              MOV      R3,command
0006F4 AA40              MOV      R2,command+01H
0006F6 A941              MOV      R1,command+02H
0006F8 311C              ACALL    ?C?CLDPTR
0006FA 6424              XRL      A,#024H
0006FC 701B              JNZ      ?C0009?UART
0006FE 900001            MOV      DPTR,#01H
000701 3135              ACALL    ?C?CLDOPTR
000703 B46613            CJNE     A,#066H,?C0009?UART
000706 900002            MOV      DPTR,#02H
000709 3135              ACALL    ?C?CLDOPTR
00070B B4240B            CJNE     A,#024H,?C0009?UART
00070E 900027            MOV      DPTR,#027H
000711 3135              ACALL    ?C?CLDOPTR
000713 B42403            CJNE     A,#024H,?C0009?UART
000716 D3                SETB     C
000717 8001              SJMP     ?C0010?UART
000719         ?C0009?UART:
000719 C3                CLR      C
00071A         ?C0010?UART:
00071A 9201              MOV      isSetUUIDCommand,C
  149: 	
  150: 	memset(respondMessage, 0, MAX_RESPONSE_LENGTH);	
00071C 7E00              MOV      R6,#00H
00071E 7FC8              MOV      R7,#0C8H
000720 7D00              MOV      R5,#00H
000722 7B01              MOV      R3,#01H
000724 7AF0              MOV      R2,#HIGH respondMessage
000726 7900              MOV      R1,#LOW respondMessage
000728 31E4              ACALL    ?C?MEMSET
  151: 
  152: 	if (isNormalCommand) {
00072A 300059            JNB      isNormalCommand,?C0011?UART
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  11:02:42  PAGE 8


  153: 		switch(command[1]) {
00072D AB3F              MOV      R3,command
00072F AA40              MOV      R2,command+01H
000731 A941              MOV      R1,command+02H
000733 900001            MOV      DPTR,#01H
000736 3135              ACALL    ?C?CLDOPTR
000738 249E              ADD      A,#09EH
00073A 6019              JZ       ?C0014?UART
00073C 14                DEC      A
00073D 6025              JZ       ?C0015?UART
00073F 14                DEC      A
000740 6031              JZ       ?C0016?UART
000742 14                DEC      A
000743 6030              JZ       ?C0017?UART
000745 14                DEC      A
000746 603C              JZ       ?C0018?UART
000748 2405              ADD      A,#05H
00074A 7045              JNZ      ?C0031?UART
  154: 			case 'a':
00074C         ?C0013?UART:
  155: 				enableLCRChannel(command[3]);
00074C 900003            MOV      DPTR,#03H
00074F 3135              ACALL    ?C?CLDOPTR
000751 FF                MOV      R7,A
000752 02090E            LJMP     _enableLCRChannel
  156: 				break;
  157: 			case 'b':
000755         ?C0014?UART:
  158: 				enableLCChannel(command[3]);
000755 AB3F              MOV      R3,command
000757 AA40              MOV      R2,command+01H
000759 A941              MOV      R1,command+02H
00075B 900003            MOV      DPTR,#03H
00075E 3135              ACALL    ?C?CLDOPTR
000760 FF                MOV      R7,A
000761 0208CA            LJMP     _enableLCChannel
  159: 				break;
  160: 			case 'c':
000764         ?C0015?UART:
  161: 				setChargeMode(command[3]);
000764 AB3F              MOV      R3,command
000766 AA40              MOV      R2,command+01H
000768 A941              MOV      R1,command+02H
00076A 900003            MOV      DPTR,#03H
00076D 3135              ACALL    ?C?CLDOPTR
00076F FF                MOV      R7,A
000770 020952            LJMP     _setChargeMode
  162: 				break;
  163: 			case 'd':
000773         ?C0016?UART:
  164: 				sendHVRelayStatus();
000773 8024              SJMP     sendHVRelayStatus
  165: 				break;
  166: 			case 'e':
000775         ?C0017?UART:
  167: 				setHVMonitorMode(command[3]);
000775 AB3F              MOV      R3,command
000777 AA40              MOV      R2,command+01H
000779 A941              MOV      R1,command+02H
00077B 900003            MOV      DPTR,#03H
00077E 3135              ACALL    ?C?CLDOPTR
000780 FF                MOV      R7,A
000781 020997            LJMP     _setHVMonitorMode
  168: 				break;
  169: 			case 'f':
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  11:02:42  PAGE 9


000784         ?C0018?UART:
  170: 				sendUUID();
000784 C188              AJMP     sendUUID
  171: 				break;
  172: 			default:
000786         ?C0011?UART:
000786 300108            JNB      isSetUUIDCommand,?C0021?UART
  173: 				sendUART("Unknown Command\r\n");
  174: 		}		
  175: 	} else if (isSetUUIDCommand) {
  176: 		setUUID(command);
000789 AB3F              MOV      R3,command
00078B AA40              MOV      R2,command+01H
00078D A941              MOV      R1,command+02H
00078F C119              AJMP     _setUUID
  177: 	} else {
000791         ?C0021?UART:
  178: 		sendUART("Unknown Command\r\n");
000791         
000791 7BFF              MOV      R3,#0FFH
000793 7A03              MOV      R2,#HIGH 0100036BH
000795 796B              MOV      R1,#LOW 0100036BH
000797 C104              AJMP     _sendUART
  179: 	}
----- FUNCTION _processCommand (END) -------


----- FUNCTION sendHVRelayStatus (BEGIN) -----
 FILE: 'DeviceController.c'
   88: void sendHVRelayStatus() {
   89: 	if (isAllHVRelayOK()) {
   90: 		sendUART("HV_OK\r\n");
000799 1120              ACALL    isAllHVRelayOK
00079B 7BFF              MOV      R3,#0FFH
00079D 5006              JNC      ?C0017?DEVICECONTROLLER
   91: 	} else {
00079F 7A02              MOV      R2,#HIGH 010002B8H
0007A1 79B8              MOV      R1,#LOW 010002B8H
   92: 		sendUART("HV_NG\r\n");		
0007A3 8004              SJMP     ?C0040?DEVICECONTROLLER
0007A5         ?C0017?DEVICECONTROLLER:
   93: 	}
0007A5 7A02              MOV      R2,#HIGH 010002C0H
0007A7 79C0              MOV      R1,#LOW 010002C0H
0007A9         
0007A9 C104              AJMP     _sendUART
   94: }
----- FUNCTION sendHVRelayStatus (END) -------


----- FUNCTION getFlashDataEndAddress (BEGIN) -----
 FILE: 'FlashUtils.c'
   12: unsigned char code * getFlashDataEndAddress() {
   13:   // Initialize the pointer to the FLASH (Checking if there is a valid data)
   14:   unsigned char code * EECurrentAddr = (unsigned char code*)FLASH_LAST_ADDR;
;---- Variable 'EECurrentAddr' assigned to Register 'R6/R7' ----
0007AB 7F00              MOV      R7,#00H
0007AD 7EAC              MOV      R6,#0ACH
   15:   unsigned char code * EETempAddr;
   16:           
   17:   for (EETempAddr = (unsigned char code*)FLASH_FIRST_ADDR; EETempAddr <= (unsigned char code*)FLASH_LAST_ADDR; EE
>> TempAddr += BYTES_PER_WORDLINE)
;---- Variable 'EETempAddr' assigned to Register 'DPTR' ----
0007AF 90A000            MOV      DPTR,#0A000H
0007B2         ?C0001?FLASHUTILS:
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  11:02:42  PAGE 10


0007B2 D3                SETB     C
0007B3 E582              MOV      A,DPL
0007B5 9400              SUBB     A,#00H
0007B7 E583              MOV      A,DPH
0007B9 94AC              SUBB     A,#0ACH
0007BB 5017              JNC      ?C0002?FLASHUTILS
   18: 	{
   19: 		if (*EETempAddr == 0)
0007BD E4                CLR      A
0007BE 93                MOVC     A,@A+DPTR
0007BF 7006              JNZ      ?C0003?FLASHUTILS
   20: 		{
   21: 			EECurrentAddr = EETempAddr;
0007C1 AE83              MOV      R6,DPH
0007C3 AF82              MOV      R7,DPL
   22: 			break;
0007C5 800D              SJMP     ?C0002?FLASHUTILS
   23: 		}
   24: 	}
0007C7         ?C0003?FLASHUTILS:
0007C7 7420              MOV      A,#020H
0007C9 2582              ADD      A,DPL
0007CB F582              MOV      DPL,A
0007CD E4                CLR      A
0007CE 3583              ADDC     A,DPH
0007D0 F583              MOV      DPH,A
0007D2 80DE              SJMP     ?C0001?FLASHUTILS
0007D4         ?C0002?FLASHUTILS:
   25: 	return EECurrentAddr;
   26: }
0007D4 22                RET      
----- FUNCTION getFlashDataEndAddress (END) -------


----- FUNCTION UART_vInit (BEGIN) -----
 FILE: 'UART.C'
   60: void UART_vInit(void)
   61: {
   62:   ///  -----------------------------------------------------------------------
   63:   ///  UART settings
   64:   ///  -----------------------------------------------------------------------
   65:   ///  Pin TXD_1 (P0.2) is selected for transmission
   66:   ///  Pin RXD_1 (P0.1) is selected for reception
   67:   ///  Receiver enabled
   68:   ///  Mode 1: 8-bit data, 1 start bit, 1 stop bit, variable baud rate
   69:   ///  Receiver interrupt flag RI will only be activated if a valid stop bit 
   70:   ///  was received
   71:   ///  BRG is selected for baudrate generation
   72: 
   73:   SFR_PAGE(_pp2, noSST);         // switch to page 2 without saving
0007D5 75B202            MOV      PORT_PAGE,#02H
   74:   P0_ALTSEL0   &= ~(ubyte)0x04;  // configure alternate function register 0
0007D8 5380FB            ANL      P0_ALTSEL0,#0FBH
   75:   P0_ALTSEL1   |=  (ubyte)0x04;  // configure alternate function register 1
0007DB 438604            ORL      P0_ALTSEL1,#04H
   76:   SFR_PAGE(_pp0, noSST);         // switch to page 0 without saving
0007DE E4                CLR      A
0007DF F5B2              MOV      PORT_PAGE,A
   77:   P0_DIR       |=  (ubyte)0x04;  // set output direction
0007E1 438604            ORL      P0_DIR,#04H
   78: 
   79: 
   80:   MODPISEL     |=  (ubyte)0x01;  // configure peripheral input select register
0007E4 43B301            ORL      MODPISEL,#01H
   81:   BCON          =  0x00;         // reset baudrate timer/reload register
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  11:02:42  PAGE 11


0007E7 F5BD              MOV      BCON,A
   82:   SCON          =  0x70;         // load serial channel control register
0007E9 759870            MOV      SCON,#070H
   83: 
   84:   ///  -----------------------------------------------------------------------
   85:   ///  Baudrate generator settings
   86:   ///  -----------------------------------------------------------------------
   87:   ///  input clock = fPCLK
   88:   ///  Fractional divider is enabled
   89:   ///  baudrate = 9.6004 kbaud
   90: 
   91:   FDSTEP        =  0xD5;         // load fractional divider reload register
0007EC 75EAD5            MOV      FDSTEP,#0D5H
   92:   BG            =  0x81;         // load baudrate timer/reload register
0007EF 75BE81            MOV      BG,#081H
   93:   FDCON        |=  0x01;         // load Fractional Divider control register
0007F2 43E901            ORL      FDCON,#01H
   94:   BCON         |=  0x01;         // load baud rate control register
0007F5 43BD01            ORL      BCON,#01H
   95: 
   96:   ///  UART interrupt enabled
   97:   ES = 1;
0007F8 D2AC              SETB     ES
   98: 
   99: } //  End of function UART_vInit
0007FA 22                RET      
----- FUNCTION UART_vInit (END) -------


----- FUNCTION _delay (BEGIN) -----
 FILE: 'MAIN.C'
   70: void delay(int second) {
   71:   int i, j, k;
;---- Variable 'second' assigned to Register 'R6/R7' ----
   72:   for (i = 0; i < second; i++) {
;---- Variable 'i' assigned to Register 'R4/R5' ----
0007FB E4                CLR      A
0007FC FD                MOV      R5,A
0007FD FC                MOV      R4,A
0007FE         ?C0002?MAIN:
0007FE C3                CLR      C
0007FF ED                MOV      A,R5
000800 9F                SUBB     A,R7
000801 EE                MOV      A,R6
000802 6480              XRL      A,#080H
000804 F8                MOV      R0,A
000805 EC                MOV      A,R4
000806 6480              XRL      A,#080H
000808 98                SUBB     A,R0
000809 5023              JNC      ?C0011?MAIN
   73:     for (j = 0; j < 25; j++) {
;---- Variable 'j' assigned to Register 'R2/R3' ----
00080B E4                CLR      A
00080C FB                MOV      R3,A
00080D FA                MOV      R2,A
00080E         ?C0005?MAIN:
   74:       for (k = 0; k < 30000; k++) {
;---- Variable 'k' assigned to Register 'DPTR' ----
00080E 900000            MOV      DPTR,#00H
000811         ?C0008?MAIN:
   75:       }
000811 A3                INC      DPTR
000812 E582              MOV      A,DPL
000814 B430FA            CJNE     A,#030H,?C0008?MAIN
000817 E583              MOV      A,DPH
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  11:02:42  PAGE 12


000819 B475F5            CJNE     A,#075H,?C0008?MAIN
   76:     }
00081C         ?C0007?MAIN:
00081C 0B                INC      R3
00081D BB0001            CJNE     R3,#00H,?C0017?MAIN
000820 0A                INC      R2
000821         ?C0017?MAIN:
000821 EB                MOV      A,R3
000822 6419              XRL      A,#019H
000824 4A                ORL      A,R2
000825 70E7              JNZ      ?C0005?MAIN
   77:   }
000827         ?C0004?MAIN:
000827 0D                INC      R5
000828 BD0001            CJNE     R5,#00H,?C0018?MAIN
00082B 0C                INC      R4
00082C         ?C0018?MAIN:
00082C 80D0              SJMP     ?C0002?MAIN
   78: }
00082E         ?C0011?MAIN:
00082E 22                RET      
----- FUNCTION _delay (END) -------


----- FUNCTION UART_viIsr (BEGIN) -----
 FILE: 'UART.C'
  182: void UART_viIsr(void) interrupt UARTINT
00082F C0E0              PUSH     ACC
000831 C0F0              PUSH     B
000833 C083              PUSH     DPH
000835 C082              PUSH     DPL
000837 C0D0              PUSH     PSW
000839 75D000            MOV      PSW,#00H
00083C C000              PUSH     AR0
00083E C001              PUSH     AR1
000840 C002              PUSH     AR2
000842 C003              PUSH     AR3
000844 C004              PUSH     AR4
000846 C005              PUSH     AR5
000848 C006              PUSH     AR6
00084A C007              PUSH     AR7
  183: {
  184: 	// switch to page 0
  185:   SFR_PAGE(_su0, SST0);
00084C 75BF80            MOV      SCU_PAGE,#080H
  186:   if (TI)
00084F 309902            JNB      TI,?C0024?UART
  187:   {
  188: 		TI = 0;
000852 C299              CLR      TI
  189:   }
000854         ?C0024?UART:
  190:   if (RI)
000854 309855            JNB      RI,?C0025?UART
  191:   {
  192: 		char receiveByte = SBUF;
000857 85993E            MOV      receiveByte,SBUF
  193: 		if (receiveByte == '\r' || receiveByte == '\n' || bufferCount >= MAX_COMMAND_LENGTH-1) {
00085A E53E              MOV      A,receiveByte
00085C 640D              XRL      A,#0DH
00085E 6013              JZ       ?C0027?UART
000860 E53E              MOV      A,receiveByte
000862 640A              XRL      A,#0AH
000864 600D              JZ       ?C0027?UART
000866 C3                CLR      C
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  11:02:42  PAGE 13


000867 E509              MOV      A,bufferCount+01H
000869 9463              SUBB     A,#063H
00086B E508              MOV      A,bufferCount
00086D 6480              XRL      A,#080H
00086F 9480              SUBB     A,#080H
000871 4020              JC       ?C0026?UART
000873         ?C0027?UART:
  194: 			processCommand(receiveBuffer);
000873 7B01              MOV      R3,#01H
000875 7AF1              MOV      R2,#HIGH receiveBuffer
000877 7971              MOV      R1,#LOW receiveBuffer
000879 1206A3            LCALL    _processCommand
  195: 			memset(receiveBuffer, 0, MAX_COMMAND_LENGTH);			
00087C 7E00              MOV      R6,#00H
00087E 7F64              MOV      R7,#064H
000880 7D00              MOV      R5,#00H
000882 7B01              MOV      R3,#01H
000884 7AF1              MOV      R2,#HIGH receiveBuffer
000886 7971              MOV      R1,#LOW receiveBuffer
000888 1201E4            LCALL    ?C?MEMSET
  196: 			bufferCount = 0;
00088B 750800            MOV      bufferCount,#00H
00088E 750900            MOV      bufferCount+01H,#00H
  197: 		} else {
000891 8017              SJMP     ?C0028?UART
000893         ?C0026?UART:
  198: 			receiveBuffer[bufferCount] = receiveByte;
000893 7471              MOV      A,#LOW receiveBuffer
000895 2509              ADD      A,bufferCount+01H
000897 F582              MOV      DPL,A
000899 74F1              MOV      A,#HIGH receiveBuffer
00089B 3508              ADDC     A,bufferCount
00089D F583              MOV      DPH,A
00089F E53E              MOV      A,receiveByte
0008A1 F0                MOVX     @DPTR,A
  199: 			bufferCount++;
0008A2 0509              INC      bufferCount+01H
0008A4 E509              MOV      A,bufferCount+01H
0008A6 7002              JNZ      ?C0030?UART
0008A8 0508              INC      bufferCount
0008AA         ?C0030?UART:
  200: 		}
0008AA         ?C0028?UART:
  201:     RI = 0;
0008AA C298              CLR      RI
  202:   }
0008AC         ?C0025?UART:
  203: 
  204: 	// restore the old page
  205:   SFR_PAGE(_su0, RST0);
0008AC 75BFC0            MOV      SCU_PAGE,#0C0H
  206: }
0008AF D007              POP      AR7
0008B1 D006              POP      AR6
0008B3 D005              POP      AR5
0008B5 D004              POP      AR4
0008B7 D003              POP      AR3
0008B9 D002              POP      AR2
0008BB D001              POP      AR1
0008BD D000              POP      AR0
0008BF D0D0              POP      PSW
0008C1 D082              POP      DPL
0008C3 D083              POP      DPH
0008C5 D0F0              POP      B
0008C7 D0E0              POP      ACC
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  11:02:42  PAGE 14


0008C9 32                RETI     
----- FUNCTION UART_viIsr (END) -------


----- FUNCTION _enableLCChannel (BEGIN) -----
 FILE: 'DeviceController.c'
   16: void enableLCChannel(char channelCode) {
   17: 	// Switch off all LCR channel first.
;---- Variable 'channelCode' assigned to Register 'R7' ----
   18: 	IO_vResetPin(LC_CHANNEL_1);
0008CA C2B1              CLR      P3_1
   19: 	IO_vResetPin(LC_CHANNEL_2);
0008CC C2B3              CLR      P3_3
   20: 	IO_vResetPin(LC_CHANNEL_3);
0008CE C2B5              CLR      P3_5
   21: 	
   22: 	// Enable coressponding LCR channel GPIO
   23: 	switch(channelCode) {
0008D0 EF                MOV      A,R7
0008D1 24CF              ADD      A,#0CFH
0008D3 6012              JZ       ?C0004?DEVICECONTROLLER
0008D5 14                DEC      A
0008D6 6019              JZ       ?C0005?DEVICECONTROLLER
0008D8 14                DEC      A
0008D9 6020              JZ       ?C0006?DEVICECONTROLLER
0008DB 2403              ADD      A,#03H
0008DD 7026              JNZ      ?C0007?DEVICECONTROLLER
   24: 		case '0':
0008DF         ?C0003?DEVICECONTROLLER:
   25: 			sendUART("#b#0#\r\n");
0008DF 7BFF              MOV      R3,#0FFH
0008E1 7A02              MOV      R2,#HIGH 0100024BH
0008E3 794B              MOV      R1,#LOW 0100024BH
   26: 			break;
0008E5 8024              SJMP     ?C0035?DEVICECONTROLLER
   27: 		case '1':
0008E7         ?C0004?DEVICECONTROLLER:
   28: 			IO_vSetPin(LC_CHANNEL_1);
0008E7 D2B1              SETB     P3_1
   29: 			sendUART("#b#1#\r\n");
0008E9 7BFF              MOV      R3,#0FFH
0008EB 7A02              MOV      R2,#HIGH 01000253H
0008ED 7953              MOV      R1,#LOW 01000253H
0008EF         
   30: 			break;
0008EF 801A              SJMP     ?C0035?DEVICECONTROLLER
   31: 		case '2':
0008F1         ?C0005?DEVICECONTROLLER:
   32: 			IO_vSetPin(LC_CHANNEL_2);
0008F1 D2B3              SETB     P3_3
   33: 			sendUART("#b#2#\r\n");		
0008F3 7BFF              MOV      R3,#0FFH
0008F5 7A02              MOV      R2,#HIGH 0100025BH
0008F7 795B              MOV      R1,#LOW 0100025BH
0008F9         
   34: 			break;
0008F9 8010              SJMP     ?C0035?DEVICECONTROLLER
   35: 		case '3':
0008FB         ?C0006?DEVICECONTROLLER:
   36: 			IO_vSetPin(LC_CHANNEL_3);
0008FB D2B5              SETB     P3_5
   37: 			sendUART("#b#3#\r\n");
0008FD 7BFF              MOV      R3,#0FFH
0008FF 7A02              MOV      R2,#HIGH 01000263H
000901 7963              MOV      R1,#LOW 01000263H
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  11:02:42  PAGE 15


000903         
   38: 			break;
000903 8006              SJMP     ?C0035?DEVICECONTROLLER
   39: 		default:
000905         ?C0007?DEVICECONTROLLER:
   40: 			sendUART("Unknown LC Channel.\r\n");			
000905 7BFF              MOV      R3,#0FFH
000907 7A02              MOV      R2,#HIGH 0100026BH
000909 796B              MOV      R1,#LOW 0100026BH
00090B         
00090B 020604            LJMP     _sendUART
   41: 			break;
   42: 	}
----- FUNCTION _enableLCChannel (END) -------


----- FUNCTION _enableLCRChannel (BEGIN) -----
 FILE: 'DeviceController.c'
   45: void enableLCRChannel(char channelCode) {
   46: 	// Switch off all LCR channel first.
;---- Variable 'channelCode' assigned to Register 'R7' ----
   47: 	IO_vResetPin(LCR_CHANNEL_1);
00090E C2B0              CLR      P3_0
   48: 	IO_vResetPin(LCR_CHANNEL_2);
000910 C2B2              CLR      P3_2
   49: 	IO_vResetPin(LCR_CHANNEL_3);
000912 C2B4              CLR      P3_4
   50: 	
   51: 	// Enable coressponding LCR channel GPIO
   52: 	switch(channelCode) {
000914 EF                MOV      A,R7
000915 24CF              ADD      A,#0CFH
000917 6012              JZ       ?C0011?DEVICECONTROLLER
000919 14                DEC      A
00091A 6019              JZ       ?C0012?DEVICECONTROLLER
00091C 14                DEC      A
00091D 6020              JZ       ?C0013?DEVICECONTROLLER
00091F 2403              ADD      A,#03H
000921 7026              JNZ      ?C0014?DEVICECONTROLLER
   53: 		case '0':
000923         ?C0010?DEVICECONTROLLER:
   54: 			sendUART("#a#0#\r\n");
000923 7BFF              MOV      R3,#0FFH
000925 7A02              MOV      R2,#HIGH 01000281H
000927 7981              MOV      R1,#LOW 01000281H
   55: 			break;
000929 8024              SJMP     ?C0039?DEVICECONTROLLER
   56: 		case '1':
00092B         ?C0011?DEVICECONTROLLER:
   57: 			IO_vSetPin(LCR_CHANNEL_1);
00092B D2B0              SETB     P3_0
   58: 			sendUART("#a#1#\r\n");
00092D 7BFF              MOV      R3,#0FFH
00092F 7A02              MOV      R2,#HIGH 01000289H
000931 7989              MOV      R1,#LOW 01000289H
000933         
   59: 			break;
000933 801A              SJMP     ?C0039?DEVICECONTROLLER
   60: 		case '2':
000935         ?C0012?DEVICECONTROLLER:
   61: 			IO_vSetPin(LCR_CHANNEL_2);
000935 D2B2              SETB     P3_2
   62: 			sendUART("#a#2#\r\n");		
000937 7BFF              MOV      R3,#0FFH
000939 7A02              MOV      R2,#HIGH 01000291H
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  11:02:42  PAGE 16


00093B 7991              MOV      R1,#LOW 01000291H
00093D         
   63: 			break;
00093D 8010              SJMP     ?C0039?DEVICECONTROLLER
   64: 		case '3':
00093F         ?C0013?DEVICECONTROLLER:
   65: 			IO_vSetPin(LCR_CHANNEL_3);
00093F D2B4              SETB     P3_4
   66: 			sendUART("#a#3#\r\n");
000941 7BFF              MOV      R3,#0FFH
000943 7A02              MOV      R2,#HIGH 01000299H
000945 7999              MOV      R1,#LOW 01000299H
000947         
   67: 			break;
000947 8006              SJMP     ?C0039?DEVICECONTROLLER
   68: 		default:
000949         ?C0014?DEVICECONTROLLER:
   69: 			sendUART("Unknown LCR Channel.\r\n");			
000949 7BFF              MOV      R3,#0FFH
00094B 7A02              MOV      R2,#HIGH 010002A1H
00094D 79A1              MOV      R1,#LOW 010002A1H
00094F         
00094F 020604            LJMP     _sendUART
   70: 			break;
   71: 	}
----- FUNCTION _enableLCRChannel (END) -------


----- FUNCTION _setChargeMode (BEGIN) -----
 FILE: 'DeviceController.c'
   96: void setChargeMode(char modeCode) {
   97: 	if (modeCode == '1') {
000952 8F44              MOV      modeCode,R7
   98: 		if (!isAllHVRelayOK()) {
000954 E544              MOV      A,modeCode
000956 6431              XRL      A,#031H
000958 7021              JNZ      ?C0020?DEVICECONTROLLER
   99: 			IO_vResetPin(HV_CHANNEL);			
00095A 120020            LCALL    isAllHVRelayOK
00095D 400E              JC       ?C0021?DEVICECONTROLLER
  100: 			IO_vResetPin(CHARGE_CHANNEL);
00095F C2B6              CLR      P3_6
  101: 			IO_vResetPin(DISCHARGE_CHANNEL);
000961 C2B7              CLR      P3_7
  102: 			sendUART("HV_NG\r\n");
000963 C292              CLR      P1_2
  103: 			return;
000965 7BFF              MOV      R3,#0FFH
000967 7A02              MOV      R2,#HIGH 010002C0H
000969 79C0              MOV      R1,#LOW 010002C0H
00096B 8027              SJMP     ?C0043?DEVICECONTROLLER
  104: 		}
00096D         ?C0021?DEVICECONTROLLER:
  105: 		IO_vResetPin(DISCHARGE_CHANNEL);
00096D C292              CLR      P1_2
  106: 		IO_vSetPin(HV_CHANNEL);
00096F D2B6              SETB     P3_6
  107: 		IO_vSetPin(CHARGE_CHANNEL);
000971 D2B7              SETB     P3_7
  108: 		sendUART("#c#1#\r\n");
000973 7BFF              MOV      R3,#0FFH
000975 7A02              MOV      R2,#HIGH 010002C8H
000977 79C8              MOV      R1,#LOW 010002C8H
000979         
  109: 	} else if (modeCode == '0') {
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  11:02:42  PAGE 17


000979 8019              SJMP     ?C0043?DEVICECONTROLLER
00097B         ?C0020?DEVICECONTROLLER:
00097B E544              MOV      A,modeCode
00097D B4300E            CJNE     A,#030H,?C0024?DEVICECONTROLLER
  110: 		IO_vResetPin(CHARGE_CHANNEL);
000980 C2B7              CLR      P3_7
  111: 		IO_vResetPin(HV_CHANNEL);
000982 C2B6              CLR      P3_6
  112: 		IO_vSetPin(DISCHARGE_CHANNEL);
000984 D292              SETB     P1_2
  113: 		sendUART("#c#0#\r\n");
000986 7BFF              MOV      R3,#0FFH
000988 7A02              MOV      R2,#HIGH 010002D0H
00098A 79D0              MOV      R1,#LOW 010002D0H
00098C         
  114: 	} else {
00098C 8006              SJMP     ?C0043?DEVICECONTROLLER
00098E         ?C0024?DEVICECONTROLLER:
  115: 		sendUART("Unknown Charge Mode\r\n");		
00098E 7BFF              MOV      R3,#0FFH
000990 7A02              MOV      R2,#HIGH 010002D8H
000992 79D8              MOV      R1,#LOW 010002D8H
000994         
000994 020604            LJMP     _sendUART
  116: 	}
----- FUNCTION _setChargeMode (END) -------


----- FUNCTION _setHVMonitorMode (BEGIN) -----
 FILE: 'DeviceController.c'
  119: void setHVMonitorMode(char modeCode) {
  120: 	if (modeCode == '1') {
000997 8F44              MOV      modeCode,R7
  121: 		shouldMonitorHVStatus = 1;
000999 E544              MOV      A,modeCode
00099B B4310A            CJNE     A,#031H,?C0026?DEVICECONTROLLER
  122: 		sendUART("#e#1#\r\n");
00099E D203              SETB     shouldMonitorHVStatus
  123: 	} else if (modeCode == '0') {
0009A0 7BFF              MOV      R3,#0FFH
0009A2 7A02              MOV      R2,#HIGH 010002EEH
0009A4 79EE              MOV      R1,#LOW 010002EEH
  124: 		shouldMonitorHVStatus = 0;
0009A6 8015              SJMP     ?C0045?DEVICECONTROLLER
0009A8         ?C0026?DEVICECONTROLLER:
0009A8 E544              MOV      A,modeCode
0009AA B4300A            CJNE     A,#030H,?C0028?DEVICECONTROLLER
  125: 		sendUART("#e#0#\r\n");
0009AD C203              CLR      shouldMonitorHVStatus
  126: 	} else {
0009AF 7BFF              MOV      R3,#0FFH
0009B1 7A02              MOV      R2,#HIGH 010002F6H
0009B3 79F6              MOV      R1,#LOW 010002F6H
0009B5         
  127: 		sendUART("Unknown HV Monitor Code\r\n");
0009B5 8006              SJMP     ?C0045?DEVICECONTROLLER
0009B7         ?C0028?DEVICECONTROLLER:
  128: 	}
0009B7 7BFF              MOV      R3,#0FFH
0009B9 7A02              MOV      R2,#HIGH 010002FEH
0009BB 79FE              MOV      R1,#LOW 010002FEH
0009BD         
0009BD 020604            LJMP     _sendUART
  129: 	
----- FUNCTION _setHVMonitorMode (END) -------
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  11:02:42  PAGE 18




----- FUNCTION FLASH_Erase_Abort (BEGIN) -----
 FILE: 'FlashHandler.c'
   75: bit FLASH_Erase_Abort (void)
   76: {
   77: #ifdef __C51__		
   78: 	((void (code *) (void)) FLASH_ERASE_ABORT) ();
0009C0 12DFF3            LCALL    0DFF3H
   79: #endif	// __C51__
   80: #ifdef	SDCC
   81: _asm
   82: 	LCALL FLASH_ERASE_ABORT;
   83: _endasm;
   84: #endif	// SDCC
   85: 	return (!CY);  
0009C3 B3                CPL      C
   86: }
0009C4 22                RET      
----- FUNCTION FLASH_Erase_Abort (END) -------


----- FUNCTION _FLASH_Ready (BEGIN) -----
 FILE: 'FlashHandler.c'
   90: bit FLASH_Ready						(unsigned char BankNum)
   91: {
;---- Variable 'BankNum' assigned to Register 'R7' ----
   92:     ACC = BankNum;
   93: #ifdef __C51__		
0009C5 EF                MOV      A,R7
   94: 	((void (code *) (void)) FLASH_READ_STATUS) ();
0009C6 02DFF0            LJMP     0DFF0H
   95: #endif	// __C51__
   96: #ifdef	SDCC
   97: _asm
   98: 	LCALL FLASH_READ_STATUS;
   99: _endasm;
  100: #endif	// SDCC
  101: 	return(CY);
----- FUNCTION _FLASH_Ready (END) -------


----- FUNCTION _readFlashToBuffer (BEGIN) -----
 FILE: 'FlashUtils.c'
   46: void readFlashToBuffer(char xdata * buffer, int n, unsigned char code * EECurrentAddr) 
   47: {
0009C9 8E44              MOV      buffer,R6
0009CB 8F45              MOV      buffer+01H,R7
0009CD 8C46              MOV      n,R4
0009CF 8D47              MOV      n+01H,R5
0009D1 8A48              MOV      EECurrentAddr,R2
0009D3 8B49              MOV      EECurrentAddr+01H,R3
   48: 	unsigned char code * EETempAddr = (unsigned char code*)FLASH_FIRST_ADDR;
   49: 	int i = 0;
0009D5 754AA0            MOV      EETempAddr,#0A0H
0009D8 754B00            MOV      EETempAddr+01H,#00H
   50: 	int j = 0;
0009DB E4                CLR      A
0009DC F54C              MOV      i,A
0009DE F54D              MOV      i+01H,A
   51: 	int k = 0;
0009E0 F54E              MOV      j,A
0009E2 F54F              MOV      j+01H,A
   52: 	memset(buffer, 0, n);
0009E4 F550              MOV      k,A
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  11:02:42  PAGE 19


0009E6 F551              MOV      k+01H,A
   53: 	
0009E8 AE46              MOV      R6,n
0009EA AF47              MOV      R7,n+01H
0009EC FD                MOV      R5,A
0009ED AA44              MOV      R2,buffer
0009EF A945              MOV      R1,buffer+01H
0009F1 7B01              MOV      R3,#01H
0009F3 1201E4            LCALL    ?C?MEMSET
0009F6         ?C0011?FLASHUTILS:
   54: 	while (FLASH_Ready(FLASH_BANK_TO_CHECK) == 0) {;}
0009F6 7F03              MOV      R7,#03H
0009F8 31C5              ACALL    _FLASH_Ready
0009FA 50FA              JNC      ?C0011?FLASHUTILS
0009FC         ?C0012?FLASHUTILS:
0009FC         ?C0013?FLASHUTILS:
   55: 	
   56: 	while (EETempAddr < EECurrentAddr && j < n) 
0009FC C3                CLR      C
0009FD E54B              MOV      A,EETempAddr+01H
0009FF 9549              SUBB     A,EECurrentAddr+01H
000A01 E54A              MOV      A,EETempAddr
000A03 9548              SUBB     A,EECurrentAddr
000A05 5054              JNC      ?C0017?FLASHUTILS
000A07 C3                CLR      C
000A08 E54F              MOV      A,j+01H
000A0A 9547              SUBB     A,n+01H
000A0C E546              MOV      A,n
000A0E 6480              XRL      A,#080H
000A10 F8                MOV      R0,A
000A11 E54E              MOV      A,j
000A13 6480              XRL      A,#080H
000A15 98                SUBB     A,R0
000A16 5043              JNC      ?C0017?FLASHUTILS
   57: 	{	
   58: 		i = 0;
000A18 E4                CLR      A
000A19 F54C              MOV      i,A
000A1B F54D              MOV      i+01H,A
000A1D         ?C0015?FLASHUTILS:
   59: 		while (*(EETempAddr+i) != 0) {
000A1D E54B              MOV      A,EETempAddr+01H
000A1F 254D              ADD      A,i+01H
000A21 F582              MOV      DPL,A
000A23 E54A              MOV      A,EETempAddr
000A25 354C              ADDC     A,i
000A27 F583              MOV      DPH,A
000A29 E4                CLR      A
000A2A 93                MOVC     A,@A+DPTR
000A2B FF                MOV      R7,A
000A2C 6020              JZ       ?C0016?FLASHUTILS
   60: 			buffer[j] = *(EETempAddr+i);
000A2E E545              MOV      A,buffer+01H
000A30 254F              ADD      A,j+01H
000A32 F582              MOV      DPL,A
000A34 E544              MOV      A,buffer
000A36 354E              ADDC     A,j
000A38 F583              MOV      DPH,A
000A3A EF                MOV      A,R7
000A3B F0                MOVX     @DPTR,A
   61: 			i++;
000A3C 054D              INC      i+01H
000A3E E54D              MOV      A,i+01H
000A40 7002              JNZ      ?C0025?FLASHUTILS
000A42 054C              INC      i
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  11:02:42  PAGE 20


000A44         ?C0025?FLASHUTILS:
   62: 			j++;
000A44 054F              INC      j+01H
000A46 E54F              MOV      A,j+01H
000A48 7002              JNZ      ?C0026?FLASHUTILS
000A4A 054E              INC      j
000A4C         ?C0026?FLASHUTILS:
   63: 		}
000A4C 80CF              SJMP     ?C0015?FLASHUTILS
000A4E         ?C0016?FLASHUTILS:
   64: 		EETempAddr = EETempAddr + BYTES_PER_WORDLINE;		
000A4E 7420              MOV      A,#020H
000A50 254B              ADD      A,EETempAddr+01H
000A52 F54B              MOV      EETempAddr+01H,A
000A54 E4                CLR      A
000A55 354A              ADDC     A,EETempAddr
000A57 F54A              MOV      EETempAddr,A
   65: 	}	
000A59 80A1              SJMP     ?C0013?FLASHUTILS
   66: }
000A5B         ?C0017?FLASHUTILS:
000A5B 22                RET      
----- FUNCTION _readFlashToBuffer (END) -------


----- FUNCTION _FLASH_Prog (BEGIN) -----
 FILE: 'FlashHandler.c'
  113: bit FLASH_Prog					(unsigned char code* WLAddress) 
  114: {
;---- Variable 'WLAddress' assigned to Register 'R6/R7' ----
  115: #ifdef	XC88x
  116: 	volatile bit success;		    // needed for CY flag saving of the BROM routine's result
  117: #endif	// XC88x
  118: #ifdef	XC866
  119: #define USE_BANK  3					// fix the used registerbank to 3 for XC866 devices
  120: #endif	// XC866
  121: 									// For SDCC parameter is now already in DPTR
  122: #ifdef SDCC
  123: 	*WLAddress;						// avoid warning of 'unreferenced function argument
  124: #endif	// SDCC
  125: #ifdef __C51__
  126:    DPTR = (unsigned int)WLAddress;
000A5C 8E83              MOV      DPH,R6
000A5E 8F82              MOV      DPL,R7
  127: #endif	// __C51__
  128: 
  129:    REG[(0+(USE_BANK*8))] = WORDLINE_BUFFER_ADDRESS;
000A60 7818              MOV      R0,#018H
000A62 76E0              MOV      @R0,#0E0H
  130: #ifdef	XC88x
  131: 	PUSH(PSW);
000A64 C0D0              PUSH     PSW
  132: 	PSW = ((USE_BANK)<<3);
000A66 75D018            MOV      PSW,#018H
  133: #endif	// XC88x
  134: 
  135: #ifdef	__C51__		
  136: 	((void (code *) (void)) FLASH_PROG) ();
000A69 12DFF6            LCALL    0DFF6H
  137: #endif	// __C51__
  138: #ifdef	SDCC
  139: _asm
  140: 	LCALL FLASH_PROG;
  141: _endasm;
  142: #endif	// SDCC
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  11:02:42  PAGE 21


  143: 
  144: #ifdef	XC88x
  145: 	success = CY;
000A6C 9202              MOV      success,C
  146: 	POP(PSW);
000A6E D0D0              POP      PSW
  147: 	return(!success);			  
000A70 A202              MOV      C,success
000A72 B3                CPL      C
  148: #endif	// XC88x
  149: #ifdef	XC866
  150: 	return (!CY);
  151: #endif	// XC866
  152: }
000A73 22                RET      
----- FUNCTION _FLASH_Prog (END) -------


----- FUNCTION _writeToFlashPage (BEGIN) -----
 FILE: 'FlashUtils.c'
   29: void writeToFlashPage(char xdata * buffer, unsigned char code ** EECurrentAddr) {
   30: 	int i = 0;
000A74 8E54              MOV      buffer,R6
000A76 8F55              MOV      buffer+01H,R7
000A78 8B56              MOV      EECurrentAddr,R3
000A7A 8A57              MOV      EECurrentAddr+01H,R2
000A7C 8958              MOV      EECurrentAddr+02H,R1
   31: 
;---- Variable 'i' assigned to Register 'R6/R7' ----
000A7E E4                CLR      A
000A7F FF                MOV      R7,A
000A80 FE                MOV      R6,A
   32: 	for (i=0; i < BYTES_PER_WORDLINE; i++) {
000A81         ?C0006?FLASHUTILS:
   33: 		WLBuf[i] = *buffer;
000A81 855582            MOV      DPL,buffer+01H
000A84 855483            MOV      DPH,buffer
000A87 E0                MOVX     A,@DPTR
000A88 FD                MOV      R5,A
000A89 74E0              MOV      A,#LOW WLBuf
000A8B 2F                ADD      A,R7
000A8C F8                MOV      R0,A
000A8D A605              MOV      @R0,AR5
   34: 		buffer++;
000A8F 0555              INC      buffer+01H
000A91 E555              MOV      A,buffer+01H
000A93 7002              JNZ      ?C0023?FLASHUTILS
000A95 0554              INC      buffer
000A97         ?C0023?FLASHUTILS:
   35: 	}
000A97 0F                INC      R7
000A98 BF0001            CJNE     R7,#00H,?C0024?FLASHUTILS
000A9B 0E                INC      R6
000A9C         ?C0024?FLASHUTILS:
000A9C EF                MOV      A,R7
000A9D 6420              XRL      A,#020H
000A9F 4E                ORL      A,R6
000AA0 70DF              JNZ      ?C0006?FLASHUTILS
000AA2         ?C0007?FLASHUTILS:
   36: 
   37: 	// Start the Flash Programming
   38: 	if (FLASH_Prog(*EECurrentAddr)) 
000AA2 AB56              MOV      R3,EECurrentAddr
000AA4 AA57              MOV      R2,EECurrentAddr+01H
000AA6 A958              MOV      R1,EECurrentAddr+02H
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  11:02:42  PAGE 22


000AA8 120162            LCALL    ?C?ILDPTR
000AAB FF                MOV      R7,A
000AAC AEF0              MOV      R6,B
000AAE 515C              ACALL    _FLASH_Prog
000AB0 500D              JNC      ?C0009?FLASHUTILS
   39: 	{
   40: 		*EECurrentAddr = *EECurrentAddr + BYTES_PER_WORDLINE;
000AB2 AB56              MOV      R3,EECurrentAddr
000AB4 AA57              MOV      R2,EECurrentAddr+01H
000AB6 A958              MOV      R1,EECurrentAddr+02H
000AB8 E4                CLR      A
000AB9 75F020            MOV      B,#020H
000ABC 12018D            LCALL    ?C?IILDPTR
   41: 	}
000ABF         ?C0009?FLASHUTILS:
   42: 	delay(2);
000ABF 7F02              MOV      R7,#02H
000AC1 7E00              MOV      R6,#00H
000AC3 0207FB            LJMP     _delay
----- FUNCTION _writeToFlashPage (END) -------


----- FUNCTION _writeBufferToFlash (BEGIN) -----
 FILE: 'FlashUtils.c'
   68: void writeBufferToFlash(char * buffer, unsigned char code ** EECurrentAddr) {
   69: 	char xdata pageBuffer[BYTES_PER_WORDLINE] = {0};
000AC6 8B49              MOV      buffer,R3
000AC8 8A4A              MOV      buffer+01H,R2
000ACA 894B              MOV      buffer+02H,R1
   70: 	char * currentCharacter = buffer;
000ACC 78ED              MOV      R0,#LOW pageBuffer
000ACE 7CF0              MOV      R4,#HIGH pageBuffer
000AD0 7D01              MOV      R5,#01H
000AD2 7BFF              MOV      R3,#0FFH
000AD4 7A05              MOV      R2,#HIGH _?ix1000
000AD6 79A0              MOV      R1,#LOW _?ix1000
000AD8 7E00              MOV      R6,#00H
000ADA 7F20              MOV      R7,#020H
000ADC 1200F6            LCALL    ?C?COPY
   71: 	int i = 0;
000ADF 85494F            MOV      currentCharacter,buffer
000AE2 854A50            MOV      currentCharacter+01H,buffer+01H
000AE5 854B51            MOV      currentCharacter+02H,buffer+02H
   72: 	
000AE8 E4                CLR      A
000AE9 F552              MOV      i,A
000AEB F553              MOV      i+01H,A
   73: 	FLASH_Erase(SECALL,0);
000AED FD                MOV      R5,A
000AEE FC                MOV      R4,A
000AEF 7FFF              MOV      R7,#0FFH
000AF1 7E03              MOV      R6,#03H
000AF3 717E              ACALL    _FLASH_Erase
   74: 	*EECurrentAddr = (unsigned char code*)FLASH_FIRST_ADDR;			// if erase than 1. WL is current
000AF5 AB4C              MOV      R3,EECurrentAddr
000AF7 AA4D              MOV      R2,EECurrentAddr+01H
000AF9 A94E              MOV      R1,EECurrentAddr+02H
000AFB 74A0              MOV      A,#0A0H
000AFD 75F000            MOV      B,#00H
000B00 1201C5            LCALL    ?C?ISTPTR
   75:   delay(2);
000B03 7F02              MOV      R7,#02H
000B05 7E00              MOV      R6,#00H
000B07 1207FB            LCALL    _delay
   76: 	
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  11:02:42  PAGE 23


   77: 	memset(pageBuffer, 0, BYTES_PER_WORDLINE);
000B0A 7E00              MOV      R6,#00H
000B0C 7F20              MOV      R7,#020H
000B0E 7D00              MOV      R5,#00H
000B10 7B01              MOV      R3,#01H
000B12 7AF0              MOV      R2,#HIGH pageBuffer
000B14 79ED              MOV      R1,#LOW pageBuffer
000B16 1201E4            LCALL    ?C?MEMSET
000B19         ?C0018?FLASHUTILS:
   78: 	while (*currentCharacter != 0) {
000B19 AB4F              MOV      R3,currentCharacter
000B1B AA50              MOV      R2,currentCharacter+01H
000B1D A951              MOV      R1,currentCharacter+02H
000B1F 12011C            LCALL    ?C?CLDPTR
000B22 FF                MOV      R7,A
000B23 604D              JZ       ?C0019?FLASHUTILS
   79: 		
   80: 		pageBuffer[i] = *currentCharacter;
000B25 74ED              MOV      A,#LOW pageBuffer
000B27 2553              ADD      A,i+01H
000B29 F582              MOV      DPL,A
000B2B 74F0              MOV      A,#HIGH pageBuffer
000B2D 3552              ADDC     A,i
000B2F F583              MOV      DPH,A
000B31 EF                MOV      A,R7
000B32 F0                MOVX     @DPTR,A
   81: 		if (i == 25) {
000B33 E553              MOV      A,i+01H
000B35 6419              XRL      A,#019H
000B37 4552              ORL      A,i
000B39 7022              JNZ      ?C0020?FLASHUTILS
   82: 			writeToFlashPage(pageBuffer, EECurrentAddr);
000B3B 7EF0              MOV      R6,#HIGH pageBuffer
000B3D 7FED              MOV      R7,#LOW pageBuffer
000B3F AB4C              MOV      R3,EECurrentAddr
000B41 AA4D              MOV      R2,EECurrentAddr+01H
000B43 A94E              MOV      R1,EECurrentAddr+02H
000B45 5174              ACALL    _writeToFlashPage
   83: 			memset(pageBuffer, 0, BYTES_PER_WORDLINE);
000B47 7E00              MOV      R6,#00H
000B49 7F20              MOV      R7,#020H
000B4B 7D00              MOV      R5,#00H
000B4D 7B01              MOV      R3,#01H
000B4F 7AF0              MOV      R2,#HIGH pageBuffer
000B51 79ED              MOV      R1,#LOW pageBuffer
000B53 1201E4            LCALL    ?C?MEMSET
   84: 			i = 0;
000B56 E4                CLR      A
000B57 F552              MOV      i,A
000B59 F553              MOV      i+01H,A
   85: 		} else {
000B5B 8008              SJMP     ?C0021?FLASHUTILS
000B5D         ?C0020?FLASHUTILS:
   86: 			i++;
000B5D 0553              INC      i+01H
000B5F E553              MOV      A,i+01H
000B61 7002              JNZ      ?C0027?FLASHUTILS
000B63 0552              INC      i
000B65         ?C0027?FLASHUTILS:
   87: 		}
000B65         ?C0021?FLASHUTILS:
   88: 		currentCharacter++;
000B65 7401              MOV      A,#01H
000B67 2551              ADD      A,currentCharacter+02H
000B69 F551              MOV      currentCharacter+02H,A
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  11:02:42  PAGE 24


000B6B E4                CLR      A
000B6C 3550              ADDC     A,currentCharacter+01H
000B6E F550              MOV      currentCharacter+01H,A
   89: 	}
000B70 80A7              SJMP     ?C0018?FLASHUTILS
000B72         ?C0019?FLASHUTILS:
   90: 	writeToFlashPage(pageBuffer, EECurrentAddr);	
000B72 7EF0              MOV      R6,#HIGH pageBuffer
000B74 7FED              MOV      R7,#LOW pageBuffer
000B76 AB4C              MOV      R3,EECurrentAddr
000B78 AA4D              MOV      R2,EECurrentAddr+01H
000B7A A94E              MOV      R1,EECurrentAddr+02H
000B7C 4174              AJMP     _writeToFlashPage
----- FUNCTION _writeBufferToFlash (END) -------


----- FUNCTION _FLASH_Erase (BEGIN) -----
 FILE: 'FlashHandler.c'
  161: bit FLASH_Erase			(unsigned int DFlash0Sector,unsigned int DFlash1Sector)
  162: #endif	// XC88x
;---- Variable 'DFlash1Sector' assigned to Register 'R4/R5' ----
;---- Variable 'DFlash0Sector' assigned to Register 'R6/R7' ----
  163: {
  164: #ifdef	XC88x
  165:     volatile bit success; 
  166: #endif	// XC88x
  167: 	t_unFLPARAM P1;
  168: #ifdef	XC88x
  169: 	t_unFLPARAM P2;
  170: #endif	// XC88x
  171: 
  172: #ifdef	XC866
  173: #define USE_BANK  3								// fix the used registerbank to 3 for XC866 devices
  174: #endif	// XC866
  175: 
  176: 	P1.UINT_Param = DFlash0Sector;
000B7E 8E54              MOV      P1,R6
000B80 8F55              MOV      P1+01H,R7
  177: #ifdef	XC88x
  178: 	P2.UINT_Param = DFlash1Sector;
000B82 8C56              MOV      P2,R4
000B84 8D57              MOV      P2+01H,R5
  179: #endif	// XC88x
  180: 	
  181: #ifdef	XC866
  182: 	REG[(4+(USE_BANK*8))] = P1.UBYTE_Param[0];	// DFLASH0 Sector - BANK3 - High Adr Byte
  183: 	REG[(3+(USE_BANK*8))] = P1.UBYTE_Param[1];	// DFLASH0 Sector - BANK3 - Low  Adr Byte
  184: #endif	// XC866
  185: #ifdef	XC88x
  186: 	REG[(1+(USE_BANK*8))] = P1.UBYTE_Param[0];	// DFLASH0 Sector -         High Adr Byte
000B86 7819              MOV      R0,#019H
000B88 A654              MOV      @R0,P1
  187: 	REG[(0+(USE_BANK*8))] = P1.UBYTE_Param[1];	// DFLASH0 Sector -         Low  Adr Byte
000B8A 18                DEC      R0
000B8B A655              MOV      @R0,P1+01H
  188: 	REG[(4+(USE_BANK*8))] = P2.UBYTE_Param[0];	// DFLASH1 Sector  
000B8D 781C              MOV      R0,#01CH
000B8F A656              MOV      @R0,P2
  189: 	REG[(3+(USE_BANK*8))] = P2.UBYTE_Param[1];	// DFLASH1 Sector  
000B91 18                DEC      R0
000B92 A657              MOV      @R0,P2+01H
  190: #endif	// XC88x
  191: 	REG[(5+(USE_BANK*8))] = 0;					// PFLASH  
000B94 781D              MOV      R0,#01DH
000B96 E4                CLR      A
LX51 LINKER/LOCATER V4.66.41.0                                                        03/18/2016  11:02:42  PAGE 25


000B97 F6                MOV      @R0,A
  192: 	REG[(6+(USE_BANK*8))] = 0;					// PFLASH  
000B98 08                INC      R0
000B99 F6                MOV      @R0,A
  193: 	REG[(7+(USE_BANK*8))] = 0;					// PFLASH  
000B9A 08                INC      R0
000B9B F6                MOV      @R0,A
  194: 
  195: #ifdef XC88x
  196: 	PUSH(PSW);
000B9C C0D0              PUSH     PSW
  197: 	PSW = ((USE_BANK)<<3);
000B9E 75D018            MOV      PSW,#018H
  198: #endif	// XC88x
  199: 
  200: #ifdef	__C51__
  201: 	((void (code *) (void)) FLASH_ERASE) ();
000BA1 12DFF9            LCALL    0DFF9H
  202: #endif	// __C51__
  203: #ifdef	SDCC
  204: _asm
  205: 	LCALL FLASH_ERASE;
  206: _endasm;
  207: #endif	// SDCC
  208: 
  209: #ifdef	XC866
  210: 	return(!CY);
  211: #endif	// XC866
  212: #ifdef	XC88x
  213: 	success = CY;
000BA4 9202              MOV      success,C
  214: 	POP(PSW);
000BA6 D0D0              POP      PSW
  215: 	return (!success);
000BA8 A202              MOV      C,success
000BAA B3                CPL      C
  216: #endif	// XC88x
  217: }
000BAB 22                RET      
----- FUNCTION _FLASH_Erase (END) -------


