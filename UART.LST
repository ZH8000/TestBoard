C51 COMPILER V9.54   UART                                                                  03/16/2016 12:24:09 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN UART.OBJ
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE UART.C OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          //****************************************************************************
   2          // @Module        UART (Serial Interface)
   3          // @Filename      UART.C
   4          // @Project       TestBoard.dav
   5          //----------------------------------------------------------------------------
   6          // @Controller    Infineon XC888CLM-8FF
   7          //
   8          // @Compiler      Keil
   9          //
  10          // @Codegenerator 1.7
  11          //
  12          // @Description:  This file contains functions that use the UART module.
  13          //
  14          //----------------------------------------------------------------------------
  15          // @Date          2016/3/15 16:17:36
  16          //
  17          //****************************************************************************
  18          
  19          
  20          //****************************************************************************
  21          // @Project Includes
  22          //****************************************************************************
  23          
  24          #include "MAIN.H"
  25          #include <string.h>
  26          #include <stdio.h>
  27          
  28          
  29          
  30          //****************************************************************************
  31          // @Function      void UART_vInit(void) 
  32          //
  33          //----------------------------------------------------------------------------
  34          // @Description   This is the initialization function of the UART function 
  35          //                library. It is assumed that the SFRs used by this library 
  36          //                are in their reset state. 
  37          //                
  38          //                The following SFR fields will be initialized:
  39          //                - register SCON
  40          //                - bits SMOD and ES
  41          //
  42          //----------------------------------------------------------------------------
  43          // @Returnvalue   None
  44          //
  45          //----------------------------------------------------------------------------
  46          // @Parameters    None
  47          //
  48          //----------------------------------------------------------------------------
  49          // @Date          2016/3/15
  50          //
  51          //****************************************************************************
  52          
  53          // USER CODE BEGIN (UART_Init,1)
  54          
  55          // USER CODE END
C51 COMPILER V9.54   UART                                                                  03/16/2016 12:24:09 PAGE 2   

  56          
  57          void UART_vInit(void)
  58          {
  59   1        ///  -----------------------------------------------------------------------
  60   1        ///  UART settings
  61   1        ///  -----------------------------------------------------------------------
  62   1        ///  Pin TXD_1 (P0.2) is selected for transmission
  63   1        ///  Pin RXD_1 (P0.1) is selected for reception
  64   1        ///  Receiver enabled
  65   1        ///  Mode 1: 8-bit data, 1 start bit, 1 stop bit, variable baud rate
  66   1        ///  Receiver interrupt flag RI will only be activated if a valid stop bit 
  67   1        ///  was received
  68   1        ///  BRG is selected for baudrate generation
  69   1      
  70   1        SFR_PAGE(_pp2, noSST);         // switch to page 2 without saving
  71   1        P0_ALTSEL0   &= ~(ubyte)0x04;  // configure alternate function register 0
  72   1        P0_ALTSEL1   |=  (ubyte)0x04;  // configure alternate function register 1
  73   1        SFR_PAGE(_pp0, noSST);         // switch to page 0 without saving
  74   1        P0_DIR       |=  (ubyte)0x04;  // set output direction
  75   1      
  76   1      
  77   1        MODPISEL     |=  (ubyte)0x01;  // configure peripheral input select register
  78   1        BCON          =  0x00;         // reset baudrate timer/reload register
  79   1        SCON          =  0x70;         // load serial channel control register
  80   1      
  81   1        ///  -----------------------------------------------------------------------
  82   1        ///  Baudrate generator settings
  83   1        ///  -----------------------------------------------------------------------
  84   1        ///  input clock = fPCLK
  85   1        ///  Fractional divider is enabled
  86   1        ///  baudrate = 9.6004 kbaud
  87   1      
  88   1        FDSTEP        =  0xD5;         // load fractional divider reload register
  89   1        BG            =  0x81;         // load baudrate timer/reload register
  90   1        FDCON        |=  0x01;         // load Fractional Divider control register
  91   1        BCON         |=  0x01;         // load baud rate control register
  92   1      
  93   1        ///  UART interrupt enabled
  94   1        ES = 1;
  95   1      
  96   1      } //  End of function UART_vInit
  97          
  98          
  99          //****************************************************************************
 100          // @Function      void UART_viIsr(void) 
 101          //
 102          //----------------------------------------------------------------------------
 103          // @Description   This is the service routine for the UART interrupt. It is 
 104          //                called after each transmission (flag TI set) or reception 
 105          //                (flag RI set) of a data unit.
 106          //                Please note that you have to add application specific code 
 107          //                to this function.
 108          //
 109          //----------------------------------------------------------------------------
 110          // @Returnvalue   None
 111          //
 112          //----------------------------------------------------------------------------
 113          // @Parameters    None
 114          //
 115          //----------------------------------------------------------------------------
 116          // @Date          2016/3/15
 117          //
C51 COMPILER V9.54   UART                                                                  03/16/2016 12:24:09 PAGE 3   

 118          //****************************************************************************
 119          
 120          //   You have two choices for interrupt type select in Project Settings Page 
 121          //   under Global Settings Section.
 122          //   If you select CHOICE 1 then ISR will be generated with push and pop.
 123          //   If you select CHOICE 2 then ISR will be generated without push and pop.
 124          //   Default choice is CHOICE 2.
 125          //   Current selection is CHOICE 2 
 126          
 127          
 128          void sendUART(char * message) {
 129   1        char * current = message;
 130   1        while (*current != '\0') {
 131   2          SBUF = *current;
 132   2          while (TI == 0);
 133   2          TI = 0;   
 134   2          current++;
 135   2        }
 136   1      }
 137          
 138          
 139          char receiveBuffer[20] = {0};
 140          int bufferCount = 0;
 141          
 142          void enableLCChannel(char channelCode) {
 143   1        // Switch off all LCR channel first.
 144   1        IO_vResetPin(P3_1);
 145   1        IO_vResetPin(P3_3);
 146   1        IO_vResetPin(P3_5);
 147   1        
 148   1        // Enable coressponding LCR channel GPIO
 149   1        switch(channelCode) {
 150   2          case '0':
 151   2            sendUART("#b#0#\r\n");
 152   2            break;
 153   2          case '1':
 154   2            IO_vSetPin(P3_1);
 155   2            sendUART("#b#1#\r\n");
 156   2            break;
 157   2          case '2':
 158   2            IO_vSetPin(P3_3);
 159   2            sendUART("#b#2#\r\n");    
 160   2            break;
 161   2          case '3':
 162   2            IO_vSetPin(P3_5);
 163   2            sendUART("#b#3#\r\n");
 164   2            break;
 165   2          default:
 166   2            sendUART("Unknown LC Channel.\r\n");      
 167   2            break;
 168   2        }
 169   1      }
 170          
 171          void enableLCRChannel(char channelCode) {
 172   1        // Switch off all LCR channel first.
 173   1        IO_vResetPin(P3_0);
 174   1        IO_vResetPin(P3_2);
 175   1        IO_vResetPin(P3_4);
 176   1        
 177   1        // Enable coressponding LCR channel GPIO
 178   1        switch(channelCode) {
 179   2          case '0':
C51 COMPILER V9.54   UART                                                                  03/16/2016 12:24:09 PAGE 4   

 180   2            sendUART("#a#0#\r\n");
 181   2            break;
 182   2          case '1':
 183   2            IO_vSetPin(P3_0);
 184   2            sendUART("#a#1#\r\n");
 185   2            break;
 186   2          case '2':
 187   2            IO_vSetPin(P3_2);
 188   2            sendUART("#a#2#\r\n");    
 189   2            break;
 190   2          case '3':
 191   2            IO_vSetPin(P3_4);
 192   2            sendUART("#a#3#\r\n");
 193   2            break;
 194   2          default:
 195   2            sendUART("Unknown LCR Channel.\r\n");     
 196   2            break;
 197   2        }
 198   1      }
 199          
 200          void processCommand(char * command) {
 201   1        int commandSize = strlen(command);
 202   1        char respondMessage[20] = {0};
 203   1        memset(respondMessage, 0, 20);
 204   1        if (commandSize != 5 || command[0] != '$' || command[4] != '$') {
 205   2          sendUART("Unknown Command\r\n");
 206   2        } else {
 207   2          switch(command[1]) {
 208   3            case 'a':
 209   3              enableLCRChannel(command[3]);
 210   3              break;
 211   3            case 'b':
 212   3              enableLCChannel(command[3]);
 213   3              break;
 214   3            default:
 215   3              sendUART("Unknown Command\r\n");
 216   3          }
 217   2        }
 218   1      }
 219          
 220          void UART_viIsr(void) interrupt UARTINT
 221          {
 222   1        // switch to page 0
 223   1        SFR_PAGE(_su0, SST0);
 224   1        if (TI)
 225   1        {
 226   2          TI = 0;
 227   2        }
 228   1        if (RI)
 229   1        {
 230   2          char receiveByte = SBUF;
 231   2          if (receiveByte == '\r' || receiveByte == '\n' || bufferCount >= 18) {
 232   3            processCommand(receiveBuffer);
 233   3            memset(receiveBuffer, 0, 20);     
 234   3            bufferCount = 0;
 235   3          } else {
 236   3            receiveBuffer[bufferCount] = receiveByte;
 237   3            bufferCount++;
 238   3          }
 239   2          RI = 0;
 240   2        }
 241   1      
C51 COMPILER V9.54   UART                                                                  03/16/2016 12:24:09 PAGE 5   

 242   1        // restore the old page
 243   1        SFR_PAGE(_su0, RST0);
 244   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    479    ----
   CONSTANT SIZE    =    147    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     22      26
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
